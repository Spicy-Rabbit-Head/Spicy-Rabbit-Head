{
  "name": "auto-complete",
  "type": "registry:component",
  "description": "在输入时提供一些选项帮助快速完成，可以当搜索框用。",
  "files": [
    {
      "target": "components/auto-complete/auto-complete.vue",
      "content": "<script setup lang=\"ts\">\nimport { useFieldStore } from \"@/components/form\";\nimport { Icon } from \"@/components/icon\";\n\nimport { Select } from \"@/components/select\";\n\nimport {\n  computed,\n  nextTick,\n  onMounted,\n  ref,\n  toRef,\n  watch,\n  watchEffect,\n} from \"vue\";\n\nimport {\n  createIconProp,\n  createSizeProp,\n  createStateProp,\n  emitEvent,\n  useLocale,\n  useNameHelper,\n  useProps,\n} from \"@pocui/config\";\nimport { placementWhileList, useSetTimeout } from \"@pocui/hooks\";\nimport { debounce, isNullish, throttle, toNumber } from \"@pocui/utils\";\n\nimport { autoCompleteProps } from \"./props\";\n\nimport type { SelectOptionState } from \"@/components/select\";\n\nimport type { AutoCompleteRawOption, ChangeEvent, EnterEvent } from \"./symbol\";\n\ndefineOptions({\n  name: \"AutoComplete\",\n  description: \"在输入时提供一些选项帮助快速完成，可以当搜索框用。\",\n  categories: [\"form\"],\n});\n\nconst select = ref<InstanceType<typeof Select>>();\nconst control = ref<HTMLInputElement>();\n\nconst {\n  idFor,\n  state,\n  disabled,\n  loading,\n  size,\n  validateField,\n  clearField,\n  getFieldValue,\n  setFieldValue,\n} = useFieldStore<string | number>(() => control.value?.focus());\n\nconst nh = useNameHelper(\"auto-complete\");\n\nconst _props = defineProps(autoCompleteProps);\nconst props = useProps(\"autoComplete\", _props, {\n  size: createSizeProp(size),\n  state: createStateProp(state),\n  locale: null,\n  transfer: false,\n  value: {\n    default: () => getFieldValue(\"\"),\n    static: true,\n  },\n  options: {\n    default: () => [],\n    static: true,\n  },\n  filter: false,\n  prefix: createIconProp(),\n  prefixColor: \"\",\n  suffix: createIconProp(),\n  suffixColor: \"\",\n  placeholder: null,\n  disabled: () => disabled.value,\n  transitionName: () => nh.ns(\"drop\"),\n  dropDisabled: false,\n  placement: {\n    default: \"bottom\",\n    validator: (value) => placementWhileList.includes(value),\n  },\n  clearable: false,\n  ignoreCase: false,\n  autofocus: false,\n  spellcheck: false,\n  keyConfig: () => ({}),\n  loading: () => loading.value,\n  loadingIcon: createIconProp(),\n  loadingLock: false,\n  loadingEffect: null,\n  transparent: false,\n  debounce: false,\n  delay: null,\n  showEmpty: false,\n  name: {\n    default: \"\",\n    static: true,\n  },\n  popperAlive: null,\n});\n\nconst emit = defineEmits([\"update:value\"]);\n\nconst slots = defineSlots<{\n  append(): any;\n  control(props: {\n    value: string | number;\n    onInput: (event: string | Event) => void;\n    onChange: (valid?: boolean) => void;\n    onEnter: (event: KeyboardEvent) => void;\n    onClear: () => void;\n  }): any;\n  default(props: {\n    option: SelectOptionState;\n    index: number;\n    selected: boolean;\n  }): any;\n  prefix(): any;\n  prepend(): any;\n  suffix(): any;\n  group(props: { option: SelectOptionState; index: number }): any;\n}>();\n\nconst locale = useLocale(\"input\", toRef(props, \"locale\"));\n\nconst { timer } = useSetTimeout();\n\nconst currentValue = ref(props.value);\nconst currentIndex = ref(-1);\nconst currentVisible = ref(false);\nconst composing = ref(false);\n\nlet changed = false;\nlet lastValue = props.value;\nlet lastInput = String(lastValue);\n\nconst isReadonly = computed(() => props.loading && props.loadingLock);\nconst optionStates = computed(() => select.value?.optionStates || []);\nconst filteredOptions = computed(() => select.value?.visibleOptions || []);\nconst hasPrefix = computed(() => !!(slots.prefix || props.prefix));\nconst hasSuffix = computed(() => !!(slots.suffix || props.suffix));\n\nwatch(\n  () => props.value,\n  (value) => {\n    currentValue.value = value;\n    lastValue = value;\n    lastInput = String(value);\n\n    if (control.value) {\n      control.value.value = String(value);\n    }\n  },\n);\nwatch(currentIndex, computeHitting);\nwatch(currentVisible, (value) => {\n  if (!value) {\n    currentIndex.value = -1;\n  } else {\n    control.value?.focus();\n  }\n});\nwatch(currentValue, (value) => {\n  if (props.filter && select.value) {\n    select.value.currentFilter = `${value}`;\n  }\n});\nwatchEffect(() => {\n  if (!props.filter || !currentVisible.value || !select.value) return;\n\n  select.value.currentFilter = String(currentValue.value);\n});\n\ndefineExpose({\n  idFor,\n  composing,\n  select,\n  control,\n  focus: (options?: FocusOptions) => control.value?.focus(options),\n  blur: () => control.value?.blur(),\n});\n\nonMounted(() => {\n  nextTick(() => {\n    if (control.value && !isNullish(currentValue.value)) {\n      control.value.value = String(currentValue.value);\n    }\n  });\n});\n\nfunction computeHitting() {\n  const hitting = currentIndex.value;\n  let index = -1;\n\n  optionStates.value.forEach((state) => {\n    if (!state.hidden) {\n      index += 1;\n      state.hitting = hitting === index;\n\n      if (state.hitting) {\n        if (control.value) {\n          control.value.value = String(state.value);\n        }\n      }\n    } else {\n      state.hitting = false;\n    }\n  });\n\n  if (control.value && hitting < 0) {\n    control.value.value = lastInput;\n  }\n}\n\nlet focused = false;\n\nfunction handleFocus(event: FocusEvent) {\n  if (!focused) {\n    focused = true;\n    emitEvent(props.onFocus, event);\n  }\n}\n\nfunction handleBlur(event: FocusEvent) {\n  if (focused) {\n    focused = false;\n\n    timer.focus = setTimeout(() => {\n      if (!focused) {\n        emitEvent(props.onBlur, event);\n        handleChange();\n      }\n    }, 120);\n  }\n}\n\nfunction handleSelect(value: string | number, data: AutoCompleteRawOption) {\n  if (composing.value || isNullish(value)) {\n    return;\n  }\n\n  const prevValue = currentValue.value;\n  currentValue.value = value;\n\n  emitEvent(props.onSelect as ChangeEvent, value, data);\n\n  if (value !== prevValue) {\n    changed = true;\n    handleChange();\n  } else {\n    currentVisible.value = false;\n  }\n}\n\nfunction handleInputInternal(event: string | Event) {\n  const value =\n    typeof event === \"string\"\n      ? event\n      : (event.target as HTMLInputElement).value;\n\n  currentValue.value = value;\n  changed = true;\n  lastInput = value;\n\n  if (currentIndex.value !== -1) {\n    currentIndex.value = 0;\n  }\n\n  if (props.showEmpty) {\n    currentVisible.value = !props.dropDisabled;\n\n    if (select.value) {\n      select.value.currentVisible = currentVisible.value;\n    }\n  }\n\n  emitEvent(props.onInput, value);\n  nextTick(testOptionCanDrop);\n}\n\nconst delay = toNumber(props.delay);\nconst handleInput = props.debounce\n  ? debounce(handleInputInternal, delay || 100)\n  : throttle(handleInputInternal, delay || 16);\n\nfunction handleChange(valid = true) {\n  if (!changed || currentValue.value === lastValue) return;\n\n  changed = false;\n  lastValue = currentValue.value;\n  lastInput = String(lastValue);\n\n  const option = optionStates.value.find(\n    (option) => option.value === lastValue,\n  );\n\n  if (select.value) {\n    select.value.currentValues.length = 0;\n    (currentValue.value || currentValue.value === 0) &&\n      select.value.currentValues.push(currentValue.value);\n  }\n\n  emit(\"update:value\", currentValue.value);\n  setFieldValue(currentValue.value);\n  emitEvent(\n    props.onChange as ChangeEvent,\n    currentValue.value,\n    option?.data || null!,\n  );\n  valid && validateField();\n\n  currentVisible.value = false;\n\n  if (control.value) {\n    control.value.value = String(lastValue);\n  }\n}\n\nlet beforeVisible = false;\nlet inClickProcess = false;\n\nfunction beforeClick() {\n  if (props.disabled || isReadonly.value) return;\n\n  beforeVisible = currentVisible.value;\n  inClickProcess = true;\n\n  if (select.value) {\n    select.value.currentFilter = String(currentValue.value);\n  }\n}\n\nfunction handleClick() {\n  if (props.disabled || isReadonly.value) return;\n\n  inClickProcess = false;\n\n  if (!select.value) return;\n\n  currentVisible.value = true;\n\n  if (!beforeVisible) {\n    testOptionCanDrop();\n    beforeVisible = currentVisible.value;\n    beforeVisible && emitEvent(props.onToggle, beforeVisible);\n  } else {\n    select.value.currentVisible = true;\n  }\n}\n\nfunction handleToggle(visible: boolean) {\n  if (props.disabled || isReadonly.value || inClickProcess) return;\n\n  currentVisible.value = visible;\n\n  visible && testOptionCanDrop();\n  beforeVisible = currentVisible.value;\n\n  if (currentVisible.value !== visible) {\n    emitEvent(props.onToggle, currentVisible.value);\n  }\n\n  if (!currentVisible.value) {\n    currentIndex.value = -1;\n  }\n}\n\nfunction testOptionCanDrop() {\n  currentVisible.value = !(\n    props.dropDisabled ||\n    (!props.showEmpty && !filteredOptions.value.length)\n  );\n\n  if (select.value) {\n    select.value.currentVisible = currentVisible.value;\n  }\n}\n\nfunction handleKeyDown(event: KeyboardEvent) {\n  if (composing.value) {\n    event.stopPropagation();\n    return;\n  }\n\n  const key = event.code || event.key;\n\n  if (key === \"Enter\" || key === \"NumpadEnter\") {\n    handleEnter(event);\n  } else if (key === \"ArrowDown\" || key === \"ArrowUp\") {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const options = filteredOptions.value;\n    const length = options.length;\n\n    if (!length) return;\n\n    const step = key === \"ArrowDown\" ? 1 : -1;\n\n    // 初始状态时 currentIndex 为 -1，往上时会得到 -2 导致行为不按预期，需限制\n    let index = (Math.max(currentIndex.value + step, -1) + length) % length;\n    let option = options[index];\n\n    for (let i = 0; (option.disabled || option.group) && i < length; ++i) {\n      index += step;\n      index = (index + length) % length;\n      option = options[index];\n    }\n\n    currentIndex.value = index;\n  } else {\n    if ([\"Space\", \" \"].includes(key)) {\n      event.stopPropagation();\n    }\n\n    if (![\"Enter\", \"ArrowLeft\", \"ArrowRight\"].includes(key)) {\n      // 进行了其他按键则重置\n      currentIndex.value = -1;\n    }\n  }\n}\n\nfunction handleEnter(event: KeyboardEvent) {\n  event.stopPropagation();\n\n  if (composing.value) return;\n\n  if (currentIndex.value >= 0 && filteredOptions.value.length) {\n    const option =\n      filteredOptions.value[currentIndex.value === -1 ? 0 : currentIndex.value];\n\n    handleSelect(option.value, option.data);\n  } else {\n    handleChange();\n  }\n\n  emitEvent(props.onEnter as EnterEvent, currentValue.value);\n  currentVisible.value = false;\n}\n\nfunction handleClear() {\n  if (props.clearable) {\n    const prevValue = currentValue.value;\n\n    currentValue.value = \"\";\n    currentVisible.value = false;\n\n    if (!isNullish(prevValue) && prevValue !== currentValue.value) {\n      changed = true;\n    }\n\n    handleChange(false);\n    emitEvent(props.onClear);\n    nextTick(clearField);\n    control.value?.focus();\n  }\n}\n\nfunction handleCompositionEnd() {\n  if (composing.value) {\n    composing.value = false;\n\n    if (control.value) {\n      control.value.dispatchEvent(new Event(\"input\"));\n    }\n  }\n}\n</script>\n\n<template>\n  <Select\n    :id=\"idFor\"\n    ref=\"select\"\n    v-model:visible=\"currentVisible\"\n    :class=\"[nh.b(), props.inherit && nh.in()]\"\n    :inherit=\"props.inherit\"\n    :list-class=\"nh.be('list')\"\n    :value=\"currentValue\"\n    :size=\"props.size\"\n    :state=\"props.state\"\n    :clearable=\"props.clearable\"\n    :transition-name=\"props.transitionName\"\n    :disabled=\"props.disabled\"\n    :transfer=\"props.transfer\"\n    :placement=\"props.placement\"\n    :prefix-color=\"props.prefixColor\"\n    :suffix-color=\"props.suffixColor\"\n    :no-suffix=\"!hasSuffix\"\n    :placeholder=\"props.placeholder\"\n    :options=\"props.options\"\n    :key-config=\"props.keyConfig\"\n    :loading=\"props.loading\"\n    :loading-icon=\"props.loadingIcon\"\n    :loading-lock=\"props.loadingLock\"\n    :loading-effect=\"props.loadingEffect\"\n    :transparent=\"transparent\"\n    :filter=\"props.filter\"\n    :ignore-case=\"props.ignoreCase\"\n    :popper-alive=\"props.popperAlive\"\n    @toggle=\"handleToggle\"\n    @select=\"handleSelect\"\n    @clear=\"handleClear\"\n    @focus=\"control?.focus()\"\n    @outside-close=\"handleChange\"\n    @click=\"handleClick\"\n    @click.capture=\"beforeClick\"\n  >\n    <template v-if=\"hasPrefix\" #prefix>\n      <slot name=\"prefix\">\n        <Icon :icon=\"props.prefix\"></Icon>\n      </slot>\n    </template>\n    <template #control>\n      <slot\n        name=\"control\"\n        :value=\"currentValue\"\n        :on-input=\"handleInput\"\n        :on-change=\"handleChange\"\n        :on-enter=\"handleEnter\"\n        :on-clear=\"handleClear\"\n      >\n        <input\n          ref=\"control\"\n          :class=\"nh.be('input')\"\n          :autofocus=\"props.autofocus\"\n          :spellcheck=\"props.spellcheck\"\n          :disabled=\"props.disabled\"\n          :placeholder=\"props.placeholder ?? locale.placeholder\"\n          :readonly=\"isReadonly\"\n          :name=\"props.name\"\n          autocomplete=\"off\"\n          tabindex=\"-1\"\n          role=\"combobox\"\n          aria-autocomplete=\"list\"\n          @submit.prevent\n          @input=\"handleInput\"\n          @keydown=\"handleKeyDown\"\n          @focus=\"handleFocus($event)\"\n          @blur=\"handleBlur($event)\"\n          @compositionstart=\"composing = true\"\n          @compositionend=\"handleCompositionEnd\"\n          @change=\"handleCompositionEnd\"\n        />\n      </slot>\n    </template>\n    <template v-if=\"hasSuffix\" #suffix>\n      <slot name=\"suffix\">\n        <Icon :icon=\"props.suffix\"></Icon>\n      </slot>\n    </template>\n    <template v-if=\"$slots.default\" #default=\"{ option, index, selected }\">\n      <slot :option=\"option\" :index=\"index\" :selected=\"selected\"></slot>\n    </template>\n    <template v-if=\"$slots.group\" #group=\"{ option, index }\">\n      <slot name=\"group\" :option=\"option\" :index=\"index\"></slot>\n    </template>\n    <template v-if=\"$slots.prepend\" #prepend>\n      <slot name=\"prepend\"></slot>\n    </template>\n    <template v-if=\"$slots.append\" #append>\n      <slot name=\"append\"></slot>\n    </template>\n  </Select>\n</template>\n"
    },
    {
      "target": "components/auto-complete/index.ts",
      "content": "import AutoComplete from './auto-complete.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { AutoComplete }\nexport { autoCompleteProps } from './props'\n\nexport type AutoCompleteExposed = ComponentPublicInstance & InstanceType<typeof AutoComplete>\n\nexport type { AutoCompleteProps, AutoCompleteCProps } from './props'\nexport type { AutoCompleteKeyConfig, AutoCompleteRawOption, AutoCompleteFilter } from './symbol'\n"
    },
    {
      "target": "components/auto-complete/props.ts",
      "content": "import {\n  booleanProp,\n  booleanStringProp,\n  buildProps,\n  eventProp,\n  iconProp,\n  localeProp,\n  sizeProp,\n  stateProp\n} from '@pocui/config'\n\nimport type { IconEffect } from '@/components/icon'\nimport type { ConfigurableProps, EventListener } from '@pocui/config'\nimport type { Placement } from '@pocui/hooks'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type {\n  AutoCompleteFilter,\n  AutoCompleteKeyConfig,\n  AutoCompleteRawOption,\n  ChangeEvent,\n  EnterEvent\n} from './symbol'\n\nexport const autoCompleteProps = buildProps({\n  size: sizeProp,\n  state: stateProp,\n  locale: localeProp('input'),\n  transfer: booleanStringProp,\n  value: [String, Number],\n  options: Array as PropType<AutoCompleteRawOption[]>,\n  filter: {\n    type: [Boolean, Function] as PropType<boolean | AutoCompleteFilter>,\n    default: null\n  },\n  prefix: iconProp,\n  prefixColor: String,\n  suffix: iconProp,\n  suffixColor: String,\n  placeholder: String,\n  disabled: booleanProp,\n  transitionName: String,\n  dropDisabled: booleanProp,\n  placement: String as PropType<Placement>,\n  clearable: booleanProp,\n  ignoreCase: booleanProp,\n  autofocus: booleanProp,\n  spellcheck: booleanProp,\n  loading: booleanProp,\n  loadingIcon: iconProp,\n  loadingLock: booleanProp,\n  loadingEffect: String as PropType<IconEffect>,\n  transparent: booleanProp,\n  debounce: booleanProp,\n  delay: Number,\n  keyConfig: Object as PropType<Omit<AutoCompleteKeyConfig, 'label'>>,\n  showEmpty: booleanProp,\n  name: String,\n  popperAlive: booleanProp,\n  onFocus: eventProp<(event: FocusEvent) => void>(),\n  onBlur: eventProp<(event: FocusEvent) => void>(),\n  onSelect: eventProp<EventListener<ChangeEvent>>(),\n  onInput: eventProp<(value: string) => void>(),\n  onChange: eventProp<EventListener<ChangeEvent>>(),\n  onToggle: eventProp<(visible: boolean) => void>(),\n  onEnter: eventProp<EventListener<EnterEvent>>(),\n  onClear: eventProp()\n})\n\nexport type AutoCompleteProps = ExtractPropTypes<typeof autoCompleteProps>\nexport type AutoCompleteCProps = ConfigurableProps<ExtractPropTypes<typeof autoCompleteProps>>\n"
    },
    {
      "target": "components/auto-complete/symbol.ts",
      "content": "import type { SelectKeyConfig, SelectOptionState, SelectRawOption } from '@/components/select'\n\nexport type AutoCompleteKeyConfig = Omit<SelectKeyConfig, 'label'>\nexport type AutoCompleteRawOption = SelectRawOption\nexport type AutoCompleteOptionState = Omit<SelectOptionState, 'label' | 'parent' | 'data'> & {\n  parent: AutoCompleteOptionState | null,\n  data: AutoCompleteRawOption\n}\n\nexport type AutoCompleteFilter = (value: string | number, options: AutoCompleteOptionState) => boolean\n\nexport type ChangeEvent = (value: string | number, data: AutoCompleteRawOption) => void\nexport type EnterEvent = (value: string | number) => void\n"
    }
  ],
  "dependencies": ["vue", "@pocui/hooks", "@pocui/utils", "@pocui/config"],
  "registryDependencies": ["auto-complete.scss", "form", "icon", "select"],
  "categories": ["form"],
  "meta": { "isReferenceOnly": false }
}
