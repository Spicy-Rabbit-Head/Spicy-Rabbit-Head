{
  "name": "native-scroll",
  "type": "registry:component",
  "description": "用于需要展示超出一个区域范围的内容，可以使用户滚动浏览，内部实现采用浏览器原生滚动以获得更好的兼容性与性能。",
  "files": [
    {
      "target": "components/native-scroll/helper.ts",
      "content": "interface ScrollElement {\n  scrollTo(x: number, y: number): void,\n  [prop: string]: any\n}\n\nexport function animateScrollTo(options: {\n  el: ScrollElement,\n  xFrom?: number,\n  xTo?: number,\n  yFrom?: number,\n  yTo?: number,\n  duration?: number,\n  callback?: null | (() => any)\n}): void {\n  const { el, xFrom = 0, xTo = 0, yFrom = 0, yTo = 0, duration = 500, callback = null } = options\n\n  if (!el) return\n\n  if (duration <= 0) {\n    el.scrollTo(xTo, yTo)\n    return\n  }\n\n  const xDistance = xTo - xFrom\n  const yDistance = yTo - yFrom\n\n  if (!xDistance && !yDistance) return\n\n  const xStep = Math.ceil((xDistance / duration) * 16)\n  const yStep = Math.ceil((yDistance / duration) * 16)\n\n  let currentX = xFrom\n  let currentY = yFrom\n\n  const scroll = () => {\n    currentX += xStep\n    currentY += yStep\n\n    if (xDistance && (xTo - currentX) / xDistance <= 0) {\n      currentX = xTo\n    }\n\n    if (yDistance && (yTo - currentY) / yDistance <= 0) {\n      currentY = yTo\n    }\n\n    el.scrollTo(currentX, currentY)\n\n    if ((!xDistance || currentX === xTo) && (!yDistance || currentY === yTo)) {\n      typeof callback === 'function' && callback()\n    } else {\n      requestAnimationFrame(scroll)\n    }\n  }\n\n  scroll()\n}\n"
    },
    {
      "target": "components/native-scroll/hooks.ts",
      "content": "import { computed, onMounted, reactive, ref, watch } from 'vue'\n\nimport { isHiddenElement, useManualRef, useMounted } from '@pocui/hooks'\nimport { boundRange, debounce, debounceMinor, isElement, multipleFixed } from '@pocui/utils'\n\nimport { animateScrollTo } from './helper'\n\nimport type { Ref } from 'vue'\n\nimport type { NativeScrollMode } from './symbol'\n\nexport function useScrollWrapper({\n  mode,\n  disabled,\n  appear,\n  scrollX,\n  scrollY,\n  onResize,\n  onBeforeRefresh,\n  onAfterRefresh\n}: {\n  mode: Ref<NativeScrollMode>,\n  disabled: Ref<boolean>,\n  appear: Ref<boolean>,\n  scrollX: Ref<number>,\n  scrollY: Ref<number>,\n  onResize?: (entity: ResizeObserverEntry) => void,\n  onBeforeRefresh?: () => void,\n  onAfterRefresh?: () => void\n}) {\n  const { manualRef, triggerUpdate } = useManualRef()\n\n  const syncing = ref(false)\n\n  const contentEl = ref<HTMLElement>()\n\n  const content = reactive({\n    el: contentEl,\n    scrollWidth: 0,\n    offsetWidth: 0,\n    scrollHeight: 0,\n    offsetHeight: 0\n  })\n\n  // 当前滚动位置\n  const x = manualRef(0)\n  const y = manualRef(0)\n\n  const percentX = manualRef(0)\n  const percentY = manualRef(0)\n\n  const xScrollLimit = computed(() => {\n    return content.el ? content.scrollWidth - content.offsetWidth : 0\n  })\n  const yScrollLimit = computed(() => {\n    return content.el ? content.scrollHeight - content.offsetHeight : 0\n  })\n  const enableXScroll = computed(() => {\n    return !disabled.value && mode.value !== 'vertical' && !!content.el && content.scrollWidth > content.offsetWidth\n  })\n  const enableYScroll = computed(() => {\n    return !disabled.value && mode.value !== 'horizontal' && !!content.el && content.scrollHeight > content.offsetHeight\n  })\n  const xBarLength = computed(() => {\n    if (content.el) {\n      return boundRange((content.offsetWidth / (content.scrollWidth || 1)) * 100, 5, 99)\n    }\n\n    return 35\n  })\n  const yBarLength = computed(() => {\n    if (content.el) {\n      return boundRange((content.offsetHeight / (content.scrollHeight || 1)) * 100, 5, 99)\n    }\n\n    return 35\n  })\n\n  watch(contentEl, () => {\n    computeContentSize()\n  })\n  watch(scrollX, value => {\n    setScrollX(value)\n  })\n  watch(scrollY, value => {\n    setScrollY(value)\n  })\n\n  function setScrollX(value: number) {\n    x.value = boundRange(value, 0, xScrollLimit.value)\n    syncScroll()\n  }\n\n  function setScrollY(value: number) {\n    y.value = boundRange(value, 0, yScrollLimit.value)\n    syncScroll()\n  }\n\n  function syncScroll() {\n    syncing.value = true\n\n    if (content.el) {\n      content.el.scrollTo({\n        top: y.value,\n        left: x.value,\n        behavior: 'instant'\n      })\n    }\n\n    setTimeout(() => {\n      syncing.value = false\n    }, 0)\n  }\n\n  const { isMounted } = useMounted()\n\n  function computeContentSize() {\n    if (!content.el || isHiddenElement(content.el)) return\n\n    content.scrollWidth = content.el.scrollWidth\n    content.offsetWidth = content.el.offsetWidth\n    content.scrollHeight = content.el.scrollHeight\n    content.offsetHeight = content.el.offsetHeight\n\n    if (mode.value !== 'vertical') {\n      setScrollX(!isMounted.value && appear.value ? scrollX.value : x.value || 0)\n    }\n\n    if (mode.value !== 'horizontal') {\n      setScrollY(!isMounted.value && appear.value ? scrollY.value : y.value || 0)\n    }\n\n    computePercent()\n    triggerUpdate()\n  }\n\n  function computePercent() {\n    if (content.el) {\n      percentX.value = multipleFixed(x.value / (xScrollLimit.value || 1), 100, 2)\n      percentY.value = multipleFixed(y.value / (yScrollLimit.value || 1), 100, 2)\n    }\n  }\n\n  function handleResize(entity: ResizeObserverEntry) {\n    refresh()\n    onResize?.(entity)\n  }\n\n  onMounted(() => {\n    refresh()\n\n    if (appear.value) {\n      scrollTo(scrollX.value, scrollY.value)\n    }\n  })\n\n  const refresh = debounceMinor(() => {\n    return new Promise<void>(resolve => {\n      if (typeof onBeforeRefresh === 'function') {\n        onBeforeRefresh()\n      }\n\n      computeContentSize()\n      setTimeout(() => {\n        if (typeof onAfterRefresh === 'function') {\n          onAfterRefresh()\n        }\n\n        resolve()\n      }, 0)\n    })\n  })\n\n  function scrollTo(clientX: number, clientY: number, duration = 500) {\n    return new Promise<void>(resolve => {\n      if (!content.el) return\n\n      if (!enableXScroll.value || Math.abs(x.value - clientX) < 0.01) {\n        clientX = x.value\n      }\n\n      if (!enableYScroll.value || Math.abs(y.value - clientY) < 0.01) {\n        clientY = y.value\n      }\n\n      animateScrollTo({\n        duration,\n        el: content.el,\n        xFrom: x.value,\n        xTo: boundRange(clientX, 0, xScrollLimit.value),\n        yFrom: y.value,\n        yTo: boundRange(clientY, 0, yScrollLimit.value),\n        callback: resolve\n      })\n    })\n  }\n\n  function scrollBy(deltaX: number, deltaY: number, duration = 500) {\n    return scrollTo(x.value + deltaX, y.value + deltaY, duration)\n  }\n\n  function scrollToElement(el: string | Element, duration?: number, offset = 0) {\n    if (!content.el) return Promise.resolve()\n\n    if (typeof el === 'string') {\n      el = content.el.querySelector(el)!\n    }\n\n    if (!isElement(el)) return Promise.resolve()\n\n    const wrapperRect = content.el.getBoundingClientRect()\n    const elRect = el.getBoundingClientRect()\n\n    let clientX = 0\n    let clientY = 0\n\n    if (mode.value !== 'vertical') {\n      clientX = elRect.left - wrapperRect.left + offset\n    }\n\n    if (mode.value !== 'horizontal') {\n      clientY = elRect.top - wrapperRect.top + offset\n    }\n\n    return scrollTo(clientX, clientY, duration)\n  }\n\n  return {\n    contentEl,\n\n    syncing,\n    content,\n    x,\n    y,\n    percentX,\n    percentY,\n    xScrollLimit,\n    yScrollLimit,\n    enableXScroll,\n    enableYScroll,\n    xBarLength,\n    yBarLength,\n\n    handleResize: debounce(handleResize),\n    setScrollX,\n    setScrollY,\n    computePercent,\n    refresh,\n    scrollTo,\n    scrollBy,\n    scrollToElement,\n    triggerUpdate\n  }\n}\n"
    },
    {
      "target": "components/native-scroll/index.ts",
      "content": "export { default as NativeScroll } from './native-scroll'\nexport { nativeScrollProps } from './props'\nexport { animateScrollTo } from './helper'\n\nexport type { NativeScrollProps, NativeScrollCProps } from './props'\nexport type { NativeScrollMode, NativeScrollPayload, NativeScrollSlotParams, NativeScrollExposed } from './symbol'\n"
    },
    {
      "target": "components/native-scroll/native-scroll.tsx",
      "content": "import { ResizeObserver } from '@/components/resize-observer'\nimport { Scrollbar } from '@/components/scrollbar'\n\nimport {\n  computed,\n  defineComponent,\n  nextTick,\n  onBeforeUnmount,\n  ref,\n  renderSlot,\n  shallowReadonly,\n  toRef,\n  watch\n} from 'vue'\n\nimport { emitEvent, useNameHelper, useProps } from '@pocui/config'\nimport { createSlotRender, flatVNodes } from '@pocui/hooks'\n\nimport { USE_TOUCH, createEventEmitter, isClient, isElement, isTrue } from '@pocui/utils'\n\nimport { useScrollWrapper } from './hooks'\nimport { nativeScrollProps } from './props'\n\nimport { NativeScrollMode, NativeScrollSlotParams } from './symbol'\n\nimport type { SlotsType } from 'vue'\nimport type { EventHandler } from '@pocui/utils'\n\nconst scrollModes = Object.freeze<NativeScrollMode[]>(['horizontal', 'vertical', 'both'])\n\nconst MOVE_EVENT = 'mousemove'\nconst UP_EVENT = 'mouseup'\n\nexport default defineComponent({\n  name: 'NativeScroll',\n  description:'用于需要展示超出一个区域范围的内容，可以使用户滚动浏览，内部实现采用浏览器原生滚动以获得更好的兼容性与性能。',\n  categories: ['other'],\n  inheritAttrs: false,\n  props: nativeScrollProps,\n  emits: [],\n  slots: Object as SlotsType<{\n    default?(props: NativeScrollSlotParams): any,\n    extra?(props: NativeScrollSlotParams): any,\n    'prefix-trap'(): any,\n    prefixTrap(): any,\n    'suffix-trap'(): any,\n    suffixTrap(): any\n  }>,\n  setup(_props, { attrs, slots, expose }) {\n    const props = useProps('nativeScroll', _props, {\n      scrollClass: null,\n      scrollStyle: null,\n      scrollAttrs: null,\n      mode: {\n        default: 'vertical',\n        validator: value => scrollModes.includes(value)\n      },\n      width: '',\n      height: '',\n      disabled: false,\n      pointer: false,\n      scrollX: {\n        default: 0,\n        static: true\n      },\n      scrollY: {\n        default: 0,\n        static: true\n      },\n      useXBar: false,\n      useYBar: false,\n      barFade: 1500,\n      barClass: null,\n      autoplay: false,\n      playWaiting: 500,\n      appear: false,\n      barDuration: null,\n      useBarTrack: false,\n      scrollTag: 'div',\n      observeDeep: false,\n      scrollOnly: false\n    })\n    const nh = useNameHelper('native-scroll')\n    const emitter = createEventEmitter()\n    const usingBar = ref(false)\n    const scrolling = ref(false)\n\n    const wrapper = ref<HTMLElement>()\n    const xBar = ref<InstanceType<typeof Scrollbar>>()\n    const yBar = ref<InstanceType<typeof Scrollbar>>()\n\n    let initialized = false\n\n    const {\n      contentEl,\n\n      syncing,\n      content,\n      x,\n      y,\n      percentX,\n      percentY,\n      xScrollLimit,\n      yScrollLimit,\n      enableXScroll,\n      enableYScroll,\n      xBarLength,\n      yBarLength,\n\n      handleResize,\n      setScrollX,\n      setScrollY,\n      computePercent,\n      refresh,\n      scrollTo,\n      scrollBy,\n      scrollToElement,\n      triggerUpdate\n    } = useScrollWrapper({\n      mode: toRef(props, 'mode'),\n      disabled: toRef(props, 'disabled'),\n      appear: toRef(props, 'appear'),\n      scrollX: toRef(props, 'scrollX'),\n      scrollY: toRef(props, 'scrollY'),\n      onResize: entry => {\n        emitEvent(props.onResize, entry)\n      },\n      onAfterRefresh: () => {\n        syncBarScroll()\n\n        if (!initialized) {\n          initialized = true\n          startAutoplay()\n        }\n      }\n    })\n\n    const slotParams = shallowReadonly({\n      getState,\n      refresh,\n      scrollTo,\n      scrollBy,\n      scrollToElement,\n      ensureInView\n    })\n\n    // 自动播放\n    const canPlay = ref(false)\n\n    const canAutoplay = computed(() => {\n      return (\n        props.mode !== 'both' &&\n        (isTrue(props.autoplay) || +props.autoplay > 1000) &&\n        ((props.mode === 'horizontal' && enableXScroll.value) || (props.mode === 'vertical' && enableYScroll.value))\n      )\n    })\n\n    watch([() => props.autoplay, () => props.playWaiting, contentEl], () => {\n      stopAutoplay()\n      nextTick(startAutoplay)\n    })\n\n    let playTimer: ReturnType<typeof setTimeout>\n    let startTimer: ReturnType<typeof setTimeout>\n    let endTimer: ReturnType<typeof setTimeout>\n\n    onBeforeUnmount(stopAutoplay)\n\n    function startAutoplay() {\n      stopAutoplay()\n\n      if (!canAutoplay.value || !contentEl.value) return\n\n      const mode = props.mode\n      const distance = mode === 'horizontal' ? 'offsetWidth' : 'offsetHeight'\n      const limit = mode === 'horizontal' ? xScrollLimit : yScrollLimit\n      const prop = mode === 'horizontal' ? x : y\n      const waiting = props.playWaiting < 20 ? 20 : props.playWaiting\n      const setScroll = mode === 'horizontal' ? setScrollX : setScrollY\n\n      let playSpeed = 0.5\n\n      if (typeof props.autoplay === 'number') {\n        playSpeed = (contentEl.value[distance] / props.autoplay) * 16\n      }\n\n      const scroll = () => {\n        setScroll(prop.value + playSpeed)\n\n        if (prop.value >= limit.value) {\n          setScroll(limit.value)\n          canPlay.value = false\n\n          computePercent()\n          triggerUpdate()\n          syncBarScroll()\n\n          endTimer = setTimeout(() => {\n            scrollTo(0, 0, 500)\n\n            startTimer = setTimeout(() => {\n              canPlay.value = true\n              scroll()\n            }, 500 + waiting)\n          }, waiting)\n        } else {\n          computePercent()\n          triggerUpdate()\n          syncBarScroll()\n\n          if (canPlay.value) {\n            requestAnimationFrame(scroll)\n          }\n        }\n      }\n\n      playTimer = setTimeout(() => {\n        canPlay.value = true\n        scroll()\n      }, waiting)\n    }\n\n    function stopAutoplay() {\n      canPlay.value = false\n\n      clearTimeout(playTimer)\n      clearTimeout(startTimer)\n      clearTimeout(endTimer)\n    }\n\n    const className = computed(() => {\n      return [\n        nh.b(),\n        nh.bm(props.mode),\n        {\n          [nh.inc()]: props.inherit,\n          [nh.bm('scrolling')]: scrolling.value,\n          [nh.bm('using-bar')]: usingBar.value\n        }\n      ]\n    })\n    const style = computed(() => {\n      const { width, height } = props\n\n      return {\n        width: width\n          ? typeof width === 'string'\n            ? Number.isNaN(Number(width))\n              ? width\n              : `${Number(width)}px`\n            : `${width}px`\n          : undefined,\n        height: height\n          ? typeof height === 'string'\n            ? Number.isNaN(Number(height))\n              ? height\n              : `${Number(height)}px`\n            : `${height}px`\n          : undefined,\n        scrollbarWidth: 'none'\n      }\n    })\n    const wrapperClass = computed(() => {\n      return [props.scrollAttrs?.class, props.scrollClass, nh.be('wrapper')]\n    })\n    const barFade = computed(() => (canAutoplay.value ? 0 : props.barFade))\n\n    const willMutate = ref(false)\n\n    function handleMutate() {\n      willMutate.value = true\n      nextTick(refresh)\n      requestAnimationFrame(() => {\n        willMutate.value = false\n      })\n    }\n\n    let observer: MutationObserver | undefined\n\n    function createMutation() {\n      if (!isClient || !contentEl.value) return\n\n      observer = new MutationObserver(handleMutate)\n      observer.observe(contentEl.value, {\n        childList: true\n      })\n    }\n\n    function clearMutation() {\n      observer?.disconnect()\n      observer = undefined\n    }\n\n    watch(\n      contentEl,\n      () => {\n        clearMutation()\n        createMutation()\n      },\n      { immediate: true }\n    )\n    watch(enableXScroll, value => {\n      emitEvent(props.onXEnabledChange, value)\n    })\n    watch(enableYScroll, value => {\n      emitEvent(props.onYEnabledChange, value)\n    })\n\n    expose({\n      x,\n      y,\n      percentX,\n      percentY,\n      xScrollLimit,\n      yScrollLimit,\n\n      xBarLength,\n      yBarLength,\n      enableXScroll,\n      enableYScroll,\n\n      wrapper,\n      content: contentEl,\n      xBar,\n      yBar,\n\n      refresh,\n      scrollTo,\n      scrollBy,\n      scrollToElement,\n      ensureInView,\n      getXScrollLimit,\n      getYScrollLimit,\n      addScrollListener,\n      removeScrollListener\n    })\n\n    function getCommonPayload() {\n      return {\n        clientX: x.value,\n        clientY: y.value,\n        percentX: percentX.value,\n        percentY: percentY.value\n      }\n    }\n\n    function syncBarScroll() {\n      xBar.value?.handleScroll(percentX.value)\n      yBar.value?.handleScroll(percentY.value)\n    }\n\n    function handleMouseDown(event: MouseEvent) {\n      if (!props.pointer || event.button !== 0 || USE_TOUCH) {\n        return false\n      }\n\n      handlePointerDown(event)\n    }\n\n    // 记录滚动开始位置\n    let xScrollStartAt = 0\n    let yScrollStartAt = 0\n\n    // 记录滚动开始鼠标位置\n    let cursorXPosition = 0\n    let cursorYPosition = 0\n\n    function handlePointerDown(event: MouseEvent) {\n      if (!enableXScroll.value && !enableYScroll.value) {\n        return false\n      }\n\n      prepareScroll()\n\n      xScrollStartAt = x.value\n      yScrollStartAt = y.value\n      cursorXPosition = event.clientX\n      cursorYPosition = event.clientY\n\n      document.addEventListener(MOVE_EVENT, handlePointerMove)\n      document.addEventListener(UP_EVENT, handlePointerUp)\n\n      emitEvent(props.onScrollStart, getCommonPayload())\n    }\n\n    function handlePointerMove(event: MouseEvent) {\n      event.stopPropagation()\n      event.preventDefault()\n\n      scrolling.value = true\n\n      if (enableXScroll.value) {\n        setScrollX(xScrollStartAt - (event.clientX - cursorXPosition))\n      }\n\n      if (enableYScroll.value) {\n        setScrollY(yScrollStartAt - (event.clientY - cursorYPosition))\n      }\n\n      computePercent()\n      triggerUpdate()\n      syncBarScroll()\n      emitScrollEvent(props.mode)\n    }\n\n    function handlePointerUp() {\n      document.removeEventListener(MOVE_EVENT, handlePointerMove)\n      document.removeEventListener(UP_EVENT, handlePointerUp)\n\n      emitEvent(props.onScrollEnd, getCommonPayload())\n      startAutoplay()\n    }\n\n    function handleWheel(event: WheelEvent, type: 'vertical' | 'horizontal') {\n      const isVerticalScroll = enableYScroll.value && type === 'vertical'\n      const isHorizontalScroll = enableXScroll.value && type === 'horizontal'\n      const sign = event.deltaY > 0 ? 1 : -1\n\n      emitEvent(props.onWheel, event, type)\n\n      if (isVerticalScroll || isHorizontalScroll) {\n        const maxLimit = isVerticalScroll ? yScrollLimit.value : xScrollLimit.value\n        const scroll = isVerticalScroll ? y.value : x.value\n\n        if (sign > 0 ? scroll < maxLimit : scroll > 0) {\n          event.stopPropagation()\n\n          return false\n        }\n      }\n    }\n\n    function handleScroll(event: UIEvent) {\n      if (!contentEl.value || syncing.value) return\n\n      event.stopPropagation()\n\n      const type = contentEl.value?.scrollLeft !== x.value ? 'horizontal' : 'vertical'\n\n      y.value = contentEl.value.scrollTop\n      x.value = contentEl.value.scrollLeft\n\n      computePercent()\n      triggerUpdate()\n      syncBarScroll()\n      emitScrollEvent(type)\n    }\n\n    function prepareScroll() {\n      stopAutoplay()\n    }\n\n    function handleBarScrollStart(type: 'vertical' | 'horizontal') {\n      usingBar.value = true\n      prepareScroll()\n      emitEvent(props.onBarScrollStart, {\n        ...getCommonPayload(),\n        type\n      })\n    }\n\n    function handleBarScrollEnd(type: 'vertical' | 'horizontal') {\n      usingBar.value = false\n      startAutoplay()\n      emitEvent(props.onBarScrollEnd, {\n        ...getCommonPayload(),\n        type\n      })\n    }\n\n    function handleXBarScroll(percent: number) {\n      percentX.value = percent\n      setScrollX((percent * xScrollLimit.value) / 100)\n      triggerUpdate()\n      emitEvent(props.onBarScroll, {\n        ...getCommonPayload(),\n        type: 'horizontal'\n      })\n      emitScrollEvent('horizontal')\n    }\n\n    function handleYBarScroll(percent: number) {\n      percentY.value = percent\n      setScrollY((percent * yScrollLimit.value) / 100)\n      triggerUpdate()\n      emitEvent(props.onBarScroll, {\n        ...getCommonPayload(),\n        type: 'vertical'\n      })\n      emitScrollEvent('vertical')\n    }\n\n    function emitScrollEvent(type: NativeScrollMode) {\n      emitEvent(props.onScroll, {\n        ...getCommonPayload(),\n        type\n      })\n      emitter.emit('scroll', {\n        ...getCommonPayload(),\n        type\n      })\n    }\n\n    function getState() {\n      const { clientX: scrollX, clientY: scrollY, percentX, percentY } = getCommonPayload()\n\n      return {\n        scrollX,\n        scrollY,\n        percentX,\n        percentY,\n        enableXScroll: enableXScroll.value,\n        enableYScroll: enableYScroll.value\n      }\n    }\n\n    function getXScrollLimit() {\n      return [0, xScrollLimit.value]\n    }\n\n    function getYScrollLimit() {\n      return [0, yScrollLimit.value]\n    }\n\n    function ensureInView(el: string | Element, duration?: number, offset = 0) {\n      if (!wrapper.value) return Promise.resolve()\n\n      if (typeof el === 'string') {\n        el = wrapper.value.querySelector(el)!\n      }\n\n      if (!isElement(el)) return Promise.resolve()\n\n      const wrapperRect = wrapper.value.getBoundingClientRect()\n      const elRect = el.getBoundingClientRect()\n\n      let clientX = 0\n      let clientY = 0\n\n      if (props.mode !== 'vertical') {\n        if (elRect.left < wrapperRect.left + offset) {\n          clientX = elRect.left - wrapperRect.left - offset\n        } else if (elRect.right > wrapperRect.right - offset) {\n          clientX = elRect.right - wrapperRect.right + offset\n        }\n      }\n\n      if (props.mode !== 'horizontal') {\n        if (elRect.top < wrapperRect.top + offset) {\n          clientY = elRect.top - wrapperRect.top - offset\n        } else if (elRect.bottom > wrapperRect.bottom - offset) {\n          clientY = elRect.bottom - wrapperRect.bottom + offset\n        }\n      }\n\n      return scrollBy(clientX, clientY, duration)\n    }\n\n    function addScrollListener(listener: EventHandler) {\n      emitter.on('scroll', listener)\n    }\n\n    function removeScrollListener(listener: EventHandler) {\n      emitter.off('scroll', listener)\n    }\n\n    function renderContent() {\n      const Content = (props.scrollTag || 'div') as any\n      const children = props.observeDeep && slots.default ? renderSlot(slots, 'default', slotParams).children : []\n\n      return (\n        <Content\n          {...props.scrollAttrs}\n          {...(props.scrollOnly ? attrs : {})}\n          ref={contentEl}\n          class={wrapperClass.value}\n          style={[props.scrollAttrs?.style, props.scrollStyle, props.scrollOnly && style.value]}\n          onMousedown={handleMouseDown}\n          onWheelPassive={(event: WheelEvent) => handleWheel(event, event.shiftKey ? 'horizontal' : 'vertical')}\n          onScroll={handleScroll}\n        >\n          {slots.extra && (\n            <div\n              class={nh.be('extra')}\n              style={{\n                width: willMutate.value ? undefined : `${content.scrollWidth}px`,\n                height: willMutate.value ? undefined : `${content.scrollHeight}px`\n              }}\n            >\n              <div\n                class={nh.be('extra-inner')}\n                style={{\n                  width: `${content.offsetWidth}px`,\n                  height: `${content.offsetHeight}px`\n                }}\n              >\n                {renderSlot(slots, 'extra', slotParams)}\n              </div>\n            </div>\n          )}\n          {slots.default &&\n            (props.observeDeep\n              ? flatVNodes(children).map((vnode, index) => {\n                return (\n                  <ResizeObserver key={vnode.key ?? index} on-resize={handleResize}>\n                    {() => vnode}\n                  </ResizeObserver>\n                )\n              })\n              : renderSlot(slots, 'default', slotParams))}\n        </Content>\n      )\n    }\n\n    return () => {\n      if (props.scrollOnly) {\n        return <ResizeObserver on-resize={handleResize}>{renderContent()}</ResizeObserver>\n      }\n\n      return (\n        <div {...attrs} ref={wrapper} class={[className.value, attrs.class]} style={[style.value, attrs.style as any]}>\n          {createSlotRender(slots, ['prefix-trap', 'prefixTrap'])?.()}\n          <ResizeObserver on-resize={handleResize}>{renderContent()}</ResizeObserver>\n          {props.useXBar && (\n            <Scrollbar\n              ref={xBar}\n              inherit\n              placement='bottom'\n              class={[nh.bem('bar', 'horizontal'), props.barClass]}\n              fade={barFade.value}\n              bar-length={xBarLength.value}\n              disabled={!enableXScroll.value}\n              appear={props.appear}\n              duration={props.barDuration}\n              use-track={props.useBarTrack}\n              onScrollStart={() => handleBarScrollStart('horizontal')}\n              onScroll={handleXBarScroll}\n              onScrollEnd={() => handleBarScrollEnd('horizontal')}\n            ></Scrollbar>\n          )}\n          {props.useYBar && (\n            <Scrollbar\n              ref={yBar}\n              inherit\n              placement='right'\n              class={[nh.bem('bar', 'vertical'), props.barClass]}\n              fade={barFade.value}\n              bar-length={yBarLength.value}\n              disabled={!enableYScroll.value}\n              appear={props.appear}\n              duration={props.barDuration}\n              use-track={props.useBarTrack}\n              onScrollStart={() => handleBarScrollStart('vertical')}\n              onScroll={handleYBarScroll}\n              onScrollEnd={() => handleBarScrollEnd('vertical')}\n            ></Scrollbar>\n          )}\n          {createSlotRender(slots, ['suffix-trap', 'suffixTrap'])?.()}\n        </div>\n      )\n    }\n  }\n})\n"
    },
    {
      "target": "components/native-scroll/props.ts",
      "content": "import {\n  booleanNumberProp,\n  booleanProp,\n  buildProps,\n  classProp,\n  eventProp,\n  styleProp\n} from '@pocui/config'\n\nimport type { BarScrollPayload } from '@/components/scroll'\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { NativeScrollMode, NativeScrollPayload } from './symbol'\n\nexport const nativeScrollProps = buildProps({\n  scrollClass: classProp,\n  scrollStyle: styleProp,\n  scrollAttrs: Object as PropType<Record<string, any>>,\n  mode: String as PropType<NativeScrollMode>,\n  width: [Number, String],\n  height: [Number, String],\n  disabled: booleanProp,\n  pointer: booleanProp,\n  scrollX: Number,\n  scrollY: Number,\n  useXBar: booleanProp,\n  useYBar: booleanProp,\n  barFade: Number,\n  barClass: classProp,\n  autoplay: booleanNumberProp,\n  playWaiting: Number,\n  appear: booleanProp,\n  barDuration: Number,\n  useBarTrack: booleanProp,\n  scrollTag: String,\n  observeDeep: booleanProp,\n  scrollOnly: booleanProp,\n  onResize: eventProp<(entry: ResizeObserverEntry) => void>(),\n  onXEnabledChange: eventProp<(enabled: boolean) => void>(),\n  onYEnabledChange: eventProp<(enabled: boolean) => void>(),\n  onWheel: eventProp<(event: WheelEvent, type: 'vertical' | 'horizontal') => void>(),\n  onScrollStart: eventProp<(payload: Omit<NativeScrollPayload, 'type'>) => void>(),\n  onScroll: eventProp<(payload: NativeScrollPayload) => void>(),\n  onScrollEnd: eventProp<(payload: Omit<NativeScrollPayload, 'type'>) => void>(),\n  onBarScrollStart: eventProp<(payload: BarScrollPayload) => void>(),\n  onBarScroll: eventProp<(payload: BarScrollPayload) => void>(),\n  onBarScrollEnd: eventProp<(payload: BarScrollPayload) => void>()\n})\n\nexport type NativeScrollProps = ExtractPropTypes<typeof nativeScrollProps>\nexport type NativeScrollCProps = ConfigurableProps<NativeScrollProps, 'scrollX' | 'scrollY', 'onBeforeScroll'>\n"
    },
    {
      "target": "components/native-scroll/symbol.ts",
      "content": "import type { ScrollMode } from '@/components/scroll'\nimport type { EventHandler } from '@pocui/utils'\nimport type { ComponentPublicInstance } from 'vue'\n\nexport type NativeScrollMode = Exclude<ScrollMode, 'horizontal-exact'>\n\nexport interface NativeScrollPayload {\n  type: NativeScrollMode,\n\n  clientX: number,\n\n  clientY: number,\n\n  percentX: number,\n\n  percentY: number\n}\n\nexport interface NativeScrollState {\n  scrollX: number,\n\n  scrollY: number,\n\n  percentX: number,\n\n  percentY: number,\n\n  enableXScroll: Readonly<boolean>,\n\n  enableYScroll: Readonly<boolean>\n}\n\nexport interface NativeScrollSlotParams {\n  getState: () => NativeScrollState,\n\n  refresh: () => void,\n\n  scrollTo: (clientX: number, clientY: number, duration?: number) => Promise<void>,\n\n  scrollBy: (deltaX: number, deltaY: number, duration?: number) => Promise<void>,\n\n  scrollToElement: (el: string | Element, duration?: number, offset?: number) => Promise<void>,\n\n  ensureInView: (el: string | Element, duration?: number, offset?: number) => void\n}\n\nexport interface NativeScrollExposed extends ComponentPublicInstance {\n  x: number,\n\n  y: number,\n\n  percentX: number,\n\n  percentY: number,\n\n  xScrollLimit: number,\n\n  yScrollLimit: number,\n\n  enableXScroll: boolean,\n\n  enableYScroll: boolean,\n\n  xBarLength: number,\n\n  yBarLength: number,\n\n  content?: HTMLElement,\n\n  refresh: () => Promise<void>,\n\n  scrollTo: (clientX: number, clientY: number, duration?: number) => Promise<void>,\n\n  scrollBy: (deltaX: number, deltaY: number, duration?: number) => Promise<void>,\n\n  scrollToElement: (el: string | Element, duration?: number, offset?: number) => Promise<void>,\n\n  ensureInView: (el: string | Element, duration?: number, offset?: number) => Promise<void>,\n\n  getXScrollLimit: () => number[],\n\n  getYScrollLimit: () => number[],\n\n  addScrollListener: (listener: EventHandler) => void,\n\n  removeScrollListener: (listener: EventHandler) => void\n}\n"
    }
  ],
  "dependencies": ["vue", "@pocui/hooks", "@pocui/utils", "@pocui/config"],
  "registryDependencies": ["native-scroll.scss", "resize-observer", "scrollbar", "scroll"],
  "categories": ["other"],
  "meta": { "isReferenceOnly": false }
}
