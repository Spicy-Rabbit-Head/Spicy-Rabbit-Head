{
  "name": "checkbox",
  "type": "registry:components",
  "description": "需要在一组选项中进行多项选择时使用，或是用于需要表示两种状态之间的切换的场合。",
  "files": [
    {
      "target": "components/checkbox/checkbox-group.vue",
      "content": "<script setup lang=\"ts\">\nimport { Checkbox } from '@/components/checkbox'\nimport { useFieldStore } from '@/components/form'\n\nimport { computed, onMounted, provide, reactive, ref, toRef, watch } from 'vue'\n\nimport {\n  createSizeProp,\n  createStateProp,\n  emitEvent,\n  useLocale,\n  useNameHelper,\n  useProps\n} from '@pocui/config'\nimport {\n  adjustAlpha,\n  debounceMinor,\n  isClient,\n  isDefined,\n  isObject,\n  parseColorToRgba\n} from '@pocui/utils'\n\nimport { checkboxGroupProps } from './props'\n\nimport { GROUP_STATE } from './symbol'\n\nimport type { Ref } from 'vue'\n\nimport type { ControlState } from './symbol'\n\ndefineOptions({\n  name: 'CheckboxGroup',\n  description: '用于将多个 Checkbox 组合在一起，形成一组复选框集合。',\n  categories: ['form'],\n  components: { Checkbox }\n})\n\nconst { idFor, state, disabled, loading, size, validateField, getFieldValue, setFieldValue } =\n  useFieldStore<(string | number)[]>(focus)\nconst _props = defineProps(checkboxGroupProps)\n\nconst props = useProps('checkboxGroup', _props, {\n  size: createSizeProp(size),\n  state: createStateProp(state),\n  locale: null,\n  value: {\n    default: () => getFieldValue(),\n    static: true\n  },\n  vertical: false,\n  disabled: () => disabled.value,\n  keepOne: false,\n  border: false,\n  options: {\n    default: () => [],\n    static: true\n  },\n  loading: () => loading.value,\n  control: null,\n  loadingLock: false,\n  color: null,\n  stateColor: false\n})\n\nconst emit = defineEmits<{\n  'update:value': [value: (string | number)[]]\n}>()\n\nconst onlyOne = ref<boolean>(false)\nconst nh = useNameHelper('checkbox-group')\nconst locale = useLocale('checkbox', toRef(props, 'locale'))\nconst valueMap = new Map<string | number, boolean>()\nconst inputSet = new Set<Ref<HTMLElement | null | undefined>>()\nconst controlSet = new Set<ControlState>()\nconst currentValues = ref<(string | number)[]>(props.value || [])\n\nconst readonly = computed(() => props.loading && props.loadingLock)\nconst className = computed(() => {\n  return [\n    nh.b(),\n    nh.ns('checkbox-vars'),\n    {\n      [nh.in()]: props.inherit,\n      [nh.bm('vertical')]: props.vertical,\n      [nh.bm('disabled')]: props.disabled,\n      [nh.bm('readonly')]: readonly.value,\n      [nh.bm('loading')]: props.loading,\n      [nh.bm(props.size)]: props.size !== 'default',\n      [nh.bm('border')]: props.border,\n      [nh.bm(props.state)]: props.state !== 'default'\n    }\n  ]\n})\nconst controlLabel = computed(() => {\n  return typeof props.control === 'string' ? props.control : locale.value.all\n})\nconst colorMap = computed(() => {\n  if (!props.color) return null\n\n  const baseColor = parseColorToRgba(props.color)\n\n  return {\n    base: baseColor.toString(),\n    opacity6: adjustAlpha(baseColor, 0.4).toString()\n  }\n})\n\nconst updateValue = debounceMinor(() => {\n  isOnlyOne()\n  currentValues.value = []\n\n  valueMap.forEach((checked, value) => {\n    if (checked) {\n      currentValues.value.push(value)\n    }\n  })\n\n  handleChange(currentValues.value)\n})\n\nconst updateControl = debounceMinor(() => {\n  const valueLength = currentValues.value.length\n  const checked = valueLength === valueMap.size && valueMap.size > 0\n  const partial = valueLength > 0 && !checked\n  controlSet.forEach(state => {\n    state.checked = checked\n    state.partial = partial\n  })\n})\n\nonMounted(() => {\n  isOnlyOne()\n})\n\nprovide(\n  GROUP_STATE,\n  reactive({\n    onlyOne,\n    currentValues,\n    size: toRef(props, 'size'),\n    state: toRef(props, 'state'),\n    disabled: toRef(props, 'disabled'),\n    loading: toRef(props, 'loading'),\n    loadingLock: toRef(props, 'loadingLock'),\n    colorMap,\n    stateColor: toRef(props, 'stateColor'),\n    increaseItem,\n    decreaseItem,\n    increaseControl,\n    decreaseControl,\n    handleControlChange,\n    setItemChecked,\n    replaceValue\n  })\n)\n\nwatch(\n  () => props.value,\n  value => {\n    const checkedValues = new Set(value)\n    const allValues = Array.from(valueMap.keys())\n\n    currentValues.value = []\n\n    allValues.forEach(value => {\n      const checked = checkedValues.has(value)\n\n      valueMap.set(value, checkedValues.has(value))\n      checked && currentValues.value.push(value)\n    })\n  }\n)\nwatch(currentValues, () => {\n  updateControl()\n})\n\n/**\n * 计算是否唯一\n */\nfunction isOnlyOne() {\n  onlyOne.value = [...valueMap.values()].filter(Boolean).length === 1 && props.keepOne\n}\n\nfunction increaseItem(value: string | number, checked: boolean, input: Ref<HTMLElement | null | undefined>) {\n  valueMap.set(value, checked)\n  inputSet.add(input)\n}\n\nfunction decreaseItem(value: string | number, input: Ref<HTMLElement | null | undefined>) {\n  valueMap.delete(value)\n  inputSet.delete(input)\n}\n\nfunction increaseControl(state: ControlState) {\n  controlSet.add(state)\n  updateControl()\n}\n\nfunction decreaseControl(state: ControlState) {\n  controlSet.delete(state)\n}\n\nfunction setItemChecked(value: string | number, checked: boolean) {\n  if (!isDefined(value) || !valueMap.has(value)) return\n\n  valueMap.set(value, checked)\n  updateValue()\n  updateControl()\n}\n\nfunction handleControlChange() {\n  // 在 group 层进行更新, 未选满则全选, 反之全不选\n  const allValues = Array.from(valueMap.keys())\n  const checked = currentValues.value.length !== allValues.length\n\n  allValues.forEach(value => {\n    valueMap.set(value, checked)\n  })\n\n  updateValue()\n  updateControl()\n}\n\nfunction handleChange(value: (string | number)[]) {\n  emit('update:value', value)\n  setFieldValue(value)\n  emitEvent(props.onChange, value)\n  validateField()\n}\n\nfunction replaceValue(prevValue: string | number, newValue: string | number) {\n  if (isDefined(prevValue) && isDefined(newValue) && prevValue !== newValue && valueMap.has(prevValue)) {\n    valueMap.set(newValue, valueMap.get(prevValue)!)\n    valueMap.delete(prevValue)\n  }\n}\n\nfunction focus(options?: FocusOptions) {\n  const input = Array.from(inputSet)[0]?.value\n\n  if (isClient && input && document.activeElement !== input) {\n    input.focus(options)\n  }\n}\n</script>\n\n<template>\n  <div :id=\"idFor\" :class=\"className\" role=\"group\">\n    <slot>\n      <Checkbox v-if=\"props.control\" inherit control>\n        {{ controlLabel }}\n      </Checkbox>\n      <template v-for=\"(item, _index) in props.options\" :key=\"_index\">\n        <Checkbox\n          v-if=\"isObject(item)\"\n          inherit\n          :value=\"item.value\"\n          :control=\"item.control\"\n          :disabled=\"item.disabled\"\n        >\n          {{ item.label || item.value }}\n        </Checkbox>\n        <Checkbox v-else inherit :value=\"item\">\n          {{ item }}\n        </Checkbox>\n      </template>\n    </slot>\n  </div>\n</template>\n"
    },
    {
      "target": "components/checkbox/checkbox.vue",
      "content": "<script setup lang=\"ts\">\nimport { useFieldStore } from '@/components/form'\n\nimport { computed, inject, onBeforeUnmount, onMounted, reactive, ref, watch } from 'vue'\n\nimport { createSizeProp, createStateProp, emitEvent, useNameHelper, useProps } from '@pocui/config'\nimport { adjustAlpha, isDefined, isFunction, parseColorToRgba } from '@pocui/utils'\n\nimport { checkboxProps } from './props'\nimport { GROUP_STATE } from './symbol'\n\ndefineOptions({\n  name: 'Checkbox',\n  description: '需要在一组选项中进行多项选择时使用，或是用于需要表示两种状态之间的切换的场合。',\n  categories: ['basic']\n})\n\nconst _props = defineProps(checkboxProps)\nconst { idFor, state, disabled, loading, size, validateField, getFieldValue, setFieldValue } = useFieldStore<boolean>(\n  () => input.value?.focus()\n)\nconst props = useProps('checkbox', _props, {\n  size: createSizeProp(size),\n  state: createStateProp(state),\n  checked: {\n    default: () => getFieldValue(),\n    static: true\n  },\n  label: null,\n  value: {\n    default: null,\n    static: true\n  },\n  labelClass: null,\n  disabled: () => disabled.value,\n  border: false,\n  control: false,\n  partial: false,\n  tabIndex: 0,\n  loading: () => loading.value,\n  loadingLock: false,\n  name: {\n    default: '',\n    static: true\n  },\n  color: null,\n  stateColor: false\n})\n\nconst emit = defineEmits<{\n  'update:checked': [value: boolean]\n}>()\nconst slots = defineSlots<{\n  default(): any\n}>()\n\nconst groupState = inject(GROUP_STATE, null)\n\nconst nh = useNameHelper('checkbox')\nconst currentChecked = ref(props.checked ?? false)\nconst currentPartial = ref(props.partial)\n\nconst input = ref<HTMLInputElement>()\n\nconst controlState = reactive({\n  checked: currentChecked,\n  partial: currentPartial\n})\n\nconst computedSize = computed(() => groupState?.size || props.size)\nconst computedState = computed(() => groupState?.state || props.state)\nconst isDisabled = computed(\n  () => groupState?.disabled || props.disabled || (groupState?.onlyOne && currentChecked.value)\n)\nconst isLoading = computed(() => groupState?.loading || props.loading)\nconst isLoadingLock = computed(() => groupState?.loadingLock || props.loadingLock)\nconst stateColor = computed(() => groupState?.stateColor || props.stateColor)\nconst readonly = computed(() => isLoading.value && isLoadingLock.value)\nconst className = computed(() => {\n  return [\n    nh.b(),\n    nh.bs('vars'),\n    {\n      [nh.in()]: props.inherit,\n      [nh.bm('checked')]: currentChecked.value,\n      [nh.bm('disabled')]: isDisabled.value,\n      [nh.bm('readonly')]: readonly.value,\n      [nh.bm('loading')]: isLoading.value,\n      [nh.bm(computedSize.value)]: computedSize.value !== 'default',\n      [nh.bm('border')]: props.border,\n      [nh.bm('partial')]: props.control && currentPartial.value,\n      [nh.bm(computedState.value)]: computedState.value !== 'default'\n    }\n  ]\n})\nconst colorMap = computed(() => {\n  if (!props.color) return groupState?.colorMap\n\n  const baseColor = parseColorToRgba(props.color)\n\n  return {\n    base: baseColor.toString(),\n    opacity6: adjustAlpha(baseColor, 0.4).toString()\n  }\n})\nconst style = computed<Record<string, string>>(() => {\n  if (!colorMap.value) return {}\n\n  const { base, opacity6 } = colorMap.value\n\n  return nh.cvm({\n    'label-color-checked': base,\n    'b-color': stateColor.value ? base : undefined,\n    'b-color-hover': base,\n    'b-color-checked': base,\n    'signal-bg-color-checked': base,\n    's-color-focus': opacity6\n  })\n})\nconst hasLabel = computed(() => {\n  return isDefined(props.label) && props.label !== ''\n})\nconst hasSlot = computed(() => {\n  return !!slots.default\n})\nconst currentValue = computed(() => {\n  return props.value ?? props.label\n})\n\nwatch(\n  () => props.checked,\n  value => {\n    setCurrentChecked(value)\n  }\n)\nwatch(\n  () => props.partial,\n  value => {\n    currentPartial.value = value\n  }\n)\n\nif (groupState) {\n  let increased = false\n\n  watch(currentValue, (value, prevValue) => {\n    if (isFunction(groupState.replaceValue)) {\n      groupState.replaceValue(prevValue, value)\n    }\n  })\n  watch(\n    () => props.control,\n    value => {\n      if (value) {\n        if (increased) {\n          groupState.decreaseItem(currentValue.value, input)\n          increased = false\n        }\n        groupState.increaseControl(controlState)\n      } else {\n        groupState.decreaseControl(controlState)\n      }\n    },\n    { immediate: true }\n  )\n  watch(\n    () => groupState.currentValues,\n    value => {\n      if (!props.control) {\n        setCurrentChecked(value.includes(currentValue.value))\n      }\n    },\n    { immediate: true }\n  )\n\n  onMounted(() => {\n    if (!props.control) {\n      groupState.increaseItem(currentValue.value, currentChecked.value, input)\n      increased = true\n    }\n  })\n\n  onBeforeUnmount(() => {\n    if (!props.control) {\n      groupState.decreaseItem(currentValue.value, input)\n    } else {\n      groupState.decreaseControl(controlState)\n    }\n  })\n}\n\nfunction emitCheckEvent() {\n  const checked = currentChecked.value\n\n  emit('update:checked', checked)\n  setFieldValue(checked)\n  emitEvent(props.onChange, checked)\n}\n\nfunction setCurrentChecked(checked: boolean) {\n  if (props.control && isFunction(groupState?.handleControlChange)) {\n    groupState!.handleControlChange()\n  } else if (currentChecked.value !== checked) {\n    currentChecked.value = checked\n    emitCheckEvent()\n  }\n}\n\nfunction handleChange(checked: boolean) {\n  if (isDisabled.value || readonly.value) {\n    return\n  }\n\n  setCurrentChecked(checked)\n\n  if (!props.control && groupState) {\n    isFunction(groupState.setItemChecked) && groupState.setItemChecked(currentValue.value, checked)\n  }\n\n  if (!groupState) {\n    validateField()\n  }\n}\n\nfunction handleClick(event: MouseEvent) {\n  emitEvent(props.onClick, event)\n}\n</script>\n\n<template>\n  <label\n    :id=\"idFor\"\n    :class=\"className\"\n    :style=\"style\"\n    :aria-disabled=\"isDisabled\"\n    @click=\"handleClick\"\n  >\n    <input\n      ref=\"input\"\n      type=\"checkbox\"\n      :class=\"nh.be('input')\"\n      :checked=\"currentChecked\"\n      :disabled=\"isDisabled || readonly\"\n      :tabindex=\"props.tabIndex\"\n      :name=\"props.name\"\n      @submit.prevent\n      @change=\"handleChange(!currentChecked)\"\n      @click.stop\n    />\n    <span :class=\"[nh.be('signal'), isLoading && nh.bem('signal', 'active')]\"></span>\n    <span v-if=\"hasLabel || hasSlot\" :class=\"[nh.be('label'), props.labelClass]\">\n      <slot>{{ props.label }} </slot>\n    </span>\n  </label>\n</template>\n"
    },
    {
      "target": "components/checkbox/index.ts",
      "content": "import Checkbox from './checkbox.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Checkbox }\nexport { checkboxProps } from './props'\n\nexport type CheckboxExposed = ComponentPublicInstance & InstanceType<typeof Checkbox>\n\nexport type { CheckboxProps, CheckboxCProps } from './props'\n"
    },
    {
      "target": "components/checkbox/props.ts",
      "content": "import {\n  booleanProp,\n  booleanStringProp,\n  buildProps,\n  classProp,\n  eventProp,\n  localeProp,\n  sizeProp,\n  stateProp\n} from '@pocui/config'\n\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\n\nexport const checkboxProps = buildProps({\n  size: sizeProp,\n  state: stateProp,\n  checked: booleanProp,\n  label: String,\n  value: [String, Number],\n  labelClass: classProp,\n  disabled: booleanProp,\n  border: booleanProp,\n  control: booleanProp,\n  partial: booleanProp,\n  tabIndex: [String, Number],\n  loading: booleanProp,\n  loadingLock: booleanProp,\n  name: String,\n  color: String,\n  stateColor: booleanProp,\n  onChange: eventProp<(checked: boolean) => void>(),\n  onClick: eventProp<(event: MouseEvent) => void>()\n})\n\nexport type CheckboxProps = ExtractPropTypes<typeof checkboxProps>\nexport type CheckboxCProps = ConfigurableProps<CheckboxProps>\n\nexport type RawOption =\n  | string\n  | {\n    value: string | number,\n    label?: string,\n    control?: boolean,\n    disabled?: boolean\n  }\n\nexport const checkboxGroupProps = buildProps({\n  size: sizeProp,\n  state: stateProp,\n  locale: localeProp('checkbox'),\n  value: Array as PropType<(string | number)[]>,\n  vertical: booleanProp,\n  disabled: booleanProp,\n  keepOne: booleanProp,\n  border: booleanProp,\n  options: Array as PropType<RawOption[]>,\n  loading: booleanProp,\n  loadingLock: booleanProp,\n  control: booleanStringProp,\n  color: String,\n  stateColor: booleanProp,\n  onChange: eventProp<(value: (string | number)[]) => void>()\n})\n\nexport type CheckboxGroupProps = ExtractPropTypes<typeof checkboxGroupProps>\nexport type CheckboxGroupCProps = ConfigurableProps<CheckboxGroupProps>\n"
    },
    {
      "target": "components/checkbox/symbol.ts",
      "content": "import type { ComponentSize, ComponentState } from '@pocui/config'\nimport type { InjectionKey, Ref } from 'vue'\n\nexport interface ControlState {\n  checked: boolean,\n\n  partial: boolean\n}\n\nexport interface GroupState {\n  onlyOne: boolean,\n\n  currentValues: (string | number)[],\n\n  size: ComponentSize,\n\n  state: ComponentState,\n\n  disabled: boolean,\n\n  loading: boolean,\n\n  loadingLock: boolean,\n\n  colorMap: Record<string, string> | null,\n\n  stateColor: boolean,\n\n  increaseItem(value: string | number, checked: boolean, input: Ref<HTMLElement | null | undefined>): void,\n\n  decreaseItem(value: string | number, input: Ref<HTMLElement | null | undefined>): void,\n\n  increaseControl(state: ControlState): void,\n\n  decreaseControl(state: ControlState): void,\n\n  handleControlChange(): void,\n\n  setItemChecked(value: string | number, checked: boolean): void,\n\n  replaceValue(prevValue: string | number, newValue: string | number): void\n}\n\nexport const GROUP_STATE: InjectionKey<GroupState> = Symbol('CHECKBOX_GROUP_STATE')\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/utils"],
  "registryDependencies": ["form", "checkbox.scss"],
  "categories": ["basic"],
  "meta": { "isReferenceOnly": false }
}
