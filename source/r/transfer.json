{
  "name": "transfer",
  "type": "registry:component",
  "description": "穿梭框组件，用于在两个列表之间转移选择项。",
  "files": [
    {
      "target": "components/transfer/index.ts",
      "content": "export { default as Transfer } from './transfer'\nexport { transferProps } from './props'\n\nexport type { TransferProps, TransferCProps } from './props'\nexport type { TransferKeyConfig, TransferFilter, TransferExposed } from './symbol'\n"
    },
    {
      "target": "components/transfer/props.ts",
      "content": "import { booleanProp, buildProps, eventProp, iconProp, localeProp, stateProp } from '@pocui/config'\n\nimport type { IconEffect } from '@/components/icon'\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { TransferFilter, TransferKeyConfig } from './symbol'\n\nexport type RawOption = string | Record<string, any>\nexport type Values = (string | number)[]\n\nexport type SelectHandler = (\n  type: 'source' | 'target',\n  selected: { source: Values, target: Values },\n  data: { source: RawOption[], target: RawOption[] }\n) => void\n\nexport const transferProps = buildProps({\n  state: stateProp,\n  locale: localeProp('transfer'),\n  options: Array as PropType<RawOption[]>,\n  value: Array as PropType<Values>,\n  disabled: booleanProp,\n  paged: booleanProp,\n  filter: {\n    type: [Boolean, Function] as PropType<boolean | TransferFilter>,\n    default: null\n  },\n  emptyText: String,\n  keyConfig: Object as PropType<TransferKeyConfig>,\n  optionHeight: Number,\n  ignoreCase: booleanProp,\n  sourceTitle: String,\n  targetTitle: String,\n  deepState: booleanProp,\n  loading: booleanProp,\n  loadingIcon: iconProp,\n  loadingLock: booleanProp,\n  loadingEffect: String as PropType<IconEffect>,\n  onChange: eventProp<(values: Values) => void>(),\n  onSelect: eventProp<SelectHandler>()\n})\n\nexport type TransferProps = ExtractPropTypes<typeof transferProps>\nexport type TransferCProps = ConfigurableProps<TransferProps>\n"
    },
    {
      "target": "components/transfer/symbol.ts",
      "content": "import type { ComponentPublicInstance } from 'vue'\n\nexport interface TransferKeyConfig {\n  value?: string,\n\n  label?: string,\n\n  disabled?: string\n}\n\nexport interface TransferOptionState {\n  value: string | number,\n\n  label: string,\n\n  disabled: boolean,\n\n  hidden: boolean,\n\n  hitting: boolean,\n\n  data: string | Record<string, any>\n}\n\nexport type TransferFilter = (value: string, options: TransferOptionState, type: 'source' | 'target') => boolean\n\nexport interface SlotPayload {\n  type: 'source' | 'target',\n\n  currentPage: number,\n\n  pageSize: number,\n\n  totalPages: number,\n\n  allSelected: boolean,\n\n  partial: boolean,\n\n  selected: (string | number)[],\n\n  options: TransferOptionState[],\n\n  toggleSelectAll: (event?: Event) => void,\n\n  handleReverse: () => void\n}\n\nexport interface TransferExposed extends ComponentPublicInstance {\n  handleToTarget: () => void,\n\n  handleToSource: () => void,\n\n  handlePanelFocus: (type: 'source' | 'target') => void,\n\n  handlePanelBlur: () => void,\n\n  focus: (options?: FocusOptions) => void,\n\n  blur: () => void\n}\n"
    },
    {
      "target": "components/transfer/transfer-panel.tsx",
      "content": "import { Checkbox } from '@/components/checkbox'\nimport { CollapseTransition } from '@/components/collapse-transition'\nimport { Icon } from '@/components/icon'\nimport { Input } from '@/components/input'\nimport { NumberInput } from '@/components/number-input'\nimport { ResizeObserver } from '@/components/resize-observer'\n\nimport { VirtualList } from '@/components/virtual-list'\n\nimport { SlotsType, computed, defineComponent, reactive, ref, renderSlot, toRef, watch, watchEffect } from 'vue'\n\nimport { stateProp, useIcons, useNameHelper } from '@pocui/config'\n\nimport { useModifier } from '@pocui/hooks'\n\nimport { boundRange, decide } from '@pocui/utils'\n\nimport { SlotPayload, TransferOptionState } from './symbol'\n\nimport type { VirtualListExposed } from '@/components/virtual-list'\n\nimport type { LocaleConfig } from '@pocui/config'\n\nimport type { PropType } from 'vue'\n\nexport default defineComponent({\n  name: 'TransferPanel',\n  description:'穿梭框面板组件，作为穿梭框的单个面板部分。',\n  categories: ['other'],\n  props: {\n    type: {\n      type: String as PropType<'source' | 'target'>,\n      default: null\n    },\n    state: {\n      type: stateProp,\n      default: 'default'\n    },\n    selected: {\n      type: Set as PropType<Set<string | number>>,\n      default: () => new Set()\n    },\n    paged: {\n      type: Boolean,\n      default: false\n    },\n    filter: {\n      type: Function as PropType<(value: string, options: TransferOptionState) => boolean>,\n      default: null\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    title: {\n      type: String,\n      default: ''\n    },\n    options: {\n      type: Array as PropType<TransferOptionState[]>,\n      default: () => []\n    },\n    emptyText: {\n      type: String,\n      default: '暂无数据'\n    },\n    optionHeight: {\n      type: Number,\n      default: 32\n    },\n    deepState: {\n      type: Boolean,\n      default: false\n    },\n    loading: {\n      type: Boolean,\n      default: false\n    },\n    loadingIcon: {\n      type: Object,\n      default: null\n    },\n    loadingLock: {\n      type: Boolean,\n      default: false\n    },\n    loadingEffect: {\n      type: String,\n      default: null\n    },\n    locale: {\n      type: Object as PropType<LocaleConfig['transfer']>,\n      default: () => ({})\n    }\n  },\n  emits: ['update:selected', 'select', 'enter', 'switch'],\n  slots: Object as SlotsType<{\n    option?(props: { type: 'source' | 'target', option: TransferOptionState, index: number }): any,\n    label?(props: { option: TransferOptionState, index: number }): any,\n    header?(props: SlotPayload): any,\n    title?(props: SlotPayload): any,\n    body?(props: SlotPayload): any,\n    footer?(props: SlotPayload): any\n  }>,\n  setup(props, { slots, emit }) {\n    const nh = useNameHelper('transfer')\n    const icons = useIcons()\n\n    const currentSelected = ref(new Set(props.selected))\n    const pageSize = ref(10)\n    const currentPage = ref(1)\n    const currentMark = ref<string | number | null>(null)\n    const currentHitting = ref(-1)\n    const currentFilter = ref('')\n    const searching = ref(false)\n\n    const header = ref<HTMLElement>()\n    const body = ref<HTMLElement>()\n    const footer = ref<HTMLElement>()\n    const search = ref<HTMLElement>()\n    const input = ref<InstanceType<typeof Input>>()\n    const list = ref<VirtualListExposed>()\n\n    let bodyRealHeight = 0\n    let lastSelected: string | number | null = null\n    let keyUsed = false\n\n    const { target: wrapper, modifier } = useModifier({\n      passive: false,\n      onKeyDown: (event, modifier) => {\n        decide(\n          [\n            [\n              () => modifier.up || modifier.down,\n              () => {\n                if (!keyUsed && currentHitting.value < 0) {\n                  keyUsed = true\n\n                  if (lastSelected) {\n                    currentHitting.value = props.options.findIndex(option => option.value === lastSelected)\n                  } else if (list.value) {\n                    currentHitting.value = Math.round(list.value.scrollOffset / props.optionHeight)\n                  }\n\n                  currentHitting.value = currentHitting.value === -1 ? 0 : currentHitting.value\n                } else {\n                  currentHitting.value = boundRange(\n                    findEnabledIndex(currentHitting.value + (modifier.up ? -1 : 1), modifier.up ? -1 : 1),\n                    0,\n                    currentOptions.value.length - 1\n                  )\n                }\n\n                if (!props.paged) {\n                  ensureOptionInView(currentHitting.value, modifier.up ? 'top' : 'bottom')\n                }\n              }\n            ],\n            [\n              () => props.paged && (modifier.left || modifier.right) && event.ctrlKey,\n              () => {\n                handlePageChange(currentPage.value + (modifier.left ? -1 : 1))\n                currentHitting.value = 0\n              }\n            ],\n            [\n              () => (props.type === 'source' && modifier.right) || (props.type === 'target' && modifier.left),\n              () => {\n                keyUsed = false\n                currentHitting.value = -1\n                lastSelected = null\n                emit('switch')\n              }\n            ],\n            [\n              () => modifier.space,\n              () => {\n                const option = currentOptions.value[currentHitting.value]\n\n                if (option) {\n                  currentSelected.value[currentSelected.value.has(option.value) ? 'delete' : 'add'](option.value)\n                  emitSelectedChange()\n                }\n              }\n            ],\n            [() => modifier.enter, () => emit('enter')],\n            [\n              () => typeof props.filter === 'function' && !!input.value && modifier['ctrl+f'],\n              () => {\n                event.stopPropagation()\n                input.value!.focus()\n              }\n            ]\n          ],\n          {\n            beforeMatchAny: () => event.preventDefault(),\n            afterMatchAny: modifier.resetAll\n          }\n        )\n      }\n    })\n\n    const className = computed(() => {\n      return {\n        [nh.be('panel')]: true,\n        [nh.bem('panel', props.state)]: props.state !== 'default',\n        [nh.bem('panel', 'disabled')]: props.disabled\n      }\n    })\n    const visibleOptions = computed(() => {\n      const filter = props.filter\n      const filterValue = currentFilter.value\n\n      if (filter && filterValue) {\n        return props.options.filter(option => filter(filterValue, option))\n      }\n\n      return props.options\n    })\n    const optionSize = computed(() => visibleOptions.value.length)\n    const pagedOptions = computed(() => {\n      return visibleOptions.value.slice((currentPage.value - 1) * pageSize.value, currentPage.value * pageSize.value)\n    })\n    const currentOptions = computed(() => (props.paged ? pagedOptions.value : visibleOptions.value))\n    const totalPages = computed(() => Math.ceil(optionSize.value / (pageSize.value || 1)))\n\n    watch(\n      () => props.selected,\n      value => {\n        currentSelected.value = value\n      }\n    )\n    watch(optionSize, () => {\n      keyUsed = false\n      currentHitting.value = -1\n      lastSelected = null\n    })\n\n    const partial = ref(false)\n    const allSelected = ref(false)\n\n    watchEffect(() => {\n      const options = visibleOptions.value\n      const selected = currentSelected.value\n\n      let hasSelected = false\n      let hasUnselected = false\n\n      for (let i = 0, len = optionSize.value; i < len; ++i) {\n        const option = options[i]\n\n        if (!option.disabled) {\n          if (selected.has(option.value)) {\n            hasSelected = true\n          } else {\n            hasUnselected = true\n          }\n        }\n\n        if (hasSelected && hasUnselected) {\n          break\n        }\n      }\n\n      allSelected.value = hasSelected && !hasUnselected\n      partial.value = !allSelected.value && selected.size > 0\n    })\n\n    function computePageSize() {\n      requestAnimationFrame(() => {\n        const bodyEl = body.value || list.value?.wrapper\n\n        if (bodyEl) {\n          const style = getComputedStyle(bodyEl)\n          const paddingTop = parseInt(style.paddingTop)\n          const paddingBottom = parseInt(style.paddingBottom)\n          const innerHeight = bodyEl.offsetHeight - paddingTop - paddingBottom\n\n          bodyRealHeight = innerHeight\n          pageSize.value = Math.floor(innerHeight / (props.optionHeight || 1))\n        }\n      })\n    }\n\n    function toggleSelect(option: TransferOptionState) {\n      if (props.disabled || option.disabled) return\n\n      if (currentMark.value && modifier.shift) {\n        handleRangeSelect(currentMark.value, option.value)\n        return\n      }\n\n      if (currentSelected.value.has(option.value)) {\n        currentSelected.value.delete(option.value)\n      } else {\n        currentSelected.value.add(option.value)\n      }\n\n      keyUsed = false\n      currentHitting.value = -1\n      lastSelected = option.value\n      currentMark.value = option.value\n      emitSelectedChange()\n    }\n\n    function handleRangeSelect(start: string | number, end: string | number) {\n      const options = visibleOptions.value\n\n      let startIndex = -1\n      let endIndex = -1\n\n      for (let i = 0, len = options.length; i < len; ++i) {\n        const option = options[i]\n\n        if (option.value === start) {\n          startIndex = i\n        } else if (option.value === end) {\n          endIndex = i\n        }\n\n        if (startIndex > 0 && endIndex > 0) break\n      }\n\n      const method = currentSelected.value.has(options[startIndex]?.value) ? 'add' : 'delete'\n\n      if (startIndex > endIndex) {\n        ;[startIndex, endIndex] = [endIndex, startIndex]\n      }\n\n      for (let i = startIndex; i <= endIndex; ++i) {\n        const option = options[i]\n\n        if (!option.disabled) {\n          currentSelected.value[method](option.value)\n        }\n      }\n\n      emitSelectedChange()\n    }\n\n    function toggleSelectAll(event?: Event) {\n      event?.preventDefault()\n\n      if (props.disabled) return\n\n      if (allSelected.value) {\n        for (const option of visibleOptions.value) {\n          !option.disabled && currentSelected.value.delete(option.value)\n        }\n      } else {\n        for (const option of visibleOptions.value) {\n          !option.disabled && currentSelected.value.add(option.value)\n        }\n      }\n\n      currentMark.value = null\n      emitSelectedChange()\n    }\n\n    function handleReverse() {\n      if (props.disabled) return\n\n      if (partial.value) {\n        const prevSelected = new Set(currentSelected.value)\n\n        for (const option of visibleOptions.value) {\n          if (!option.disabled) {\n            if (prevSelected.has(option.value)) {\n              currentSelected.value.delete(option.value)\n            } else {\n              currentSelected.value.add(option.value)\n            }\n          }\n        }\n\n        currentMark.value = null\n        emitSelectedChange()\n      } else {\n        toggleSelectAll()\n      }\n    }\n\n    function handleBlur() {\n      currentMark.value = null\n      modifier.resetAll()\n    }\n\n    function emitSelectedChange() {\n      emit('update:selected', currentSelected.value)\n      emit('select')\n    }\n\n    function handlePageChange(page: number) {\n      currentPage.value = boundRange(page, 1, totalPages.value)\n    }\n\n    function queryEnabledIndex(index: number, step: number) {\n      const options = currentOptions.value\n      step = step / Math.abs(step)\n\n      while (options[index]?.disabled) {\n        index += step\n\n        if (index < 0 || index >= options.length) break\n      }\n\n      return index\n    }\n\n    function findEnabledIndex(index: number, sign: 1 | -1 = 1) {\n      const options = currentOptions.value\n\n      if (options[index]?.disabled) {\n        index = queryEnabledIndex(index, sign)\n\n        if (sign > 0 ? index >= options.length : index < 0) {\n          index = queryEnabledIndex(index, -sign)\n\n          // 全禁用\n          if (sign > 0 ? index < 0 : index >= options.length) index = -1\n        }\n      }\n\n      return index\n    }\n\n    function ensureOptionInView(index: number, direction: 'top' | 'bottom') {\n      const option = props.options[index]\n\n      if (props.paged || !option || !list.value) return\n\n      if (direction === 'bottom') {\n        const target = (index + 1) * props.optionHeight\n\n        if (list.value.scrollOffset + bodyRealHeight < target) {\n          list.value.scrollTo((index - pageSize.value + 1) * props.optionHeight)\n        }\n      } else {\n        const target = index * props.optionHeight\n\n        if (list.value.scrollOffset > target) {\n          list.value.scrollTo(target)\n        }\n      }\n    }\n\n    const slotParams = reactive({\n      type: toRef(props, 'type'),\n      currentPage,\n      pageSize,\n      totalPages,\n      allSelected,\n      partial,\n      selected: computed(() => Array.from(currentSelected.value)),\n      options: computed(() => visibleOptions.value),\n      toggleSelectAll,\n      handleReverse\n    })\n\n    function renderOption({ option, index }: { option: TransferOptionState, index: number }) {\n      const disabled = props.disabled || option.disabled\n      const handleCheck = (event: MouseEvent) => {\n        event.preventDefault()\n        event.stopPropagation()\n        toggleSelect(option)\n      }\n\n      return (\n        <li\n          class={{\n            [nh.be('option')]: true,\n            [nh.bem('option', 'disabled')]: disabled,\n            [nh.bem('option', 'hitting')]: currentHitting.value === index\n          }}\n          role='option'\n          aria-disabled={disabled ? 'true' : undefined}\n          onClick={() => toggleSelect(option)}\n        >\n          {slots.option\n            ? renderSlot(slots, 'option', {\n              type: props.type,\n              option,\n              index\n            })\n            : [\n              <Checkbox\n                key={1}\n                class={nh.be('checkbox')}\n                state={props.deepState ? props.state : undefined}\n                checked={currentSelected.value.has(option.value)}\n                disabled={disabled}\n                tab-index={-1}\n                onClick={handleCheck}\n              ></Checkbox>,\n              <span key={2} class={nh.be('label')}>\n                {slots.label\n                  ? renderSlot(slots, 'label', {\n                    option,\n                    index\n                  })\n                  : option.label}\n              </span>\n              ]}\n        </li>\n      )\n    }\n\n    function renderHeader() {\n      return (\n        <div ref={header} class={nh.be('header')}>\n          {slots.header\n            ? (\n                renderSlot(slots, 'header', slotParams)\n              )\n            : (\n              <>\n                <Checkbox\n                  inherit\n                  control\n                  class={nh.be('checkbox')}\n                  state={props.deepState ? props.state : undefined}\n                  checked={allSelected.value}\n                  partial={partial.value}\n                  disabled={props.disabled}\n                  tab-index={-1}\n                  onClick={toggleSelectAll}\n                ></Checkbox>\n                <div\n                  class={[nh.be('reverse'), props.disabled && nh.bem('reverse', 'disabled')]}\n                  title={props.locale.reverse}\n                  onClick={handleReverse}\n                >\n                  <Icon {...icons.value.retweet} scale={+(icons.value.retweet.scale || 1) * 1.2}></Icon>\n                </div>\n                <div class={nh.be('counter')}>{`${currentSelected.value.size}/${visibleOptions.value.length}`}</div>\n                {(props.title || slots.title) && (\n                  <span class={nh.be('title')}>{slots.title ? renderSlot(slots, 'title', slotParams) : props.title}</span>\n                )}\n                <CollapseTransition appear horizontal fade-effect>\n                  {props.loading && (\n                    <div class={nh.be('loading')}>\n                      <Icon\n                        {...icons.value.loading}\n                        effect={props.loadingEffect || icons.value.loading.effect}\n                        icon={props.loadingIcon || icons.value.loading.icon}\n                        label='loading'\n                      ></Icon>\n                    </div>\n                  )}\n                </CollapseTransition>\n              </>\n              )}\n        </div>\n      )\n    }\n\n    function renderFilter() {\n      if (typeof props.filter !== 'function') return null\n\n      const stop = (e: Event) => e.stopPropagation()\n\n      return (\n        <div ref={search} class={nh.be('filter')}>\n          <Input\n            ref={input}\n            v-model:value={currentFilter.value}\n            inherit\n            clearable\n            sync\n            disabled={props.disabled}\n            placeholder={searching.value ? undefined : props.locale.search}\n            onKeydown={stop}\n            onFocus={() => (searching.value = true)}\n            onBlur={() => (searching.value = false)}\n          >\n            {{\n              suffix: () => <Icon {...icons.value.search}></Icon>\n            }}\n          </Input>\n        </div>\n      )\n    }\n\n    function renderBody() {\n      if (props.paged || slots.body) {\n        return (\n          <ResizeObserver throttle onResize={computePageSize}>\n            <ul ref={body} class={nh.be('body')} role='listbox'>\n              {slots.body\n                ? (\n                    renderSlot(slots, 'body', slotParams)\n                  )\n                : pagedOptions.value.length\n                  ? (\n                      pagedOptions.value.map((option, index) =>\n                        renderOption({\n                          option,\n                          index\n                        })\n                      )\n                    )\n                  : (\n                    <div class={nh.be('empty')}>{props.emptyText || props.locale.empty}</div>\n                    )}\n            </ul>\n          </ResizeObserver>\n        )\n      }\n\n      return (\n        <VirtualList\n          ref={list}\n          inherit\n          class={nh.be('body')}\n          items={visibleOptions.value}\n          item-size={props.optionHeight}\n          item-fixed\n          use-y-bar\n          id-key='value'\n          items-attrs={{\n            role: 'listbox',\n            ariaLabel: props.type\n          }}\n          onResize={computePageSize}\n        >\n          {{\n            default: ({ item, index }: { item: TransferOptionState, index: number }) =>\n              renderOption({\n                option: item,\n                index\n              }),\n            empty: () => <div class={nh.be('empty')}>{props.emptyText || props.locale.empty}</div>\n          }}\n        </VirtualList>\n      )\n    }\n\n    function renderFooter() {\n      if (!props.paged && !slots.footer) return null\n\n      return (\n        <div ref={footer} class={nh.be('footer')}>\n          {slots.footer\n            ? (\n                renderSlot(slots, 'footer', slotParams)\n              )\n            : (\n              <div class={nh.be('pagination')}>\n                <Icon\n                  {...icons.value.angleLeft}\n                  class={[nh.be('page-plus'), currentPage.value <= 1 && nh.bem('page-plus', 'disabled')]}\n                  onClick={() => handlePageChange(currentPage.value - 1)}\n                ></Icon>\n                <NumberInput\n                  inherit\n                  value={currentPage.value}\n                  class={nh.be('page-input')}\n                  size='small'\n                  min={1}\n                  max={totalPages.value}\n                  onChange={handlePageChange}\n                ></NumberInput>\n                <span style='margin: 0 4px'>{'/'}</span>\n                <span>{totalPages.value}</span>\n                <Icon\n                  {...icons.value.angleRight}\n                  class={[nh.be('page-minus'), currentPage.value >= totalPages.value && nh.bem('page-minus', 'disabled')]}\n                  onClick={() => handlePageChange(currentPage.value + 1)}\n                ></Icon>\n              </div>\n              )}\n        </div>\n      )\n    }\n\n    return () => (\n      <div ref={wrapper} class={className.value} tabindex={0} onBlur={handleBlur}>\n        {renderHeader()}\n        {renderFilter()}\n        {renderBody()}\n        {renderFooter()}\n      </div>\n    )\n  }\n})\n"
    },
    {
      "target": "components/transfer/transfer.tsx",
      "content": "import { Button } from '@/components/button'\nimport { useFieldStore } from '@/components/form'\nimport { Icon } from '@/components/icon'\n\nimport { SlotsType, computed, defineComponent, reactive, ref, renderSlot, toRef, watch, watchEffect } from 'vue'\n\nimport {\n  createIconProp,\n  createStateProp,\n  emitEvent,\n  useIcons,\n  useLocale,\n  useNameHelper,\n  useProps\n} from '@pocui/config'\nimport { isNullish } from '@pocui/utils'\n\nimport { transferProps } from './props'\n\nimport { SlotPayload, TransferKeyConfig, TransferOptionState } from './symbol'\n\nimport TransferPanel from './transfer-panel'\n\nconst defaultKeyConfig: Required<TransferKeyConfig> = {\n  value: 'value',\n  label: 'label',\n  disabled: 'disabled'\n}\n\nexport default defineComponent({\n  name: 'Transfer',\n  description:'穿梭框组件，用于在两个列表之间转移选择项。',\n  categories: ['other'],\n  components: {\n    Button,\n    TransferPanel\n  },\n  props: transferProps,\n  slots: Object as SlotsType<{\n    body?(props: SlotPayload): any,\n    footer?(props: SlotPayload): any,\n    header?(props: SlotPayload): any,\n    option?(props: { type: 'source' | 'target', option: TransferOptionState, index: number }): any,\n    'source-body'?(props: SlotPayload): any,\n    sourceBody?(props: SlotPayload): any,\n    'source-footer'?(props: SlotPayload): any,\n    sourceFooter?(props: SlotPayload): any,\n    'source-header'?(props: SlotPayload): any,\n    sourceHeader?(props: SlotPayload): any,\n    'source-option'?(props: { type: 'source' | 'target', option: TransferOptionState, index: number }): any,\n    sourceOption?(props: { type: 'source' | 'target', option: TransferOptionState, index: number }): any,\n    'source-title'?(props: SlotPayload): any,\n    sourceTitle?(props: SlotPayload): any,\n    'target-body'?(props: SlotPayload): any,\n    targetBody?(props: SlotPayload): any,\n    'target-footer'?(props: SlotPayload): any,\n    targetFooter?(props: SlotPayload): any,\n    'target-header'?(props: SlotPayload): any,\n    targetHeader?(props: SlotPayload): any,\n    'target-option'?(props: { type: 'source' | 'target', option: TransferOptionState, index: number }): any,\n    targetOption?(props: { type: 'source' | 'target', option: TransferOptionState, index: number }): any,\n    'target-title'?(props: SlotPayload): any,\n    targetTitle?(props: SlotPayload): any,\n    title?(props: SlotPayload): any,\n    actions?(props: { handleToTarget: () => void, handleToSource: () => void }): any\n  }>,\n  emits: ['update:value'],\n  setup(_props, { slots, emit, expose }) {\n    const { idFor, state, disabled, loading, validateField, getFieldValue, setFieldValue } = useFieldStore<\n    (string | number)[]\n      >(() => source.value?.$el?.focus())\n\n    const props = useProps('transfer', _props, {\n      state: createStateProp(state),\n      locale: null,\n      options: {\n        default: () => [],\n        static: true\n      },\n      value: {\n        default: () => getFieldValue([]),\n        static: true\n      },\n      disabled: () => disabled.value,\n      paged: false,\n      filter: false,\n      emptyText: null,\n      keyConfig: () => ({}),\n      optionHeight: {\n        default: 32,\n        validator: value => value > 0\n      },\n      ignoreCase: false,\n      sourceTitle: null,\n      targetTitle: null,\n      deepState: false,\n      loading: () => loading.value,\n      loadingIcon: createIconProp(),\n      loadingLock: false,\n      loadingEffect: null\n    })\n\n    const nh = useNameHelper('transfer')\n    const locale = useLocale('transfer', toRef(props, 'locale'))\n    const icons = useIcons()\n\n    const currentValue = ref<Set<string | number>>(null!)\n    const sourceSelected = ref(new Set<string | number>())\n    const targetSelected = ref(new Set<string | number>())\n    const sourceOptions = ref<TransferOptionState[]>([])\n    const targetOptions = ref<TransferOptionState[]>([])\n    const optionStates = ref<TransferOptionState[]>([])\n\n    const source = ref<InstanceType<typeof TransferPanel>>()\n    const target = ref<InstanceType<typeof TransferPanel>>()\n\n    const keyConfig = computed(() => ({ ...defaultKeyConfig, ...props.keyConfig }))\n\n    let optionValueMap = new Map<string | number, TransferOptionState>()\n    let emittedValue = props.value\n\n    const updateTrigger = ref(0)\n\n    watchEffect(() => {\n      /* eslint-disable @typescript-eslint/no-unused-expressions */\n      props.keyConfig.value\n      props.keyConfig.label\n      props.keyConfig.disabled\n\n      for (let i = 0, len = props.options.length; i < len; ++i) {\n        props.options[i]\n      }\n      /* eslint-enable */\n\n      updateTrigger.value++\n    })\n\n    watch(updateTrigger, initOptions, { immediate: true })\n\n    watchEffect(() => {\n      if (!currentValue.value.size) {\n        sourceOptions.value = Array.from(optionStates.value)\n        targetOptions.value = []\n        return\n      }\n\n      const selectedValues = new Set(currentValue.value)\n      const target: TransferOptionState[] = []\n      const source: TransferOptionState[] = []\n\n      for (const option of optionStates.value) {\n        if (selectedValues.has(option.value)) {\n          target.push(option)\n        } else {\n          source.push(option)\n        }\n      }\n\n      targetOptions.value = target\n      sourceOptions.value = source\n    })\n\n    function initOptions() {\n      const { value: valueKey, label: labelKey, disabled: disabledKey } = keyConfig.value\n      const oldMap = optionValueMap\n      const map = new Map<string | number, TransferOptionState>()\n\n      props.options.forEach(option => {\n        const rawOption = typeof option === 'string' ? { [valueKey]: option } : option\n        const value = rawOption[valueKey]\n\n        if (isNullish(value)) return\n\n        const label = rawOption[labelKey] || String(value)\n        const { [disabledKey]: disabled = false } = rawOption\n        const oldState = oldMap.get(rawOption.value)\n        const optionState = reactive({\n          disabled,\n          value,\n          label,\n          hidden: oldState?.hidden ?? false,\n          hitting: oldState?.hitting ?? false,\n          data: option\n        })\n\n        map.set(value, optionState)\n      })\n\n      optionValueMap = map\n      optionStates.value = Array.from(map.values())\n      currentValue.value = new Set(emittedValue)\n    }\n\n    const readonly = computed(() => props.loading && props.loadingLock)\n    const className = computed(() => {\n      return [\n        nh.b(),\n        nh.bs('vars'),\n        {\n          [nh.in()]: props.inherit,\n          [nh.bm(props.state)]: props.state !== 'default',\n          [nh.bm('readonly')]: readonly.value,\n          [nh.bm('loading')]: props.loading\n        }\n      ]\n    })\n    const actionType = computed(() => {\n      return props.deepState && props.state !== 'default' ? props.state : 'primary'\n    })\n    const toTargetEnabled = computed(() => !!sourceSelected.value.size)\n    const toSourceEnabled = computed(() => !!targetSelected.value.size)\n    const defaultFilter = computed(() => {\n      return props.ignoreCase\n        ? (value: string, option: TransferOptionState) => option.label.toLocaleLowerCase().includes(value)\n        : (value: string, option: TransferOptionState) => option.label.includes(value)\n    })\n    const sourceFilter = computed(() => getFilterMethod('source'))\n    const targetFilter = computed(() => getFilterMethod('target'))\n\n    watch(\n      () => props.value,\n      value => {\n        emittedValue = value\n        currentValue.value = new Set(emittedValue)\n      }\n    )\n\n    expose({\n      handleToTarget,\n      handleToSource,\n      handlePanelFocus,\n      handlePanelBlur,\n      focus: (options?: FocusOptions) => source.value?.$el?.focus(options),\n      blur: () => {\n        source.value?.$el?.blur()\n        target.value?.$el?.blur()\n      }\n    })\n\n    function getFilterMethod(type: 'source' | 'target') {\n      const filter = props.filter\n\n      if (!filter) return undefined\n\n      if (typeof filter === 'function') {\n        return (value: string, option: TransferOptionState) => filter(value, option, type)\n      }\n\n      return defaultFilter.value\n    }\n\n    function handleChange() {\n      emittedValue = Array.from(currentValue.value)\n\n      emit('update:value', emittedValue)\n      setFieldValue(emittedValue)\n      emitEvent(props.onChange, emittedValue)\n      validateField()\n    }\n\n    function handleToTarget() {\n      for (const value of sourceSelected.value) {\n        currentValue.value.add(value)\n      }\n\n      sourceSelected.value.clear()\n      handleChange()\n    }\n\n    function handleToSource() {\n      for (const value of targetSelected.value) {\n        currentValue.value.delete(value)\n      }\n\n      targetSelected.value.clear()\n      handleChange()\n    }\n\n    function handleSelect(type: 'source' | 'target') {\n      const selected = {\n        source: Array.from(sourceSelected.value),\n        target: Array.from(targetSelected.value)\n      }\n      const data = {\n        source: selected.source.map(value => optionValueMap.get(value)?.data ?? ''),\n        target: selected.target.map(value => optionValueMap.get(value)?.data ?? '')\n      }\n\n      emitEvent(props.onSelect, type, selected, data)\n    }\n\n    function handlePanelFocus(type: 'source' | 'target') {\n      if (type === 'source') {\n        source.value?.$el.focus()\n      } else {\n        target.value?.$el.focus()\n      }\n    }\n\n    function handlePanelBlur() {\n      source.value?.$el.blur()\n      target.value?.$el.blur()\n    }\n\n    function createSlotRender(names: string[]) {\n      for (const name of names) {\n        if (slots[name]) {\n          return (params: any) => renderSlot(slots, name, params)\n        }\n      }\n\n      return null\n    }\n\n    return () => {\n      return (\n        <div id={idFor.value} class={className.value}>\n          <TransferPanel\n            ref={source}\n            v-model:selected={sourceSelected.value}\n            type='source'\n            class={nh.bem('panel', 'source')}\n            state={props.state}\n            paged={props.paged}\n            filter={sourceFilter.value}\n            disabled={props.disabled}\n            title={props.sourceTitle || locale.value.source}\n            options={sourceOptions.value}\n            empty-text={props.emptyText || locale.value.empty}\n            option-height={props.optionHeight}\n            ignore-case={props.ignoreCase}\n            deep-state={props.deepState}\n            loading={props.loading}\n            loading-icon={props.loadingIcon}\n            loading-lock={props.loadingLock}\n            loading-effect={props.loadingEffect}\n            locale={locale.value}\n            onSelect={() => handleSelect('source')}\n            onEnter={handleToTarget}\n            onSwitch={() => handlePanelFocus('target')}\n          >\n            {{\n              header: createSlotRender(['source-header', 'sourceHeader', 'header']),\n              title: createSlotRender(['source-title', 'sourceTitle', 'title']),\n              body: createSlotRender(['source-body', 'sourceBody', 'body']),\n              footer: createSlotRender(['source-footer', 'sourceFooter', 'footer']),\n              option: createSlotRender(['source-option', 'sourceOption', 'option'])\n            }}\n          </TransferPanel>\n          <div class={nh.be('actions')}>\n            {slots.actions\n              ? renderSlot(slots, 'actions', {\n                handleToTarget,\n                handleToSource\n              })\n              : [\n                <Button\n                  key={1}\n                  inherit\n                  class={nh.be('action')}\n                  type={actionType.value}\n                  size='small'\n                  disabled={props.disabled || !toTargetEnabled.value}\n                  loading={readonly.value}\n                  loading-icon={props.loadingIcon}\n                  loading-effect={props.loadingEffect}\n                  style={{ marginBottom: '6px' }}\n                  onClick={handleToTarget}\n                >\n                  {{\n                    icon: () => <Icon {...icons.value.angleRight} label='to right'></Icon>\n                  }}\n                </Button>,\n                <Button\n                  key={2}\n                  inherit\n                  class={nh.be('action')}\n                  type={actionType.value}\n                  size='small'\n                  disabled={props.disabled || !toSourceEnabled.value}\n                  loading={readonly.value}\n                  loading-icon={props.loadingIcon}\n                  loading-effect={props.loadingEffect}\n                  style={{ margin: '0' }}\n                  onClick={handleToSource}\n                >\n                  {{\n                    icon: () => <Icon {...icons.value.angleLeft} label='to left'></Icon>\n                  }}\n                </Button>\n                ]}\n          </div>\n          <TransferPanel\n            ref={target}\n            v-model:selected={targetSelected.value}\n            type='target'\n            class={nh.bem('panel', 'target')}\n            state={props.state}\n            paged={props.paged}\n            filter={targetFilter.value}\n            disabled={props.disabled}\n            title={props.targetTitle || locale.value.target}\n            options={targetOptions.value}\n            empty-text={props.emptyText || locale.value.empty}\n            option-height={props.optionHeight}\n            ignore-case={props.ignoreCase}\n            deep-state={props.deepState}\n            loading={props.loading}\n            loading-icon={props.loadingIcon}\n            loading-lock={props.loadingLock}\n            loading-effect={props.loadingEffect}\n            locale={locale.value}\n            onSelect={() => handleSelect('target')}\n            onEnter={handleToSource}\n            onSwitch={() => handlePanelFocus('source')}\n          >\n            {{\n              header: createSlotRender(['target-header', 'targetHeader', 'header']),\n              title: createSlotRender(['target-title', 'targetTitle', 'title']),\n              body: createSlotRender(['target-body', 'targetBody', 'body']),\n              footer: createSlotRender(['target-footer', 'targetFooter', 'footer']),\n              option: createSlotRender(['target-option', 'targetOption', 'option'])\n            }}\n          </TransferPanel>\n        </div>\n      )\n    }\n  }\n})\n"
    }
  ],
  "dependencies": ["@pocui/config", "vue", "@pocui/hooks", "@pocui/utils"],
  "registryDependencies": [
    "transfer.scss",
    "icon",
    "checkbox",
    "collapse-transition",
    "input",
    "number-input",
    "resize-observer",
    "virtual-list",
    "button",
    "form"
  ],
  "categories": ["other"],
  "meta": { "isReferenceOnly": false }
}
