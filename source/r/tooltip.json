{
  "name": "tooltip",
  "type": "registry:component",
  "description": "用于需要在特定元素周围弹出一下拓展信息。",
  "files": [
    {
      "target": "components/tooltip/index.ts",
      "content": "export { default as Tooltip } from './tooltip'\nexport { tooltipProps } from './props'\n\nexport type { TooltipProps, TooltipCProps } from './props'\nexport type { TooltipTheme, TooltipTrigger, TooltipShift, TooltipVirtual, TooltipExposed } from './symbol'\n"
    },
    {
      "target": "components/tooltip/props.ts",
      "content": "import {\n  booleanProp,\n  booleanStringProp,\n  buildProps,\n  classProp,\n  eventProp,\n  styleProp\n} from '@pocui/config'\n\nimport type { ConfigurableProps } from '@pocui/config'\nimport type { Placement } from '@pocui/hooks'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { TooltipShift, TooltipTrigger, TooltipVirtual } from './symbol'\n\nexport const tooltipProps = buildProps({\n  trigger: [String, Array] as PropType<TooltipTrigger>,\n  wrapper: booleanStringProp,\n  noArrow: booleanProp,\n  transitionName: String,\n  visible: booleanProp,\n  placement: String as PropType<Placement>,\n  outsideClose: booleanProp,\n  noHover: booleanProp,\n  tipClass: classProp,\n  tipStyle: styleProp,\n  transfer: booleanStringProp,\n  disabled: booleanProp,\n  raw: booleanProp,\n  delay: [Number, Array] as PropType<number | number[]>,\n  tipAlive: booleanProp,\n  reverse: booleanProp,\n  width: [String, Number] as PropType<number | 'trigger' | 'auto'>,\n  virtual: Object as PropType<TooltipVirtual>,\n  shift: {\n    type: [Boolean, String] as PropType<boolean | TooltipShift>,\n    default: null\n  },\n  onToggle: eventProp<(visible: boolean) => void>(),\n  onTipEnter: eventProp(),\n  onTipLeave: eventProp(),\n  onClickOutside: eventProp(),\n  onOutsideClose: eventProp()\n})\n\nexport type TooltipProps = ExtractPropTypes<typeof tooltipProps>\nexport type TooltipCProps = ConfigurableProps<TooltipProps>\n"
    },
    {
      "target": "components/tooltip/symbol.ts",
      "content": "import type { ComponentPublicInstance } from 'vue'\n\nexport type TooltipTheme = 'light' | 'dark'\nexport type TooltipTrigger = 'hover' | 'click' | 'focus' | 'hover-focus' | 'custom'\nexport type TooltipShift = 'horizontal' | 'vertical' | 'both'\n\nexport type TooltipVirtual =\n  | {\n    getBoundingClientRect: () => DOMRect\n  }\n  | {\n    $el: {\n      getBoundingClientRect: () => DOMRect\n    }\n  }\n  | {\n    x: number,\n    y: number\n  }\nexport interface TooltipExposed extends ComponentPublicInstance {\n  rendering: boolean,\n  trigger: HTMLElement | undefined | null,\n  toggleVisible: (visible: boolean) => void,\n  updatePopper: () => void\n}\n"
    },
    {
      "target": "components/tooltip/tooltip.tsx",
      "content": "import { Popper } from '@/components/popper'\n\nimport {\n  Fragment,\n  computed,\n  createTextVNode,\n  defineComponent,\n  mergeProps,\n  ref,\n  renderSlot,\n  shallowReadonly,\n  toRef,\n  watch\n} from 'vue'\n\nimport { emitEvent, useHoverDelay, useNameHelper, useProps } from '@pocui/config'\n\nimport {\n  placementWhileList,\n  useClickOutside,\n  useListener,\n  usePopper,\n  useSetTimeout\n} from '@pocui/hooks'\n\nimport { isElement } from '@pocui/utils'\n\nimport { tooltipProps } from './props'\n\nimport type { PopperExposed } from '@/components/popper'\n\nimport type { VirtualElement } from '@pocui/hooks'\n\nimport type { SlotsType } from 'vue'\n\nconst TEXT_VNODE = createTextVNode('').type\n\nexport default defineComponent({\n  name: 'Tooltip',\n  description:'用于需要在特定元素周围弹出一下拓展信息。',\n  categories: ['feedback'],\n  inheritAttrs: true,\n  props: tooltipProps,\n  slots: Object as SlotsType<{\n    default(props: { toggleVisible: (visible?: boolean) => void, updatePopper: () => Promise<void> }): any,\n    trigger(props: { toggleVisible: (visible?: boolean) => void, updatePopper: () => Promise<void> }): any\n  }>,\n  emits: ['clickoutside', 'update:visible'],\n  setup(_props, { attrs, slots, emit, expose }) {\n    const nh = useNameHelper('tooltip')\n    const props = useProps('tooltip', _props, {\n      trigger: {\n        default: 'hover',\n        validator: value => {\n          return ['hover', 'click', 'focus', 'hover-focus', 'custom'].includes(value)\n        }\n      },\n      wrapper: false,\n      noArrow: false,\n      transitionName: () => nh.ns('fade'),\n      visible: false,\n      placement: {\n        default: 'top',\n        validator: value => placementWhileList.includes(value)\n      },\n      outsideClose: true,\n      noHover: false,\n      tipClass: null,\n      tipStyle: null,\n      transfer: false,\n      disabled: false,\n      raw: false,\n      delay: 250,\n      tipAlive: false,\n      reverse: false,\n      width: 'auto',\n      virtual: null,\n      shift: false\n    })\n\n    const hoverDelay = useHoverDelay()\n    const { timer } = useSetTimeout()\n\n    const placement = toRef(props, 'placement')\n    const currentVisible = ref(props.visible)\n    const rendering = ref(props.visible)\n    const transfer = toRef(props, 'transfer')\n    const triggerWidth = ref(100)\n\n    let hovered = false\n    let focused = false\n\n    const useHover = computed(() => props.trigger === 'hover' || props.trigger === 'hover-focus')\n    const useFocus = computed(() => props.trigger === 'focus' || props.trigger === 'hover-focus')\n\n    const originalTrigger = ref<HTMLElement>()\n    const reference = computed(() => {\n      const virtual = (props.virtual as any)?.$el ?? props.virtual\n\n      if (virtual) {\n        if ('getBoundingClientRect' in virtual) {\n          return virtual as VirtualElement\n        }\n\n        if ('x' in virtual && 'y' in virtual) {\n          return {\n            getBoundingClientRect: () => ({\n              x: virtual.x,\n              y: virtual.y,\n              left: virtual.x,\n              top: virtual.y,\n              width: 0,\n              height: 0\n            })\n          } as VirtualElement\n        }\n      }\n\n      return originalTrigger.value\n    })\n    const triggerEl = computed(() => (isElement(reference.value) ? reference.value : null))\n    const delay = computed(() => {\n      return typeof props.delay === 'number'\n        ? new Array<number>(2).fill(Math.max(props.delay, 0))\n        : props.delay.map(delay => Math.max(delay, 0))\n    })\n    const popper = ref<PopperExposed>()\n    const popperEl = computed(() => popper.value?.wrapper)\n    const arrow = ref<HTMLElement>()\n    const shift = computed<{ mainAxis?: boolean, crossAxis?: boolean }>(() => {\n      if (!props.shift) {\n        return { mainAxis: false }\n      }\n\n      if (props.shift === true || props.shift === 'both') {\n        return { crossAxis: true }\n      }\n\n      return props.shift === 'horizontal'\n        ? {\n            mainAxis: false,\n            crossAxis: true\n          }\n        : {}\n    })\n    const { transferTo, updatePopper } = usePopper({\n      placement,\n      transfer,\n      arrow,\n      reference,\n      shift,\n      wrapper: originalTrigger,\n      popper: popperEl\n    })\n\n    useClickOutside(handleClickOutside, originalTrigger)\n    useClickOutside(() => {\n      if (currentVisible.value && !originalTrigger.value) {\n        handleClickOutside()\n      }\n    }, popperEl)\n\n    const tipStyle = computed(() => {\n      if (props.width === 'auto') {\n        return props.tipStyle\n      }\n\n      if (props.width === 'trigger') {\n        return [{ width: `${triggerWidth.value}px` }, props.tipStyle]\n      }\n\n      return [{ width: `${props.width}px` }, props.tipStyle]\n    })\n\n    const slotParams = shallowReadonly({\n      toggleVisible,\n      updatePopper\n    })\n\n    useListener(triggerEl, 'mouseenter', handleTriggerEnter)\n    useListener(triggerEl, 'mouseleave', handleTriggerLeave)\n    useListener(triggerEl, 'click', handleTriggerClick)\n    useListener(triggerEl, 'focus', handleTriggerFocus)\n    useListener(triggerEl, 'blur', handleTriggerBlur)\n    useListener(popperEl, 'mouseenter', handleTriggerEnter)\n    useListener(popperEl, 'mouseleave', handleTriggerLeave)\n\n    watch(\n      () => props.visible,\n      value => {\n        currentVisible.value = value\n\n        if (value) {\n          rendering.value = true\n          updatePopper().then()\n        }\n      }\n    )\n    watch(\n      () => props.disabled,\n      value => {\n        if (value) {\n          toggleVisible(false)\n        }\n      }\n    )\n\n    expose({\n      rendering,\n      trigger: triggerEl,\n      toggleVisible,\n      updatePopper\n    })\n\n    /**\n     * 切换提示框的显示状态\n     * @param visible （可选）一个布尔值,指定目标可见性状态.如果未提供,将根据当前可见性状态进行切换\n     */\n    function toggleVisible(visible = !currentVisible.value) {\n      if (currentVisible.value === visible) return\n      currentVisible.value = visible\n\n      if (visible) {\n        computeTriggerWidth()\n        rendering.value = true\n        updatePopper().then()\n      }\n\n      emit('update:visible', visible)\n      emitEvent(props.onToggle, visible)\n    }\n\n    /**\n     * 计算并更新触发元素的宽度\n     * 此函数通常用于确保弹出层（或类似的UI元素）与触发元素正确对齐\n     */\n    function computeTriggerWidth() {\n      if (!triggerEl.value) return\n\n      triggerWidth.value = triggerEl.value.offsetWidth\n    }\n\n    /**\n     * 获取当前激活状态.\n     * 根据是否启用悬停或焦点监听来确定激活状态.如果组件设置为监听悬停或焦点.\n     * 并且相应的状态为真,当前处于悬停或焦点状态,则返回 true.\n     *\n     * @returns 如果组件因悬停或焦点而处于激活状态,则返回 true;否则返回 false.\n     */\n    function getActiveState() {\n      return (useHover.value && hovered) || (useFocus.value && focused)\n    }\n\n    /**\n     * 处理触发元素的进入事件.\n     *\n     * @remarks\n     * 当触发元素被鼠标悬停或获得焦点时调用此函数.如果组件没有被禁用,并且设置为在 hover 时显示,\n     * 会启动一个延时器,在指定的延迟后将 `hovered` 状态设置为 `true` 并根据激活状态切换可见性.\n     * 同时,触发 `onTipEnter` 事件.\n     */\n    function handleTriggerEnter() {\n      if (props.disabled) return\n\n      if (useHover.value) {\n        clearTimeout(timer.hover)\n\n        timer.hover = setTimeout(() => {\n          hovered = true\n          toggleVisible(getActiveState())\n        }, delay.value[0] ?? hoverDelay.value)\n      }\n\n      emitEvent(props.onTipEnter)\n    }\n\n    /**\n     * 处理触发元素的离开事件.\n     *\n     * @remarks\n     * 当触发元素不再被鼠标悬停或失去焦点时调用此函数.如果组件没有被禁用,并且设置为在 hover 状态改变时显示,\n     * 会启动一个延时器,在指定的延迟后将 `hovered` 状态设置为 `false` 并根据激活状态切换可见性.\n     * 同时,触发 `onTipLeave` 事件.\n     */\n    function handleTriggerLeave() {\n      if (props.disabled) return\n\n      if (useHover.value) {\n        clearTimeout(timer.hover)\n\n        timer.hover = setTimeout(() => {\n          hovered = false\n          toggleVisible(getActiveState())\n        }, delay.value[1] ?? hoverDelay.value)\n      }\n\n      emitEvent(props.onTipLeave)\n    }\n\n    /**\n     * 处理触发元素的点击事件.\n     *\n     * @remarks\n     * 当触发元素被点击时调用此函数.如果组件没有被禁用,并且触发类型设置为 'click',\n     * 则会切换组件的可见性.这允许在点击触发元素时显示或隐藏相关的UI元素,如工具提示或弹出菜单.\n     */\n    function handleTriggerClick() {\n      if (props.disabled) return\n\n      if (props.trigger === 'click') {\n        toggleVisible()\n      }\n    }\n\n    /**\n     * 处理触发元素的焦点事件.\n     *\n     * @remarks\n     * 当触发元素获得焦点时调用此函数.如果组件没有被禁用,并且设置为在获得焦点时改变状态,\n     * 则会将 `focused` 状态设置为 `true` 并根据当前的激活状态切换组件的可见性.\n     * 这允许在元素获得焦点时显示相关的 UI 元素,如工具提示或弹出菜单,增强了组件的可访问性.\n     */\n    function handleTriggerFocus() {\n      if (props.disabled) return\n\n      if (useFocus.value) {\n        focused = true\n        toggleVisible(getActiveState())\n      }\n    }\n\n    /**\n     * 处理触发元素的失焦事件.\n     *\n     * @remarks\n     * 当触发元素失去焦点时调用此函数.如果组件没有被禁用,并且设置为在失去焦点时改变状态,\n     * 则会将 `focused` 状态设置为 `false` 并根据当前的激活状态切换组件的可见性.\n     * 这允许在元素失去焦点时隐藏相关的 UI 元素,如工具提示或弹出菜单,从而改善用户体验和界面的整洁度.\n     */\n    function handleTriggerBlur() {\n      if (props.disabled) return\n\n      if (useFocus.value) {\n        focused = false\n        toggleVisible(getActiveState())\n      }\n    }\n\n    /**\n     * 处理点击元素外部的事件.\n     *\n     * @remarks\n     * 当点击发生在触发元素外部时调用此函数.如果组件没有被禁用,首先会触发 `onClickOutside` 事件.\n     * 如果 `props.outsideClose` 为 `true`,触发类型不是 'custom',且当前组件是可见的,则会关闭组件并触发 `onOutsideClose` 事件.\n     * 这个机制常用于关闭弹出菜单、下拉列表或模态框等,当用户点击这些组件之外的区域时,提供更好的用户交互体验.\n     */\n    function handleClickOutside() {\n      if (props.disabled) return\n\n      emitEvent(props.onClickOutside)\n\n      if (props.outsideClose && props.trigger !== 'custom' && currentVisible.value) {\n        toggleVisible(false)\n        emitEvent(props.onOutsideClose)\n      }\n    }\n\n    /**\n     * 同步触发元素的引用.\n     *\n     * @remarks\n     * 此函数用于同步或更新 `originalTrigger` 引用,使其指向传入元素的下一个兄弟元素.\n     * 如果传入的元素存在,则 `originalTrigger` 被更新为该元素的下一个兄弟元素;如果传入的元素不存在（或为 `null`）,\n     * 则 `originalTrigger` 的值被清除（设置为 `undefined`）.\n     *\n     * @param el - 可选参数,HTMLElement 或 null,传入的元素,通常是触发组件显示的元素.\n     */\n    function syncTriggerRef(el?: HTMLElement | null) {\n      if (el) {\n        originalTrigger.value = el.nextElementSibling as HTMLElement | undefined\n      } else {\n        originalTrigger.value = undefined\n      }\n    }\n\n    /**\n     * 同步渲染状态.\n     *\n     * @remarks\n     * 此函数用于将 `rendering` 的响应式引用的值同步更新为 `currentVisible` 的当前值.\n     * 这通常用于确保组件的渲染状态与其可见性状态保持一致.当组件的可见性发生变化时,\n     * 可以调用此函数来更新组件的内部渲染状态,以控制是否渲染组件的相关内容.\n     */\n    function syncRendering() {\n      rendering.value = currentVisible.value\n    }\n\n    /**\n     * 阻止事件冒泡.\n     *\n     * @remarks\n     * 该函数用于在事件处理函数中调用,以阻止给定的鼠标事件继续冒泡至父元素.\n     * 这常用于嵌套的事件处理场景,当你不希望某个事件的处理器触发后,该事件继续触发更上层元素的同类型事件处理器时.\n     *\n     * @param event - MouseEvent 类型的事件对象,表示触发该函数的鼠标事件.\n     */\n    function stopPropagation(event: MouseEvent) {\n      event.stopPropagation()\n    }\n\n    return () => {\n      const CustomTag = props.wrapper ? ((props.wrapper === true ? 'span' : props.wrapper) as any) : null\n      const triggers = slots.trigger?.(slotParams)\n      const triggerVNode = triggers ? triggers[0] : null\n\n      const renderTrigger = () => {\n        if (!triggerVNode) return null\n\n        if (triggerVNode.type === TEXT_VNODE) {\n          return CustomTag ? <span>{triggerVNode}</span> : <span {...attrs}>{triggerVNode}</span>\n        }\n\n        if (!CustomTag) {\n          triggerVNode.props = mergeProps(triggerVNode.props || {}, attrs)\n        }\n\n        return triggerVNode\n      }\n      return [\n        triggerVNode &&\n          (CustomTag\n            ? (\n              <CustomTag {...attrs} ref={originalTrigger} class={[nh.b(), nh.bs('vars'), props.inherit && nh.in()]}>\n                {triggers}\n              </CustomTag>\n              )\n            : (\n              <Fragment ref={syncTriggerRef as any}>{renderTrigger()}</Fragment>\n              )),\n        !props.disabled && (props.tipAlive || rendering.value) && (\n          <Popper\n            ref={popper}\n            class={[\n              nh.be('popper'),\n              nh.bs('vars'),\n              {\n                [nh.bem('popper', props.reverse ? 'dark' : 'light')]: true,\n                [nh.bem('popper', 'no-hover')]: props.noHover,\n                [nh.bem('popper', 'no-arrow')]: props.noArrow\n              }\n            ]}\n            appear\n            visible={currentVisible.value}\n            alive={props.tipAlive}\n            to={transferTo.value}\n            transition={props.transitionName}\n            role='tooltip'\n            tabindex={-1}\n            onClick={stopPropagation}\n            onAnimationend={syncRendering}\n            onTransitionend={syncRendering}\n          >\n            <div class={[!props.raw && nh.be('tip'), props.tipClass]} style={tipStyle.value}>\n              {renderSlot(slots, 'default', slotParams)}\n            </div>\n            {!props.raw && !props.noArrow && <div ref={arrow} class={nh.be('arrow')}></div>}\n          </Popper>\n        )\n      ]\n    }\n  }\n})\n"
    }
  ],
  "dependencies": ["@pocui/config", "@pocui/hooks", "vue", "@pocui/utils"],
  "registryDependencies": ["tooltip.scss", "popper"],
  "categories": ["feedback"],
  "meta": { "isReferenceOnly": false }
}
