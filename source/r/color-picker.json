{
  "name": "color-picker",
  "type": "registry:components",
  "description": "提供一个选择器可用于让用户快速灵活地选择颜色值。",
  "files": [
    {
      "target": "components/color-picker/color-alpha.vue",
      "content": "<script lang=\"ts\">\nimport { computed, defineComponent, ref, watch } from 'vue'\n\nimport { useNameHelper } from '@pocui/config'\nimport { useModifier, useMoving } from '@pocui/hooks'\n\nimport { boundRange, toFixed } from '@pocui/utils'\n\nimport type { RGBColor } from '@pocui/utils'\nimport type { PropType } from 'vue'\n\nexport default defineComponent({\n  name: 'ColorAlpha',\n  description:'一维透明度滑块，帮助用户精确控制颜色透明通道。',\n  categories: ['form'],\n  props: {\n    rgb: {\n      type: Object as PropType<RGBColor>,\n      default: () => {\n        return {\n          r: 0,\n          g: 0,\n          b: 0\n        }\n      },\n      validator: (value: RGBColor) => {\n        return 'r' in value && 'g' in value && 'b' in value\n      }\n    },\n    alpha: {\n      type: Number,\n      default: 1,\n      validator: (value: number) => {\n        return value >= 0 && value <= 1\n      }\n    }\n  },\n  emits: ['edit-start', 'edit-end', 'change'],\n  setup(props, { emit }) {\n    const currentLeft = ref(props.alpha * 100)\n\n    let prevLeft = currentLeft.value\n    let widthLimit: number\n    let leftStartAt: number\n\n    const { target: wrapper } = useModifier({\n      passive: false,\n      onKeyDown: (event, modifier) => {\n        if (modifier.left || modifier.right) {\n          event.preventDefault()\n\n          const step = event.ctrlKey ? 10 : event.altKey ? 0.5 : 2\n          const delta = step * (modifier.left ? -1 : 1)\n\n          currentLeft.value += delta\n\n          verifyPosition()\n          prevLeft = currentLeft.value\n          handleChange()\n        }\n      }\n    })\n\n    const { moving: editing } = useMoving({\n      target: wrapper,\n      onStart: (state, event) => {\n        if (!wrapper.value || event.button > 0) {\n          return false\n        }\n\n        const rect = wrapper.value.getBoundingClientRect()\n        const { left, width } = rect\n\n        widthLimit = width\n        currentLeft.value = ((leftStartAt = state.clientX - left) / width) * 100\n\n        verifyPosition()\n        emit('edit-start')\n\n        if (Math.abs(currentLeft.value - prevLeft) >= 0.01) {\n          prevLeft = currentLeft.value\n          handleChange()\n        }\n      },\n      onMove: state => {\n        currentLeft.value = ((leftStartAt + state.deltaX) / widthLimit) * 100\n\n        verifyPosition()\n        handleChange()\n      },\n      onEnd: () => {\n        emit('edit-end')\n      }\n    })\n\n    const rgbString = computed(() => {\n      const { r, g, b } = props.rgb\n\n      return `${r}, ${g}, ${b}`\n    })\n\n    verifyPosition()\n\n    watch(\n      () => props.alpha,\n      value => {\n        currentLeft.value = value * 100\n        verifyPosition()\n      },\n      { immediate: true }\n    )\n\n    function verifyPosition() {\n      currentLeft.value = toFixed(boundRange(currentLeft.value, 0, 100), 3)\n    }\n\n    function handleChange() {\n      emit('change', currentLeft.value / 100)\n    }\n\n    return {\n      nh: useNameHelper('color-picker'),\n      currentLeft,\n      editing,\n\n      rgbString,\n\n      wrapper\n    }\n  }\n})\n</script>\n\n<template>\n  <div\n    ref=\"wrapper\"\n    :class=\"nh.be('alpha')\"\n    tabindex=\"-1\"\n    role=\"group\"\n  >\n    <div\n      :class=\"nh.be('opacity')\"\n      :style=\"{\n        backgroundImage: `linear-gradient(to right, rgba(${rgbString}, 0) 0%, rgb(${rgbString}) 100%)`\n      }\"\n    ></div>\n    <div :class=\"nh.be('alpha-handler')\" :style=\"{ left: `${currentLeft}%` }\"></div>\n  </div>\n</template>\n"
    },
    {
      "target": "components/color-picker/color-hue.vue",
      "content": "<script lang=\"ts\">\nimport { defineComponent, ref, watch } from 'vue'\n\nimport { useNameHelper } from '@pocui/config'\nimport { useModifier, useMoving } from '@pocui/hooks'\nimport { boundRange, toFixed } from '@pocui/utils'\n\nexport default defineComponent({\n  name: 'ColorHue',\n  description:'一维色相滑块，可嵌套任意方向，快速设定基础色相。',\n  categories: ['form'],\n  props: {\n    hue: {\n      type: Number,\n      default: 0,\n      validator: (value: number) => {\n        return value >= 0 && value <= 360\n      }\n    }\n  },\n  emits: ['edit-start', 'edit-end', 'change'],\n  setup(props, { emit }) {\n    const currentLeft = ref(props.hue * 100)\n\n    let prevLeft = currentLeft.value\n    let widthLimit: number\n    let leftStartAt: number\n\n    const { target: wrapper } = useModifier({\n      passive: false,\n      onKeyDown: (event, modifier) => {\n        if (modifier.left || modifier.right) {\n          event.preventDefault()\n\n          const step = event.ctrlKey ? 10 : event.altKey ? 0.5 : 2\n          const delta = step * (modifier.left ? -1 : 1)\n\n          currentLeft.value += delta\n\n          verifyPosition()\n          prevLeft = currentLeft.value\n          handleChange()\n        }\n      }\n    })\n\n    const { moving: editing } = useMoving({\n      target: wrapper,\n      onStart: (state, event) => {\n        if (!wrapper.value || event.button > 0) {\n          return false\n        }\n\n        const rect = wrapper.value.getBoundingClientRect()\n        const { left, width } = rect\n\n        widthLimit = width\n        currentLeft.value = ((leftStartAt = state.clientX - left) / width) * 100\n\n        verifyPosition()\n        emit('edit-start')\n\n        if (Math.abs(currentLeft.value - prevLeft) >= 0.01) {\n          prevLeft = currentLeft.value\n          handleChange()\n        }\n      },\n      onMove: state => {\n        currentLeft.value = ((leftStartAt + state.deltaX) / widthLimit) * 100\n\n        verifyPosition()\n        handleChange()\n      },\n      onEnd: () => {\n        emit('edit-end')\n      }\n    })\n\n    watch(\n      () => props.hue,\n      value => {\n        currentLeft.value = (value / 360) * 100\n        verifyPosition()\n      },\n      { immediate: true }\n    )\n\n    function verifyPosition() {\n      currentLeft.value = toFixed(boundRange(currentLeft.value, 0, 100), 3)\n    }\n\n    function handleChange() {\n      emit('change', (currentLeft.value / 100) * 360)\n    }\n\n    return {\n      nh: useNameHelper('color-picker'),\n      currentLeft,\n      editing,\n\n      wrapper\n    }\n  }\n})\n</script>\n\n<template>\n  <div\n    ref=\"wrapper\"\n    :class=\"nh.be('hue')\"\n    tabindex=\"-1\"\n    role=\"group\"\n  >\n    <div :class=\"nh.be('hue-handler')\" :style=\"{ left: `${currentLeft}%` }\"></div>\n  </div>\n</template>\n"
    },
    {
      "target": "components/color-picker/color-palette.vue",
      "content": "<script lang=\"ts\">\nimport { defineComponent, ref, watch } from 'vue'\n\nimport { useNameHelper } from '@pocui/config'\nimport { useModifier, useMoving } from '@pocui/hooks'\nimport { boundRange, toFixed } from '@pocui/utils'\n\nexport default defineComponent({\n  name: 'ColorPalette',\n  description:'二维饱和-明度调色板，通过鼠标或键盘采样色相环上的饱和/明度，实时输出坐标与颜色值。',\n  categories: ['form'],\n  props: {\n    hue: {\n      type: Number,\n      default: 0,\n      validator: (value: number) => {\n        return value >= 0 && value <= 360\n      }\n    },\n    value: {\n      type: Number,\n      default: 1,\n      validator: (value: number) => {\n        return value >= 0 && value <= 1\n      }\n    },\n    saturation: {\n      type: Number,\n      default: 0,\n      validator: (value: number) => {\n        return value >= 0 && value <= 1\n      }\n    }\n  },\n  emits: ['edit-start', 'edit-end', 'change'],\n  setup(props, { emit }) {\n    const currentTop = ref((1 - props.value) * 100)\n    const currentLeft = ref(props.saturation * 100)\n\n    let prevTop = currentTop.value\n    let prevLeft = currentLeft.value\n    let widthLimit: number\n    let heightLimit: number\n    let topStartAt: number\n    let leftStartAt: number\n\n    const { target: wrapper } = useModifier({\n      passive: false,\n      onKeyDown: (event, modifier) => {\n        if (modifier.up || modifier.down || modifier.left || modifier.right) {\n          event.preventDefault()\n\n          const step = event.ctrlKey ? 10 : event.altKey ? 0.5 : 2\n          const sign = modifier.up || modifier.left ? -1 : 1\n          const delta = step * sign\n\n          if (modifier.up || modifier.down) {\n            currentTop.value += delta\n          } else {\n            currentLeft.value += delta\n          }\n\n          verifyPosition()\n          prevTop = currentTop.value\n          prevLeft = currentLeft.value\n          handleChange()\n        }\n      }\n    })\n\n    const { moving: editing } = useMoving({\n      target: wrapper,\n      onStart: (state, event) => {\n        if (!wrapper.value || event.button > 0) {\n          return false\n        }\n\n        const rect = wrapper.value.getBoundingClientRect()\n        const { top, left, width, height } = rect\n\n        widthLimit = width\n        heightLimit = height\n\n        currentTop.value = ((topStartAt = state.clientY - top) / height) * 100\n        currentLeft.value = ((leftStartAt = state.clientX - left) / width) * 100\n\n        verifyPosition()\n        emit('edit-start')\n\n        let changed = false\n\n        if (Math.abs(currentTop.value - prevTop) >= 0.01) {\n          prevTop = currentTop.value\n          changed = true\n        }\n\n        if (Math.abs(currentLeft.value - prevLeft) >= 0.01) {\n          prevLeft = currentLeft.value\n          changed = true\n        }\n\n        changed && handleChange()\n      },\n      onMove: state => {\n        currentTop.value = ((topStartAt + state.deltaY) / heightLimit) * 100\n        currentLeft.value = ((leftStartAt + state.deltaX) / widthLimit) * 100\n\n        verifyPosition()\n        handleChange()\n      },\n      onEnd: () => {\n        emit('edit-end')\n      }\n    })\n\n    watch(\n      () => props.value,\n      value => {\n        currentTop.value = (1 - value) * 100\n        verifyPosition()\n      },\n      { immediate: true }\n    )\n    watch(\n      () => props.saturation,\n      value => {\n        currentLeft.value = value * 100\n        verifyPosition()\n      },\n      { immediate: true }\n    )\n\n    function verifyPosition() {\n      currentTop.value = toFixed(boundRange(currentTop.value, 0, 100), 3)\n      currentLeft.value = toFixed(boundRange(currentLeft.value, 0, 100), 3)\n    }\n\n    function handleChange() {\n      emit('change', {\n        h: props.hue,\n        s: currentLeft.value / 100,\n        v: toFixed(1 - currentTop.value / 100, 3)\n      })\n    }\n\n    return {\n      nh: useNameHelper('color-picker'),\n      currentTop,\n      currentLeft,\n      editing,\n\n      wrapper\n\n      // handleMouseDown\n    }\n  }\n})\n</script>\n\n<template>\n  <div\n    ref=\"wrapper\"\n    :class=\"nh.be('palette')\"\n    tabindex=\"-1\"\n    role=\"group\"\n    :style=\"{\n      backgroundColor: `hsl(${hue}, 100%, 50%)`\n    }\"\n  >\n    <div :class=\"nh.be('saturation')\" role=\"none\"></div>\n    <div :class=\"nh.be('value')\" role=\"none\"></div>\n    <div\n      :class=\"nh.be('palette-handler')\"\n      :style=\"{\n        top: `${currentTop}%`,\n        left: `${currentLeft}%`\n      }\"\n    >\n      <div :class=\"nh.be('palette-pointer')\"></div>\n    </div>\n  </div>\n</template>\n"
    },
    {
      "target": "components/color-picker/color-picker.vue",
      "content": "<script setup lang=\"ts\">\nimport { Button } from '@/components/button'\nimport { useFieldStore } from '@/components/form'\nimport { Icon } from '@/components/icon'\nimport { Input } from '@/components/input'\n\nimport { Popper } from '@/components/popper'\n\nimport { computed, nextTick, ref, toRef, watch } from 'vue'\n\nimport {\n  getLast,\n  hsvToHsl,\n  hsvToRgb,\n  isClient,\n  isElement,\n  parseColorToRgba,\n  rgbToHex,\n  rgbToHsv,\n  rgbaToHex,\n  toAttrValue,\n  toFixed\n} from '@pocui/utils'\n\nimport { placementWhileList, useClickOutside, useHover, usePopper } from '@pocui/hooks'\nimport {\n  createIconProp,\n  createSizeProp,\n  createStateProp,\n  emitEvent,\n  useIcons,\n  useLocale,\n  useNameHelper,\n  useProps\n} from '@pocui/config'\nimport ColorAlpha from './color-alpha.vue'\nimport ColorHue from './color-hue.vue'\n\nimport ColorPalette from './color-palette.vue'\nimport { colorPickerProps } from './props'\n\nimport { defaultShortcuts, getDefaultHsv } from './symbol'\n\nimport type { ColorFormat } from './symbol'\nimport type { Color, HSLAColor, HSVAColor, HSVColor, RGBAColor, RGBColor } from '@pocui/utils'\nimport type { PopperExposed } from '@/components/popper'\n\ndefineOptions({\n  name: 'ColorPicker',\n  description: '提供一个选择器可用于让用户快速灵活地选择颜色值。',\n  categories: ['form']\n})\n\nconst { idFor, labelId, state, disabled, loading, size, validateField, clearField, getFieldValue, setFieldValue } =\n  useFieldStore<Color | null>(() => reference.value?.focus())\n\nconst nh = useNameHelper('color-picker')\n\nconst _props = defineProps(colorPickerProps)\nconst props = useProps('colorPicker', _props, {\n  size: createSizeProp(size),\n  state: createStateProp(state),\n  locale: null,\n  value: {\n    default: () => getFieldValue()!,\n    static: true\n  },\n  visible: false,\n  format: {\n    default: 'rgb',\n    validator: value => ['rgb', 'hsl', 'hsv', 'hex'].includes(value)\n  },\n  alpha: false,\n  disabled: () => disabled.value,\n  transitionName: () => nh.ns('drop'),\n  noInput: false,\n  shortcut: false,\n  placement: {\n    default: 'bottom',\n    validator: value => placementWhileList.includes(value)\n  },\n  transfer: false,\n  outsideClose: true,\n  clearable: false,\n  cancelText: null,\n  confirmText: null,\n  prefix: createIconProp(),\n  prefixColor: '',\n  suffix: createIconProp(),\n  suffixColor: '',\n  noSuffix: false,\n  staticSuffix: false,\n  loading: () => loading.value,\n  loadingIcon: createIconProp(),\n  loadingLock: false,\n  loadingEffect: null,\n  popperAlive: null,\n  showLabel: false,\n  labelFormat: null\n})\n\nconst emit = defineEmits(['update:value', 'update:visible'])\n\nconst slots = defineSlots<{\n  control(props: { color: RGBColor, alpha: number, empty: boolean }): any,\n  prefix(): any,\n  suffix(): any,\n  label(props: { color: RGBColor, alpha: number, empty: boolean, label: string | undefined }): any\n}>()\n\nconst icons = useIcons()\nconst locale = useLocale('colorPicker', toRef(props, 'locale'))\n\nconst isEmpty = ref(true)\nconst currentVisible = ref(props.visible)\nconst currentValue = ref<HSVColor>(null!)\nconst currentAlpha = ref(1)\nconst editing = ref(false)\nconst placement = toRef(props, 'placement')\nconst transfer = toRef(props, 'transfer')\nconst shortcutHitting = ref(0)\nconst shortcutsFocused = ref(false)\n\nparseValue(props.value)\n\nconst palette = ref(null)\nconst hue = ref(null)\nconst alphaEl = ref(null)\nconst shortcutEl = ref(null)\nconst input = ref(null)\nconst cancel = ref(null)\nconst confirm = ref(null)\n\nconst wrapper = useClickOutside(handleClickOutside)\nconst popper = ref<PopperExposed>()\nconst { reference, transferTo, updatePopper } = usePopper({\n  placement,\n  transfer,\n  wrapper,\n  popper: computed(() => popper.value?.wrapper),\n  isDrop: true\n})\nconst { isHover } = useHover(reference)\n\nconst unitList = computed(() => {\n  return [palette.value, hue.value, alphaEl.value, shortcutEl.value, input.value, cancel.value, confirm.value].filter(\n    Boolean\n  ) as any[]\n})\n\nconst lastValue = ref<HSVAColor>({\n  ...currentValue.value,\n  a: currentAlpha.value,\n  format: 'hsva'\n})\n\nconst className = computed(() => {\n  return {\n    [nh.b()]: true,\n    [nh.ns('input-vars')]: true,\n    [nh.bs('vars')]: true,\n    [nh.in()]: props.inherit,\n    [nh.bm('empty')]: isEmpty.value && !currentVisible.value,\n    [nh.bm('focused')]: currentVisible.value,\n    [nh.bm('disabled')]: props.disabled,\n    [nh.bm('alpha')]: props.alpha,\n    [nh.bm(props.size)]: props.size !== 'default',\n    [nh.bm(props.state)]: props.state !== 'default'\n  }\n})\nconst readonly = computed(() => props.loading && props.loadingLock)\nconst selectorClass = computed(() => {\n  const baseCls = nh.be('selector')\n\n  return {\n    [baseCls]: true,\n    [`${baseCls}--disabled`]: props.disabled,\n    [`${baseCls}--readonly`]: readonly.value,\n    [`${baseCls}--loading`]: props.loading,\n    [`${baseCls}--${props.size}`]: props.size !== 'default',\n    [`${baseCls}--focused`]: currentVisible.value,\n    [`${baseCls}--${props.state}`]: props.state !== 'default'\n  }\n})\nconst rgb = computed(() => {\n  const { h, s, v } =\n    currentValue.value && currentVisible.value\n      ? currentValue.value\n      : (lastValue.value ?? {\n          h: 0,\n          s: 0,\n          v: 0\n        })\n\n  return hsvToRgb(h, s, v)\n})\nconst hex = computed(() => {\n  const { r, g, b } = rgb.value\n\n  if (props.alpha) {\n    return rgbaToHex(r, g, b, currentAlpha.value)\n  }\n\n  return rgbToHex(r, g, b)\n})\nconst shortcutList = computed(() => {\n  if (!props.shortcut) return []\n\n  if (Array.isArray(props.shortcut)) {\n    return props.shortcut\n  }\n\n  return defaultShortcuts\n})\nconst hasPrefix = computed(() => !!(slots.prefix || props.prefix))\nconst showClear = computed(() => {\n  return !props.disabled && !readonly.value && props.clearable && isHover.value && !isEmpty.value\n})\nconst formattedColor = computed(() => getFormattedColor(props.format))\nconst labelColor = computed(() => {\n  return (props.labelFormat ? getFormattedColor(props.labelFormat) : formattedColor.value)?.toString()\n})\n\nwatch(\n  () => props.visible,\n  value => {\n    currentVisible.value = value\n  }\n)\nwatch(currentVisible, value => {\n  value && updatePopper()\n})\nwatch(\n  () => props.value,\n  value => {\n    parseValue(value)\n    lastValue.value = {\n      ...currentValue.value,\n      a: currentAlpha.value,\n      format: 'hsva'\n    }\n  }\n)\nwatch(\n  () => props.disabled,\n  value => {\n    if (value) {\n      setVisible(false)\n    }\n  }\n)\n\ndefineExpose({\n  idFor,\n  isEmpty,\n  currentVisible,\n  currentValue,\n  currentAlpha,\n  rgb,\n  hex,\n  labelColor,\n  wrapper,\n  reference,\n  popper,\n  toggleVisible,\n  focus,\n  blur\n})\n\nfunction parseValue(value: Color | null) {\n  if (value) {\n    const { r, g, b, a } = parseColorToRgba(value)\n\n    isEmpty.value = false\n    currentValue.value = rgbToHsv(r, g, b)\n    currentAlpha.value = a\n  } else {\n    isEmpty.value = true\n    currentValue.value = getDefaultHsv()\n    currentAlpha.value = 1\n  }\n}\n\nfunction setVisible(visible: boolean) {\n  if (currentVisible.value === visible) return\n\n  currentVisible.value = visible\n\n  emit('update:visible', visible)\n  emitEvent(props.onToggle, visible)\n}\n\nfunction getFormattedColor(format: ColorFormat) {\n  let color: Color\n\n  if (format === 'hex') {\n    const { r, g, b } = rgb.value\n\n    if (props.alpha) {\n      color = rgbaToHex(r, g, b, currentAlpha.value)\n    } else {\n      color = rgbToHex(r, g, b)\n    }\n  } else {\n    switch (format) {\n      case 'rgb': {\n        color = { ...rgb.value } as RGBAColor\n        color.r = Math.round(color.r)\n        color.g = Math.round(color.g)\n        color.b = Math.round(color.b)\n\n        break\n      }\n      case 'hsl': {\n        const { h, s, v } = currentValue.value\n\n        color = hsvToHsl(h, s, v) as HSLAColor\n        color.h = Math.round(color.h)\n        color.s = toFixed(color.s, 3)\n        color.l = toFixed(color.l, 3)\n\n        break\n      }\n      default: {\n        color = { ...currentValue.value } as HSVAColor\n        color.h = Math.round(color.h)\n        color.s = toFixed(color.s, 3)\n        color.v = toFixed(color.v, 3)\n      }\n    }\n\n    color.a = toFixed(currentAlpha.value, 3)\n  }\n\n  return color\n}\n\nfunction handleClickOutside() {\n  if (!editing.value) {\n    emitEvent(props.onClickOutside)\n\n    if (props.outsideClose && currentVisible.value) {\n      setVisible(false)\n      emitEvent(props.onOutsideClose)\n    }\n  }\n}\n\nfunction toggleVisible() {\n  if (props.disabled || readonly.value) return\n\n  setVisible(!currentVisible.value)\n}\n\nfunction handleClear() {\n  if (props.disabled || readonly.value) return\n\n  if (props.clearable) {\n    setVisible(false)\n    emit('update:value', '')\n    emitEvent(props.onChange, '')\n\n    nextTick(() => {\n      parseValue(null)\n      clearField()\n      emitEvent(props.onClear)\n    })\n  }\n}\n\nfunction handleConfirm() {\n  if (props.disabled || readonly.value) return\n\n  lastValue.value = {\n    ...currentValue.value,\n    a: currentAlpha.value,\n    format: 'hsva'\n  }\n  isEmpty.value = false\n  setVisible(false)\n  handleChange()\n}\n\nfunction handleChange() {\n  const color = formattedColor.value\n\n  emit('update:value', color)\n  setFieldValue(color)\n  emitEvent(props.onChange, color)\n  validateField()\n}\n\nfunction handlePaletteChange({ s, v }: HSVColor) {\n  currentValue.value.s = s\n  currentValue.value.v = v\n}\n\nfunction handleHueChange(hue: number) {\n  currentValue.value.h = hue\n}\n\nfunction handleAlphaChange(alpha: number) {\n  currentAlpha.value = alpha\n}\n\nfunction handleInputColor(value: string) {\n  const { r, g, b, a } = parseColorToRgba(value)\n\n  currentValue.value = rgbToHsv(r, g, b)\n  currentAlpha.value = a\n}\n\nfunction handleShortcutClick(color: string) {\n  const { r, g, b, a } = parseColorToRgba(color)\n\n  currentValue.value = rgbToHsv(r, g, b)\n  currentAlpha.value = a\n\n  emitEvent(props.onShortcut, formattedColor.value)\n}\n\nfunction toggleEditing(able: boolean) {\n  if (!able) {\n    setTimeout(() => {\n      editing.value = false\n    }, 0)\n  } else {\n    editing.value = true\n  }\n}\n\nfunction handleTabDown(event: KeyboardEvent) {\n  if (isClient && currentVisible.value) {\n    const activeEl = document && document.activeElement\n\n    if (!activeEl) return\n\n    event.preventDefault()\n\n    const shift = event.shiftKey\n    const elList = Array.from(unitList.value)\n    const index = elList.findIndex(unit => {\n      const el = isElement(unit) ? unit : unit.$el\n\n      return el === activeEl || el.contains(activeEl)\n    })\n\n    let maybeEl: any\n\n    if (!~index) {\n      maybeEl = shift ? getLast(elList) : elList[0]\n    } else if (shift ? !index : index === elList.length - 1) {\n      maybeEl = reference.value\n    } else {\n      maybeEl = elList[index + (shift ? -1 : 1)]\n    }\n\n    if (maybeEl) {\n      if (typeof maybeEl.focus === 'function') {\n        maybeEl.focus()\n      } else {\n        maybeEl.$el?.focus()\n      }\n    }\n  }\n}\n\nfunction handleShortcutsFocus() {\n  shortcutHitting.value = 0\n  shortcutsFocused.value = true\n}\n\nfunction handleShortcutsKeydown(event: KeyboardEvent) {\n  const key = event.code || event.key\n  const shortcutCount = shortcutList.value.length\n\n  switch (key) {\n    case 'ArrowUp':\n    case 'ArrowLeft': {\n      shortcutHitting.value--\n      break\n    }\n    case 'ArrowDown':\n    case 'ArrowRight': {\n      shortcutHitting.value++\n      break\n    }\n    case 'Enter':\n    case 'Space':\n    case ' ': {\n      const color = shortcutList.value[shortcutHitting.value]\n\n      color && handleShortcutClick(color)\n      break\n    }\n  }\n\n  shortcutHitting.value = (shortcutHitting.value + shortcutCount) % shortcutCount\n}\n\nfunction handleSpaceDown(event: KeyboardEvent) {\n  if (props.disabled) {\n    setVisible(false)\n  } else {\n    event.preventDefault()\n\n    if (currentVisible.value) {\n      handleConfirm()\n      reference.value?.focus()\n    } else {\n      setVisible(true)\n    }\n  }\n}\n\nfunction handleEscDown() {\n  setVisible(false)\n  reference.value?.focus()\n}\n\nfunction focus(options?: FocusOptions) {\n  reference.value?.focus(options)\n}\n\nfunction blur() {\n  reference.value?.blur()\n}\n</script>\n\n<template>\n  <div\n    :id=\"idFor\"\n    ref=\"wrapper\"\n    :class=\"className\"\n    role=\"group\"\n    :aria-disabled=\"toAttrValue(props.disabled)\"\n    :aria-expanded=\"toAttrValue(currentVisible)\"\n    aria-haspopup=\"listbox\"\n    :aria-labelledby=\"labelId\"\n    @click=\"toggleVisible\"\n    @keydown.tab.stop=\"handleTabDown\"\n    @keydown.space=\"handleSpaceDown\"\n    @keydown.escape=\"handleEscDown\"\n  >\n    <div ref=\"reference\" :class=\"selectorClass\" tabindex=\"0\">\n      <slot\n        name=\"control\"\n        :color=\"rgb\"\n        :alpha=\"currentAlpha\"\n        :empty=\"isEmpty\"\n      >\n        <div v-if=\"hasPrefix\" :class=\"[nh.be('icon'), nh.be('prefix')]\" :style=\"{ color: props.prefixColor }\">\n          <slot name=\"prefix\">\n            <Icon :icon=\"props.prefix\"></Icon>\n          </slot>\n        </div>\n        <div :class=\"nh.be('control')\">\n          <div :class=\"[nh.be('marker'), showLabel && nh.bem('marker', 'with-label')]\">\n            <Icon v-if=\"!currentVisible && isEmpty\" v-bind=\"icons.close\"></Icon>\n            <div\n              v-else\n              :style=\"{\n                caretColor: 'transparent',\n                width: '100%',\n                height: '100%',\n                backgroundColor: `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${currentVisible ? currentAlpha : lastValue.a})`\n              }\"\n            ></div>\n          </div>\n          <div v-if=\"showLabel\" :class=\"nh.be('label')\">\n            <slot\n              name=\"label\"\n              :color=\"rgb\"\n              :alpha=\"currentAlpha\"\n              :empty=\"isEmpty\"\n              :label=\"labelColor\"\n            >\n              {{ labelColor }}\n            </slot>\n          </div>\n        </div>\n        <div\n          v-if=\"!props.noSuffix\"\n          :class=\"[nh.be('icon'), nh.be('suffix')]\"\n          :style=\"{\n            color: props.suffixColor,\n            opacity: showClear || props.loading ? '0%' : ''\n          }\"\n        >\n          <slot name=\"suffix\">\n            <Icon\n              v-if=\"props.suffix\"\n              :icon=\"props.suffix\"\n              :class=\"{\n                [nh.be('arrow')]: !props.staticSuffix\n              }\"\n            ></Icon>\n            <Icon v-else v-bind=\"icons.angleDown\" :class=\"nh.be('arrow')\"></Icon>\n          </slot>\n        </div>\n        <div\n          v-else-if=\"props.clearable || props.loading\"\n          :class=\"[nh.be('icon'), nh.bem('icon', 'placeholder'), nh.be('suffix')]\"\n        ></div>\n        <Transition :name=\"nh.ns('fade')\" appear>\n          <button\n            v-if=\"showClear\"\n            :class=\"[nh.be('icon'), nh.be('clear')]\"\n            type=\"button\"\n            tabindex=\"-1\"\n            :aria-label=\"locale.ariaLabel.clear\"\n            @click.stop=\"handleClear\"\n          >\n            <Icon v-bind=\"icons.clear\"></Icon>\n          </button>\n          <div v-else-if=\"props.loading\" :class=\"[nh.be('icon'), nh.be('loading')]\">\n            <Icon\n              v-bind=\"icons.loading\"\n              :effect=\"props.loadingEffect || icons.loading.effect\"\n              :icon=\"props.loadingIcon || icons.loading.icon\"\n            ></Icon>\n          </div>\n        </Transition>\n      </slot>\n    </div>\n    <Popper\n      ref=\"popper\"\n      :class=\"[nh.be('popper'), nh.bs('vars')]\"\n      :visible=\"currentVisible\"\n      :to=\"transferTo\"\n      :transition=\"props.transitionName\"\n      :alive=\"props.popperAlive ?? !transferTo\"\n      @click.stop\n      @keydown.tab.stop=\"handleTabDown\"\n      @keydown.space=\"handleSpaceDown\"\n      @keydown.escape=\"handleEscDown\"\n    >\n      <div :class=\"nh.be('panel')\">\n        <div :class=\"nh.be('section')\">\n          <ColorPalette\n            ref=\"palette\"\n            :hue=\"currentValue.h\"\n            :saturation=\"currentValue.s\"\n            :value=\"currentValue.v\"\n            @edit-start=\"toggleEditing(true)\"\n            @edit-end=\"toggleEditing(false)\"\n            @change=\"handlePaletteChange\"\n          ></ColorPalette>\n          <ColorHue\n            ref=\"hue\"\n            :hue=\"currentValue.h\"\n            @edit-start=\"toggleEditing(true)\"\n            @edit-end=\"toggleEditing(false)\"\n            @change=\"handleHueChange\"\n          ></ColorHue>\n          <ColorAlpha\n            v-if=\"props.alpha\"\n            ref=\"alphaEl\"\n            :rgb=\"rgb\"\n            :alpha=\"currentAlpha\"\n            @edit-start=\"toggleEditing(true)\"\n            @edit-end=\"toggleEditing(false)\"\n            @change=\"handleAlphaChange\"\n          ></ColorAlpha>\n          <div\n            v-if=\"props.shortcut\"\n            ref=\"shortcutEl\"\n            :class=\"nh.be('shortcuts')\"\n            tabindex=\"-1\"\n            @focus=\"handleShortcutsFocus\"\n            @blur=\"shortcutsFocused = false\"\n            @keydown=\"handleShortcutsKeydown\"\n          >\n            <div\n              v-for=\"(item, index) in shortcutList\"\n              :key=\"index\"\n              :class=\"{\n                [nh.be('shortcut-item')]: true,\n                [nh.bem('shortcut-item', 'hitting')]:\n                  shortcutsFocused && shortcutHitting === index && shortcutHitting !== 0\n              }\"\n              :style=\"{ backgroundColor: item }\"\n              @click=\"handleShortcutClick(item)\"\n            ></div>\n          </div>\n        </div>\n        <div :class=\"nh.be('action')\">\n          <Input\n            v-if=\"!props.noInput\"\n            ref=\"input\"\n            inherit\n            :class=\"nh.be('input')\"\n            size=\"small\"\n            :value=\"hex.toUpperCase()\"\n            :respond=\"false\"\n            @change=\"handleInputColor\"\n          ></Input>\n          <Button\n            v-if=\"props.clearable\"\n            ref=\"cancel\"\n            inherit\n            text\n            size=\"small\"\n            @click=\"handleClear\"\n          >\n            {{ props.cancelText || locale.cancel }}\n          </Button>\n          <Button\n            ref=\"confirm\"\n            inherit\n            type=\"primary\"\n            size=\"small\"\n            @click=\"handleConfirm\"\n          >\n            {{ props.confirmText || locale.confirm }}\n          </Button>\n        </div>\n      </div>\n    </Popper>\n  </div>\n</template>\n"
    },
    {
      "target": "components/color-picker/index.ts",
      "content": "import ColorPicker from './color-picker.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { ColorPicker }\nexport { colorPickerProps } from './props'\n\nexport type ColorPickerExposed = ComponentPublicInstance & InstanceType<typeof ColorPicker>\n\nexport type { Color } from '@pocui/utils'\nexport type { ColorPickerProps, ColorPickerCProps } from './props'\nexport type { ColorFormat } from './symbol'\n"
    },
    {
      "target": "components/color-picker/props.ts",
      "content": "import {\n  booleanProp,\n  booleanStringProp,\n  buildProps,\n  eventProp,\n  iconProp,\n  localeProp,\n  sizeProp,\n  stateProp\n} from '@pocui/config'\n\nimport type { IconEffect } from '@/components/icon'\nimport type { ConfigurableProps } from '@pocui/config'\nimport type { Placement } from '@pocui/hooks'\nimport type { Color, HSLAColor, HSVAColor, RGBAColor } from '@pocui/utils'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { ColorFormat } from './symbol'\n\ntype FormattedColor = string | RGBAColor | HSLAColor | HSVAColor\n\nexport const colorPickerProps = buildProps({\n  size: sizeProp,\n  state: stateProp,\n  locale: localeProp('colorPicker'),\n  value: [String, Object] as PropType<Color | null>,\n  visible: booleanProp,\n  format: String as PropType<ColorFormat>,\n  alpha: booleanProp,\n  disabled: booleanProp,\n  transitionName: String,\n  noInput: booleanProp,\n  shortcut: {\n    type: [Boolean, Array] as PropType<boolean | string[]>,\n    default: null\n  },\n  placement: String as PropType<Placement>,\n  transfer: booleanStringProp,\n  outsideClose: booleanProp,\n  clearable: booleanProp,\n  cancelText: String,\n  confirmText: String,\n  prefix: iconProp,\n  prefixColor: String,\n  suffix: iconProp,\n  suffixColor: String,\n  noSuffix: booleanProp,\n  staticSuffix: booleanProp,\n  loading: booleanProp,\n  loadingIcon: iconProp,\n  loadingLock: booleanProp,\n  loadingEffect: String as PropType<IconEffect>,\n  popperAlive: booleanProp,\n  showLabel: booleanProp,\n  labelFormat: String as PropType<ColorFormat>,\n  onToggle: eventProp<(visible: boolean) => void>(),\n  onClickOutside: eventProp(),\n  onOutsideClose: eventProp(),\n  onClear: eventProp(),\n  onChange: eventProp<(color: FormattedColor) => void>(),\n  onShortcut: eventProp<(color: FormattedColor) => void>()\n})\n\nexport type ColorPickerProps = ExtractPropTypes<typeof colorPickerProps>\nexport type ColorPickerCProps = ConfigurableProps<ColorPickerProps>\n"
    },
    {
      "target": "components/color-picker/symbol.ts",
      "content": "import { rgbToHsv } from '@pocui/utils'\n\nexport type ColorFormat = 'rgb' | 'hsl' | 'hsv' | 'hex'\n\nexport const defaultShortcuts = Object.freeze([\n  '#2d8cf0',\n  '#19be6b',\n  '#ff9900',\n  '#ed4014',\n  '#00b5ff',\n  '#19c919',\n  '#f9e31c',\n  '#ea1a1a',\n  '#9b1dea',\n  '#00c2b1',\n  '#ac7a33',\n  '#1d35ea',\n  '#8bc34a',\n  '#f16b62',\n  '#ea4ca3',\n  '#0d94aa',\n  '#febd79',\n  '#5d4037',\n  '#00bcd4',\n  '#f06292',\n  '#cddc39',\n  '#607d8b',\n  '#000000',\n  '#ffffff'\n])\n\nexport const getDefaultHsv = () => rgbToHsv(0, 0, 0)\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/hooks", "@pocui/utils"],
  "registryDependencies": ["color-picker.scss", "button", "form", "icon", "input", "popper"],
  "categories": ["form"],
  "meta": { "isReferenceOnly": false }
}
