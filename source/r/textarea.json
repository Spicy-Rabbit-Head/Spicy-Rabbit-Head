{
  "name": "textarea",
  "type": "registry:component",
  "description": "通过键入内容输入数据，常用于内容较多、需要多行显示的场合。",
  "files": [
    {
      "target": "components/textarea/index.ts",
      "content": "import Textarea from './textarea.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Textarea }\nexport { textareaProps } from './props'\n\nexport type TextareaExposed = ComponentPublicInstance & InstanceType<typeof Textarea>\n\nexport type { TextareaProps, TextareaCProps } from './props'\n"
    },
    {
      "target": "components/textarea/props.ts",
      "content": "import {\n  booleanProp,\n  buildProps,\n  classProp,\n  eventProp,\n  iconProp,\n  localeProp,\n  stateProp\n} from '@pocui/config'\n\nimport type { IconEffect } from '@/components/icon'\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\n\nexport const textareaProps = buildProps({\n  state: stateProp,\n  locale: localeProp('input'),\n  value: String,\n  placeholder: String,\n  rows: Number,\n  noResize: booleanProp,\n  autofocus: booleanProp,\n  spellcheck: booleanProp,\n  autocomplete: booleanProp,\n  readonly: booleanProp,\n  disabled: booleanProp,\n  debounce: booleanProp,\n  delay: Number,\n  maxLength: Number,\n  loading: booleanProp,\n  loadingIcon: iconProp,\n  loadingLock: booleanProp,\n  loadingEffect: String as PropType<IconEffect>,\n  sync: booleanProp,\n  controlClass: classProp,\n  controlAttrs: Object as PropType<Record<string, any>>,\n  name: String,\n  onFocus: eventProp<(event: FocusEvent) => void>(),\n  onBlur: eventProp<(event: FocusEvent) => void>(),\n  onInput: eventProp<(value: string) => void>(),\n  onChange: eventProp<(value: string) => void>(),\n  onEnter: eventProp(),\n  onKeyDown: eventProp<(event: KeyboardEvent) => void>(),\n  onKeyPress: eventProp<(event: KeyboardEvent) => void>(),\n  onKeyUp: eventProp<(event: KeyboardEvent) => void>(),\n  onCompositionStart: eventProp<(event: CompositionEvent) => void>(),\n  onCompositionEnd: eventProp<(event: CompositionEvent) => void>()\n})\n\nexport type TextareaProps = ExtractPropTypes<typeof textareaProps>\nexport type TextareaCProps = ConfigurableProps<TextareaProps>\n"
    },
    {
      "target": "components/textarea/textarea.vue",
      "content": "<script setup lang=\"ts\">\nimport { useFieldStore } from '@/components/form'\nimport { Icon } from '@/components/icon'\n\nimport { computed, ref, toRef, watch } from 'vue'\n\nimport {\n  createIconProp,\n  createStateProp,\n  emitEvent,\n  useIcons,\n  useLocale,\n  useNameHelper,\n  useProps\n} from '@pocui/config'\nimport { debounce, isNullish, throttle, toNumber } from '@pocui/utils'\n\nimport { textareaProps } from './props'\n\ndefineOptions({ name: 'Textarea',\n  description:'通过键入内容输入数据，常用于内容较多、需要多行显示的场合。',\n  categories: ['form'] })\n\nconst { idFor, state, disabled, loading, validateField, getFieldValue, setFieldValue } = useFieldStore<string>(() =>\n  textarea.value?.focus()\n)\n\nconst _props = defineProps(textareaProps)\nconst props = useProps('textarea', _props, {\n  state: createStateProp(state),\n  locale: null,\n  value: {\n    default: () => getFieldValue(),\n    static: true\n  },\n  placeholder: null,\n  rows: 2,\n  noResize: false,\n  autofocus: false,\n  spellcheck: false,\n  autocomplete: false,\n  readonly: false,\n  disabled: () => disabled.value,\n  debounce: false,\n  delay: null,\n  maxLength: 0,\n  loading: () => loading.value,\n  loadingIcon: createIconProp(),\n  loadingLock: false,\n  loadingEffect: null,\n  sync: false,\n  controlClass: null,\n  controlAttrs: null,\n  name: {\n    default: '',\n    static: true\n  }\n})\n\nconst emit = defineEmits(['update:value'])\ndefineSlots<{\n  count(props: { value: string }): any\n}>()\nconst nh = useNameHelper('textarea')\nconst locale = useLocale('input', toRef(props, 'locale'))\nconst icons = useIcons()\n\nconst focused = ref(false)\nconst currentValue = ref(props.value)\nconst currentLength = ref(props.value ? props.value.length : 0)\nconst composing = ref(false)\n\nconst textarea = ref<HTMLTextAreaElement>()\n\nlet lastValue = props.value\n\nconst isReadonly = computed(() => {\n  return (props.loading && props.loadingLock) || props.readonly\n})\nconst className = computed(() => {\n  return {\n    [nh.b()]: true,\n    [nh.ns('input-vars')]: true,\n    [nh.bs('vars')]: true,\n    [nh.in()]: props.inherit,\n    [nh.bm('focused')]: focused.value,\n    [nh.bm('disabled')]: props.disabled,\n    [nh.bm('readonly')]: isReadonly.value,\n    [nh.bm('loading')]: props.loading,\n    [nh.bm('no-resize')]: props.noResize,\n    [nh.bm(props.state)]: props.state !== 'default'\n  }\n})\n\nwatch(\n  () => props.value,\n  value => {\n    currentValue.value = value\n    lastValue = value\n    limitValueLength()\n  }\n)\n\ndefineExpose({\n  idFor,\n  currentValue,\n  currentLength,\n  composing,\n  isReadonly,\n  textarea,\n  copyValue,\n  focus: (options?: FocusOptions) => textarea.value?.focus(options),\n  blur: () => textarea.value?.blur()\n})\n\nfunction handleFocus(event: FocusEvent) {\n  focused.value = true\n  emitEvent(props.onFocus, event)\n}\n\nfunction handleBlur(event: FocusEvent) {\n  focused.value = false\n  emitEvent(props.onBlur, event)\n}\n\nfunction handleChange(event: Event) {\n  const type = event.type as 'change' | 'input'\n\n  if (composing.value) {\n    if (type === 'input') return\n\n    composing.value = false\n  }\n\n  currentValue.value = (event.target as HTMLTextAreaElement).value\n  limitValueLength()\n\n  if (type === 'change') {\n    if (lastValue === currentValue.value) return\n\n    lastValue = currentValue.value\n\n    if (!props.sync) {\n      emit('update:value', currentValue.value)\n      setFieldValue(currentValue.value)\n    }\n\n    emitEvent(props.onChange, currentValue.value)\n\n    if (!props.sync) {\n      validateField()\n    }\n  } else {\n    if (props.sync) {\n      emit('update:value', currentValue.value)\n      setFieldValue(currentValue.value)\n    }\n\n    emitEvent(props.onInput, currentValue.value)\n\n    if (props.sync) {\n      validateField()\n    }\n  }\n}\n\nfunction handleEnter() {\n  emitEvent(props.onEnter)\n}\n\nfunction handleKeyDown(event: KeyboardEvent) {\n  emitEvent(props.onKeyDown, event)\n}\n\nfunction handleKeyPress(event: KeyboardEvent) {\n  emitEvent(props.onKeyPress, event)\n}\n\nfunction handleKeyUp(event: KeyboardEvent) {\n  emitEvent(props.onKeyUp, event)\n}\n\nfunction limitValueLength() {\n  let value = currentValue.value\n\n  if (isNullish(value)) {\n    currentLength.value = 0\n\n    return\n  }\n\n  const maxLength = props.maxLength\n\n  if (maxLength && value.length > maxLength) {\n    value = value.slice(0, maxLength)\n  }\n\n  currentLength.value = value.length\n  currentValue.value = value\n}\n\nfunction copyValue() {\n  const textarea = document.createElement('textarea')\n\n  textarea.style.height = '0'\n  textarea.setAttribute('readonly', 'readonly')\n  textarea.value = currentValue.value\n  document.body.appendChild(textarea)\n  textarea.select()\n\n  const isSuccess = document.execCommand('copy')\n\n  document.body.removeChild(textarea)\n\n  return isSuccess\n}\n\nconst delay = toNumber(props.delay)\nconst handleInput = props.debounce ? debounce(handleChange, delay || 100) : throttle(handleChange, delay || 16)\n\nfunction handleCompositionStart(event: CompositionEvent) {\n  composing.value = true\n  emitEvent(props.onCompositionStart, event)\n}\n\nfunction handleCompositionEnd(event: CompositionEvent) {\n  if (composing.value) {\n    composing.value = false\n\n    if (textarea.value) {\n      textarea.value.dispatchEvent(new Event('input'))\n    }\n  }\n\n  emitEvent(props.onCompositionStart, event)\n}\n</script>\n\n<template>\n  <div :id=\"idFor\" :class=\"className\" @click=\"textarea?.focus()\">\n    <textarea\n      v-bind=\"props.controlAttrs\"\n      ref=\"textarea\"\n      :class=\"[nh.be('control'), props.controlAttrs?.class, props.controlClass]\"\n      :value=\"currentValue\"\n      :rows=\"props.rows\"\n      :autofocus=\"props.autofocus\"\n      :autocomplete=\"props.autocomplete ? 'on' : 'off'\"\n      :spellcheck=\"props.spellcheck\"\n      :disabled=\"props.disabled\"\n      :readonly=\"isReadonly\"\n      :placeholder=\"props.placeholder ?? locale.placeholder\"\n      :maxlength=\"props.maxLength > 0 ? props.maxLength : undefined\"\n      :name=\"props.name || props.controlAttrs?.name\"\n      @blur=\"handleBlur\"\n      @focus=\"handleFocus\"\n      @keyup.enter=\"handleEnter\"\n      @keyup=\"handleKeyUp\"\n      @keypress=\"handleKeyPress\"\n      @keydown=\"handleKeyDown\"\n      @input=\"handleInput\"\n      @change=\"handleChange\"\n      @compositionstart=\"handleCompositionStart\"\n      @compositionend=\"handleCompositionEnd\"\n    ></textarea>\n    <div :class=\"nh.be('extra')\">\n      <Transition :name=\"nh.ns('fade')\" appear>\n        <div v-if=\"props.loading\" :class=\"nh.be('loading')\">\n          <Icon\n            v-bind=\"icons.loading\"\n            :effect=\"props.loadingEffect || icons.loading.effect\"\n            :icon=\"props.loadingIcon || icons.loading.icon\"\n            label=\"loading\"\n          ></Icon>\n        </div>\n      </Transition>\n      <div v-if=\"props.maxLength > 0\" :class=\"nh.be('count')\">\n        <slot name=\"count\" :value=\"currentValue\">\n          {{ props.maxLength === Infinity ? currentLength : `${currentLength}/${props.maxLength}` }}\n        </slot>\n      </div>\n    </div>\n  </div>\n</template>\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/utils"],
  "registryDependencies": ["textarea.scss", "icon", "form"],
  "categories": ["form"],
  "meta": { "isReferenceOnly": false }
}
