{
  "name": "wheel",
  "type": "registry:component",
  "description": "我将它用在了 TimePicker 上，不知道还有没有其他用途。",
  "files": [
    {
      "target": "components/wheel/index.ts",
      "content": "import Wheel from './wheel.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Wheel }\nexport { wheelProps } from './props'\n\nexport type WheelExposed = ComponentPublicInstance & InstanceType<typeof Wheel>\n\nexport type { WheelProps, WheelCProps } from './props'\nexport type { WheelRawOption } from './symbol'\n"
    },
    {
      "target": "components/wheel/props.ts",
      "content": "import { booleanProp, booleanStringProp, buildProps, eventProp, stateProp } from '@pocui/config'\n\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { WheelRawOption } from './symbol'\n\nexport const wheelProps = buildProps({\n  state: stateProp,\n  horizontal: booleanProp,\n  value: [String, Number],\n  /**\n   * 上下或左右两侧的候选数\n   */\n  candidate: Number as PropType<0 | 1 | 2 | 3>,\n  arrow: booleanProp,\n  pointer: booleanProp,\n  options: Array as PropType<WheelRawOption[]>,\n  insertEmpty: booleanStringProp,\n  disabled: booleanProp,\n  loading: booleanProp,\n  loadingLock: booleanProp,\n  disabledItem: Function as PropType<(value: string | number, data: WheelRawOption) => boolean>,\n  noTransition: booleanProp,\n  onChange: eventProp<(value: string | number, data: WheelRawOption) => void>(),\n  onPrev: eventProp<(value: string | number, data: WheelRawOption) => void>(),\n  onNext: eventProp<(value: string | number, data: WheelRawOption) => void>(),\n  onItemClick: eventProp<(value: string | number, data: WheelRawOption) => void>()\n})\n\nexport type WheelProps = ExtractPropTypes<typeof wheelProps>\nexport type WheelCProps = ConfigurableProps<WheelProps>\n"
    },
    {
      "target": "components/wheel/symbol.ts",
      "content": "import type { InjectionKey } from 'vue'\n\nexport type WheelRawOption =\n  | string\n  | number\n  | {\n    value: string | number,\n    label?: string,\n    disabled?: boolean\n  }\n\nexport interface WheelOption {\n  value: string | number,\n  label: string,\n  disabled: boolean,\n  meta: WheelRawOption\n}\n\nexport interface ItemState {\n  width: number,\n  height: number,\n  el?: HTMLElement | null,\n  value: number | string,\n  disabled: boolean,\n  meta: any\n}\n\nexport interface WheelState {\n  increaseItem(item: ItemState): void,\n  decreaseItem(item: ItemState): void\n}\n\nexport const WHEEL_STATE: InjectionKey<WheelState> = Symbol('WHEEL_STATE')\n"
    },
    {
      "target": "components/wheel/wheel-item.vue",
      "content": "<script setup lang=\"ts\">\nimport { computed, inject, onBeforeUnmount, onMounted, reactive, ref, toRef } from 'vue'\n\nimport { useNameHelper } from '@pocui/config'\nimport { WHEEL_STATE } from './symbol'\n\ndefineOptions({ name: 'WheelItem',description:'轮盘项组件，作为轮盘选择器的单个选项。', categories: ['other']})\n\nconst props = defineProps({\n  value: {\n    type: [Number, String],\n    default: null\n  },\n  disabled: {\n    type: Boolean,\n    default: false\n  },\n  active: {\n    type: Boolean,\n    default: false\n  },\n  meta: {\n    type: [String, Number, Object],\n    default: null\n  }\n})\n\nconst nh = useNameHelper('wheel')\n\nconst wheelState = inject(WHEEL_STATE, null)\n\nconst width = ref(0)\nconst height = ref(0)\n\nconst wrapper = ref<HTMLElement>()\n\nconst state = reactive({\n  width,\n  height,\n  el: wrapper,\n  value: toRef(props, 'value'),\n  disabled: toRef(props, 'disabled'),\n  meta: toRef(props, 'meta')\n})\n\nconst style = computed(() => {\n  return {\n    width: width.value ? `${width.value}px` : undefined,\n    height: height.value ? `${height.value}px` : undefined\n  }\n})\n\nif (wheelState) {\n  onMounted(() => {\n    wheelState.increaseItem(state)\n  })\n\n  onBeforeUnmount(() => {\n    wheelState.decreaseItem(state)\n  })\n}\n\ndefineExpose({ wrapper })\n</script>\n\n<template>\n  <li\n    ref=\"wrapper\"\n    :class=\"[nh.be('item'), disabled && nh.bem('item', 'disabled'), active && nh.bem('item', 'active')]\"\n    role=\"option\"\n    :aria-disabled=\"disabled ? 'true' : undefined\"\n    :aria-selected=\"active\"\n    :style=\"style\"\n  >\n    <slot>\n      {{ value }}\n    </slot>\n  </li>\n</template>\n"
    },
    {
      "target": "components/wheel/wheel.vue",
      "content": "<script setup lang=\"ts\">\nimport { useFieldStore } from '@/components/form'\nimport { Icon } from '@/components/icon/'\nimport { Scroll } from '@/components/scroll'\n\nimport { computed, nextTick, provide, ref, watch } from 'vue'\n\nimport { createStateProp, emitEvent, useIcons, useNameHelper, useProps } from '@pocui/config'\nimport { useDisplay, useModifier } from '@pocui/hooks'\nimport { USE_TOUCH, boundRange, debounce, debounceMinor, isString, toFalse } from '@pocui/utils'\n\nimport { wheelProps } from './props'\n\nimport { WHEEL_STATE } from './symbol'\n\nimport WheelItem from './wheel-item.vue'\n\nimport type { ItemState, WheelOption, WheelRawOption } from './symbol'\n\ndefineOptions({ name: 'Wheel',description:'我将它用在了 TimePicker 上，不知道还有没有其他用途。', categories: ['other'] })\n\nconst { idFor, labelId, state, disabled, loading, validateField, getFieldValue, setFieldValue } = useFieldStore<\n  string | number\n>(() => wrapper.value?.focus())\n\nconst _props = defineProps(wheelProps)\nconst props = useProps('wheel', _props, {\n  state: createStateProp(state),\n  horizontal: false,\n  value: {\n    default: () => getFieldValue(),\n    static: true\n  },\n  candidate: {\n    default: 2,\n    validator: value => [0, 1, 2, 3].includes(value)\n  },\n  arrow: false,\n  pointer: USE_TOUCH,\n  options: {\n    default: () => [],\n    static: true\n  },\n  insertEmpty: false,\n  disabled: () => disabled.value,\n  loading: () => loading.value,\n  loadingLock: false,\n  disabledItem: {\n    default: toFalse,\n    isFunc: true\n  },\n  noTransition: false\n})\n\nconst emit = defineEmits(['update:value'])\n\ndefineSlots<{\n  default(props: { option: WheelOption, index: number }): any\n}>()\n\nconst nh = useNameHelper('wheel')\nconst icons = useIcons()\n\nconst items = ref(new Set<ItemState>())\nconst currentActive = ref(0)\nconst wrapperWidth = ref(0)\nconst wrapperHeight = ref(0)\nconst targetWidth = ref(0)\nconst targetHeight = ref(0)\nconst horizontalPadding = ref(0)\nconst verticalPadding = ref(0)\nconst isInit = ref(false)\n\nconst wrapper = useDisplay(displayInit)\nconst scroll = ref<InstanceType<typeof Scroll>>()\n\nuseModifier({\n  target: wrapper,\n  passive: false,\n  onKeyDown: (event, modifier) => {\n    if (modifier.up || modifier.down) {\n      event.preventDefault()\n      modifier.up ? handlePrev() : handleNext()\n    }\n  }\n})\n\nconst normalizedOptions = computed<WheelOption[]>(() => {\n  const options = props.options.map(option => {\n    if (typeof option === 'object') {\n      const { value, label, disabled = false } = option\n\n      return {\n        value,\n        label: label || String(value),\n        disabled,\n        meta: option\n      }\n    }\n\n    return {\n      value: option,\n      label: String(option),\n      disabled: false,\n      meta: option\n    }\n  })\n\n  if (props.insertEmpty) {\n    options.unshift({\n      value: '',\n      label: isString(props.insertEmpty) ? props.insertEmpty : '-',\n      disabled: false,\n      meta: ''\n    })\n  }\n\n  return options\n})\nconst itemList = computed(() => {\n  return Array.from(items.value)\n})\nconst readonly = computed(() => props.loading && props.loadingLock)\nconst className = computed(() => {\n  return [\n    nh.b(),\n    nh.bs('vars'),\n    nh.bm(props.horizontal ? 'horizontal' : 'vertical'),\n    {\n      [nh.in()]: props.inherit,\n      [nh.bm(props.state)]: props.state !== 'default',\n      [nh.bm('disabled')]: props.disabled,\n      [nh.bm('readonly')]: readonly.value,\n      [nh.bm('loading')]: props.loading\n    }\n  ]\n})\nconst listStyle = computed(() => {\n  if (props.horizontal) {\n    return {\n      paddingRight: `${horizontalPadding.value}px`,\n      paddingLeft: `${horizontalPadding.value}px`\n    }\n  }\n\n  return {\n    paddingTop: `${verticalPadding.value}px`,\n    paddingBottom: `${verticalPadding.value}px`\n  }\n})\nconst maskStyle = computed(() => {\n  if (props.horizontal) {\n    return {\n      width: horizontalPadding.value ? `${horizontalPadding.value}px` : undefined\n    }\n  }\n\n  return {\n    height: verticalPadding.value ? `${verticalPadding.value}px` : undefined\n  }\n})\nconst borderStyle = computed(() => {\n  const style: Record<string, string> = {\n    inset: props.horizontal ? `0 ${horizontalPadding.value - 1}px` : `${verticalPadding.value - 1}px 0`\n  }\n\n  if (props.horizontal) {\n    style.borderTop = '0'\n    style.borderBottom = '0'\n  } else {\n    style.borderRight = '0'\n    style.borderLeft = '0'\n  }\n\n  return style\n})\nconst prevDisabled = computed(() => {\n  return props.disabled || !itemList.value.slice(0, currentActive.value).some(item => !isItemDisabled(item))\n})\nconst nextDisabled = computed(() => {\n  return (\n    props.disabled ||\n    currentActive.value >= itemList.value.length - 1 ||\n    !itemList.value.slice(currentActive.value + 1, itemList.value.length).some(item => !isItemDisabled(item))\n  )\n})\nconst prevIcon = computed(() => (props.horizontal ? icons.value.angleLeft : icons.value.angleUp))\nconst nextIcon = computed(() => (props.horizontal ? icons.value.angleRight : icons.value.angleDown))\n\nprovide(WHEEL_STATE, {\n  increaseItem,\n  decreaseItem\n})\n\nconst updateActive = debounceMinor(() => {\n  const active = Math.max(\n    itemList.value.findIndex(item => item.value === props.value),\n    0\n  )\n\n  setActive(findEnabledActive(active))\n})\n\nconst computeSize = debounceMinor(() => {\n  nextTick(() => {\n    const horizontal = props.horizontal\n\n    itemList.value.forEach(item => {\n      if (item && item.el) {\n        targetWidth.value = Math.max(targetWidth.value, item.el.offsetWidth)\n        targetHeight.value = Math.max(targetHeight.value, item.el.offsetHeight)\n      }\n    })\n\n    const candidate = props.candidate\n    const showCount = 2 * candidate + 1\n\n    wrapperWidth.value = showCount * targetWidth.value\n    wrapperHeight.value = showCount * targetHeight.value\n\n    horizontalPadding.value = candidate * targetWidth.value\n    verticalPadding.value = candidate * targetHeight.value\n\n    items.value.forEach(item => {\n      if (horizontal) {\n        item.width = targetWidth.value\n      } else {\n        item.height = targetHeight.value\n      }\n    })\n\n    setTimeout(() => {\n      scroll.value?.refresh()\n    }, 0)\n  })\n})\n\nconst refreshScroll = debounce(() => {\n  if (scroll.value) {\n    let targetXScroll = 0\n    let targetYScroll = 0\n\n    if (props.horizontal) {\n      targetXScroll = currentActive.value * targetWidth.value\n    } else {\n      targetYScroll = currentActive.value * targetHeight.value\n    }\n\n    nextTick(() => {\n      scroll.value?.scrollTo(targetXScroll, targetYScroll)\n    })\n  }\n}, 20)\n\nwatch(\n  () => props.value,\n  () => {\n    updateActive()\n    refreshScroll()\n  },\n  { immediate: true }\n)\nwatch(() => props.horizontal, computeSize)\nwatch(() => props.candidate, computeSize)\n\ndefineExpose({\n  idFor,\n  currentActive,\n  isInit,\n  targetWidth,\n  targetHeight,\n  wrapperWidth,\n  wrapperHeight,\n  itemList,\n  wrapper,\n  scroll,\n  refreshScroll,\n  focus: (options?: FocusOptions) => wrapper.value?.focus(options),\n  blur: () => wrapper.value?.blur()\n})\n\nfunction isItemDisabled(item: ItemState) {\n  return item.disabled || props.disabledItem(item.value, item.meta)\n}\n\nfunction setActive(active: number) {\n  if (currentActive.value === active) return\n\n  currentActive.value = active\n\n  const item = itemList.value[active]\n  const value = item?.value\n\n  refreshScroll()\n  emit('update:value', value)\n  setFieldValue(value)\n  emitEvent(props.onChange, value, item?.meta)\n  validateField()\n}\n\nfunction queryEnabledActive(active: number, step: number) {\n  step = step / Math.abs(step)\n\n  while (itemList.value[active].disabled) {\n    active += step\n\n    if (active < 0 || active >= itemList.value.length) break\n  }\n\n  return active\n}\n\nfunction findEnabledActive(active: number, sign = 1) {\n  if (itemList.value[active] && isItemDisabled(itemList.value[active])) {\n    active = queryEnabledActive(active, 1 * sign)\n\n    if (sign > 0 ? active >= itemList.value.length : active < 0) {\n      active = queryEnabledActive(boundRange(active, 0, itemList.value.length - 1), -1 * sign)\n\n      // 全禁用\n      if (sign > 0 ? active < 0 : active >= itemList.value.length) active = 0\n    }\n  }\n\n  return active\n}\n\nfunction increaseItem(item: ItemState) {\n  items.value.add(item)\n  computeSize()\n  updateActive()\n}\n\nfunction decreaseItem(item: ItemState) {\n  items.value.delete(item)\n  computeSize()\n  updateActive()\n}\n\nfunction displayInit() {\n  computeSize()\n  scroll.value?.refresh()\n\n  nextTick(() => {\n    isInit.value = true\n\n    updateActive()\n    refreshScroll()\n  })\n}\n\nfunction beforeScroll({ signX, signY }: { signX: number, signY: number }) {\n  if (props.disabled || readonly.value) return false\n\n  const sign = props.horizontal ? signX : signY\n\n  return !((sign < 0 && prevDisabled.value) || (sign > 0 && nextDisabled.value))\n}\n\nfunction handleScrollEnd({ clientX, clientY }: { clientX: number, clientY: number }) {\n  const aboutActive = props.horizontal ? clientX / targetWidth.value : clientY / targetHeight.value\n  const active = Math.round(aboutActive)\n\n  if (active !== currentActive.value) {\n    setActive(findEnabledActive(active, active > aboutActive ? 1 : -1))\n  } else {\n    refreshScroll()\n  }\n}\n\nfunction handleWheel({ sign, clientX, clientY }: { clientX: number, clientY: number, sign: 1 | -1 }) {\n  const active = props.horizontal ? Math.round(clientX / targetWidth.value) : Math.round(clientY / targetHeight.value)\n\n  setActive(findEnabledActive(active, sign))\n}\n\nfunction handlePrev() {\n  if (!prevDisabled.value) {\n    setActive(findEnabledActive(currentActive.value - 1, -1))\n\n    const item = itemList.value[currentActive.value]\n\n    emitEvent(props.onPrev, item?.value, item?.meta)\n  }\n}\n\nfunction handleNext() {\n  if (!nextDisabled.value) {\n    setActive(findEnabledActive(currentActive.value + 1, 1))\n\n    const item = itemList.value[currentActive.value]\n\n    emitEvent(props.onNext, item?.value, item?.meta)\n  }\n}\n\nfunction handleItemClick(value: string | number, data: WheelRawOption) {\n  emitEvent(props.onItemClick, value, data)\n}\n</script>\n\n<template>\n  <div\n    :id=\"idFor\"\n    ref=\"wrapper\"\n    :class=\"className\"\n    tabindex=\"0\"\n    role=\"group\"\n    :aria-labelledby=\"labelId\"\n  >\n    <div\n      v-if=\"props.arrow\"\n      ref=\"prevArrow\"\n      :class=\"[nh.be('arrow'), nh.bem('arrow', 'prev'), prevDisabled ? nh.bem('arrow', 'disabled') : '']\"\n      aria-hidden=\"true\"\n      @click=\"handlePrev\"\n    >\n      <Icon v-bind=\"prevIcon\"></Icon>\n    </div>\n    <div :class=\"nh.be('scroll')\" role=\"none\">\n      <Scroll\n        ref=\"scroll\"\n        inherit\n        :scroll-x=\"props.horizontal ? targetWidth * currentActive : 0\"\n        :scroll-y=\"props.horizontal ? 0 : targetHeight * currentActive\"\n        :width=\"props.horizontal ? wrapperWidth : '100%'\"\n        :height=\"props.horizontal ? '100%' : wrapperHeight\"\n        :pointer=\"props.pointer\"\n        :mode=\"props.horizontal ? 'horizontal' : 'vertical'\"\n        :delta-x=\"targetWidth\"\n        :delta-y=\"targetHeight\"\n        :on-before-scroll=\"beforeScroll\"\n        :no-transition=\"props.noTransition\"\n        @wheel=\"handleWheel\"\n        @scroll-end=\"handleScrollEnd\"\n      >\n        <ul ref=\"list\" :class=\"nh.be('list')\" :style=\"listStyle\">\n          <template v-if=\"isInit\">\n            <WheelItem\n              v-for=\"(option, index) in normalizedOptions\"\n              :key=\"index\"\n              :value=\"option.value\"\n              :disabled=\"option.disabled || props.disabledItem(option.value, option)\"\n              :active=\"currentActive === index\"\n              :meta=\"option.meta\"\n              @click=\"handleItemClick(option.value, option.meta)\"\n            >\n              <slot :option=\"option\" :index=\"index\">\n                {{ option.label }}\n              </slot>\n            </WheelItem>\n          </template>\n        </ul>\n      </Scroll>\n      <template v-if=\"props.candidate\">\n        <div :class=\"[nh.be('mask'), nh.bem('mask', 'top')]\" :style=\"maskStyle\"></div>\n        <div :class=\"[nh.be('mask'), nh.bem('mask', 'bottom')]\" :style=\"maskStyle\"></div>\n      </template>\n      <div\n        :class=\"{\n          [nh.be('border')]: true,\n          [nh.bem('border', 'active')]: props.loading,\n          [nh.bem('border', 'vertical')]: props.horizontal\n        }\"\n        :style=\"borderStyle\"\n      ></div>\n    </div>\n    <div\n      v-if=\"props.arrow\"\n      ref=\"nextArrow\"\n      :class=\"[nh.be('arrow'), nh.bem('arrow', 'next'), nextDisabled ? nh.bem('arrow', 'disabled') : '']\"\n      aria-hidden=\"true\"\n      @click=\"handleNext\"\n    >\n      <Icon v-bind=\"nextIcon\"></Icon>\n    </div>\n  </div>\n</template>\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/hooks", "@pocui/utils"],
  "registryDependencies": ["wheel.scss", "form", "icon", "scroll"],
  "categories": ["other"],
  "meta": { "isReferenceOnly": false }
}
