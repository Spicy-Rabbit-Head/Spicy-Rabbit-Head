{
  "name": "toast",
  "type": "registry:components",
  "description": "提示框组件，用于显示短暂的反馈信息。",
  "files": [
    {
      "target": "components/toast/index.ts",
      "content": "import { createApp, createVNode, markRaw, render } from 'vue'\n\nimport { proxyExposed, unrefElement } from '@pocui/hooks'\n\nimport { destroyObject, isClient, isNullish, noop, toNumber } from '@pocui/utils'\n\nimport Component from './toast.vue'\n\nimport type { MaybeInstance } from '@pocui/hooks'\n\nimport type { App, MaybeRef } from 'vue'\n\nimport type { ToastInstance, ToastOptions, ToastType } from './symbol'\n\nexport { toastProps } from './props'\n\nexport type { ToastProps, ToastCProps } from './props'\nexport type { ToastType, ToastOptions }\n\ntype FuzzyOptions = string | ToastOptions\n\ninterface AipMethod {\n  (options: ToastOptions): () => void,\n\n  (content: string, duration?: number): () => void,\n\n  (options: FuzzyOptions, duration?: number): () => void\n}\n\nconst conveniences: Record<ToastType, Record<string, any>> = {\n  success: {},\n  warning: {},\n  error: {},\n  loading: {\n    showMask: true\n  }\n}\n\nexport class ToastManager {\n  name: string\n\n  defaults: Record<string, unknown>\n\n  open: AipMethod\n\n  success: AipMethod\n\n  warning: AipMethod\n\n  error: AipMethod\n\n  loading: AipMethod\n\n  private _mountedApp: App<unknown> | null\n\n  private _instance: ToastInstance | null\n\n  private _innerApp: App<unknown> | null\n\n  private _container: HTMLElement | null\n\n  private _timer: ReturnType<typeof setTimeout> | null\n\n  private _wrapper: HTMLElement | SVGElement | null\n\n  private _mountedEl: HTMLElement | null\n\n  constructor(options: Partial<ToastOptions> = {}) {\n    options = {\n      ...options,\n      duration: options.duration ? toNumber(options.duration) : 2000\n    }\n\n    this._mountedApp = null\n    this._instance = null\n    this._innerApp = null\n    this._container = null\n    this._timer = null\n    this._wrapper = null\n    this._mountedEl = null\n    this.name = 'Toast'\n    this.defaults = {}\n\n    this.config(options)\n\n    this.open = (content: FuzzyOptions, duration?: number) => {\n      return this._open(null, content, duration)\n    }\n\n    this.success = (content: FuzzyOptions, duration?: number) => {\n      return this._open('success', content, duration)\n    }\n\n    this.warning = (content: FuzzyOptions, duration?: number) => {\n      return this._open('warning', content, duration)\n    }\n\n    this.error = (content: FuzzyOptions, duration?: number) => {\n      return this._open('error', content, duration)\n    }\n\n    this.loading = (content: FuzzyOptions, duration?: number) => {\n      return this._open('loading', content, duration)\n    }\n  }\n\n  close() {\n    this._timer && clearTimeout(this._timer)\n    this._getInstance()?.closeToast()\n  }\n\n  config(options: Record<string, unknown>) {\n    this.defaults = { ...this.defaults, ...options }\n  }\n\n  clone() {\n    const manager = new ToastManager(this.defaults)\n\n    manager._mountedApp = this._mountedApp\n\n    return manager\n  }\n\n  destroy() {\n    this._mountedEl && this._wrapper?.removeChild(this._mountedEl)\n    this._innerApp?.unmount()\n    this._container && render(null, this._container)\n    destroyObject(this)\n  }\n\n  isDestroyed() {\n    return false\n  }\n\n  install(app: App, options: Partial<ToastOptions> & { property?: string } = {}) {\n    const { property, ...others } = options\n\n    this.config(others)\n    this._mountedApp = app\n\n    if (property || !app.config.globalProperties.$toast) {\n      app.config.globalProperties[property || '$toast'] = this\n    }\n  }\n\n  transferTo(target: MaybeRef<string | MaybeInstance>) {\n    if (!isClient) return\n\n    const el = unrefElement(target)\n\n    if (el) {\n      this._wrapper = el as HTMLElement | SVGElement | null\n\n      if (this._instance) {\n        this._mountedEl && !isNullish(this._wrapper) && this._wrapper.appendChild(this._mountedEl)\n      } else {\n        this._getInstance()\n      }\n    }\n  }\n\n  private _getInstance() {\n    if (!this._instance && isClient) {\n      if (!this._mountedApp) {\n        console.warn('[pocui:Toast]: 应用程序缺失,插件可能未安装.')\n\n        this._container = document.createElement('div')\n        this._innerApp = createApp(Component)\n        this._instance = this._innerApp.mount(this._container) as ToastInstance\n      } else {\n        const vnode = createVNode(Component, null, null)\n\n        this._container = document.createElement('div')\n        vnode.appContext = this._mountedApp._context\n\n        render(vnode, this._container)\n\n        this._instance = proxyExposed<ToastInstance>(vnode)\n      }\n\n      this._mountedEl = this._container.firstElementChild as HTMLElement\n      ;(this._wrapper || document.body).appendChild(this._mountedEl)\n    }\n\n    return this._instance\n  }\n\n  private _open(type: null | ToastType, content: FuzzyOptions, _duration?: number) {\n    if (!isClient) {\n      return noop\n    }\n\n    this._timer && clearTimeout(this._timer)\n\n    const options =\n      typeof content === 'string'\n        ? {\n            content,\n            duration: _duration\n          }\n        : content\n    const convenienceOptions = type ? (conveniences[type] ?? {}) : {}\n\n    const userCloseFn = options.onClose\n    const onClose = () => {\n      this._timer && clearTimeout(this._timer)\n\n      if (typeof userCloseFn === 'function') {\n        return userCloseFn()\n      }\n    }\n\n    const toast = this._getInstance()!\n    const item: ToastOptions = {\n      ...this.defaults,\n      ...convenienceOptions,\n      ...options,\n      type,\n      onClose\n    }\n\n    if (item.icon && typeof item.icon !== 'function' && typeof item.icon !== 'string') {\n      item.icon = markRaw(item.icon)\n    }\n\n    toast.openToast(item)\n\n    const duration = typeof item.duration === 'number' ? item.duration : 2000\n\n    if (duration >= 500) {\n      this._timer = setTimeout(() => {\n        toast.closeToast()\n      }, duration)\n    }\n\n    return () => {\n      this._timer && clearTimeout(this._timer)\n      toast.closeToast()\n    }\n  }\n}\n\nexport const Toast = new ToastManager()\n"
    },
    {
      "target": "components/toast/props.ts",
      "content": "import { booleanProp, buildProps, classProp, iconProp, styleProp } from '@pocui/config'\n\nimport type { IconMinorProps } from '@/components/icon'\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { ToastOptions, ToastPosition } from './symbol'\n\nexport const toastProps = buildProps({\n  bodyWidth: Number,\n  icon: iconProp,\n  iconProps: Object as PropType<IconMinorProps>,\n  position: String as PropType<ToastPosition>,\n  transitionName: String,\n  closable: booleanProp,\n  maskClose: booleanProp,\n  showMask: booleanProp,\n  maskClass: classProp,\n  maskStyle: styleProp,\n  parseHtml: booleanProp,\n  renderer: Function as PropType<(options: ToastOptions) => any>\n})\n\nexport type ToastProps = ExtractPropTypes<typeof toastProps>\nexport type ToastCProps = ConfigurableProps<ToastProps, 'renderer'>\n"
    },
    {
      "target": "components/toast/symbol.ts",
      "content": "import type { IconMinorProps } from '@/components/icon'\nimport type { ClassType, StyleType } from '@pocui/config'\nimport type { ComponentPublicInstance } from 'vue'\n\nexport type ToastType = 'success' | 'warning' | 'error' | 'loading'\nexport type ToastPosition = 'top' | 'center' | 'bottom'\n\nexport interface ToastOptions extends Record<string, any> {\n  type?: ToastType | null,\n\n  content?: string,\n\n  icon?: Record<string, any> | (() => any) | string | null,\n\n  iconProps?: IconMinorProps,\n\n  position?: ToastPosition,\n\n  transitionName?: string,\n\n  closable?: boolean,\n\n  maskClose?: boolean,\n\n  showMask?: boolean,\n\n  maskClass?: ClassType,\n\n  maskStyle?: StyleType,\n\n  parseHtml?: boolean,\n\n  onClose?: () => void\n}\n\nexport interface ToastInstance extends ComponentPublicInstance {\n  openToast: (options: ToastOptions) => Promise<void>,\n\n  closeToast: () => void\n}\n\nexport const effectiveTypes = Object.freeze(['success', 'warning', 'error', 'loading'])\n"
    },
    {
      "target": "components/toast/toast.vue",
      "content": "<script setup lang=\"ts\">\nimport { Icon } from '@/components/icon'\nimport { Renderer } from '@/components/renderer'\n\nimport { computed, nextTick, onMounted, reactive } from 'vue'\n\nimport { createIconProp, useIcons, useNameHelper, useProps, useZIndex } from '@pocui/config'\nimport { isFunction } from '@pocui/utils'\n\nimport { toastProps } from './props'\n\nimport { effectiveTypes } from './symbol'\n\nimport type { ToastOptions, ToastType } from './symbol'\n\ndefineOptions({ name: 'Toast' ,\n  description:'提示框组件，用于显示短暂的反馈信息。',\n  categories: ['feedback'] })\n\nconst nh = useNameHelper('toast')\n\nconst _props = defineProps(toastProps)\nconst props = useProps('toast', _props, {\n  bodyWidth: 100,\n  icon: createIconProp(),\n  iconProps: () => ({}),\n  position: 'center',\n  transitionName: () => nh.ns('ease'),\n  closable: false,\n  maskClose: false,\n  showMask: false,\n  maskClass: null,\n  maskStyle: null,\n  renderer: {\n    default: null,\n    isFunc: true,\n    static: true\n  },\n  parseHtml: false\n})\n\nconst getIndex = useZIndex()\nconst icons = useIcons()\n\nconst predefinedIcons = computed(() => ({\n  success: icons.value.success,\n  warning: icons.value.warning,\n  error: icons.value.error,\n  loading: icons.value.loading\n}))\n\nconst state = reactive({\n  visible: false,\n  zIndex: 0,\n  type: null as ToastType | null,\n  content: '',\n  icon: props.icon,\n  iconProps: props.iconProps as any,\n  position: props.position,\n  transition: props.transitionName,\n  closable: props.closable,\n  maskClose: props.maskClose,\n  showMask: props.showMask,\n  maskClass: props.maskClass as any,\n  maskStyle: props.maskStyle as any,\n  parseHtml: props.parseHtml,\n  textOnly: false,\n  renderer: props.renderer,\n  onClose: null as (() => void) | null\n})\n\nconst mountedPromise = new Promise<void>(resolve => {\n  onMounted(() => {\n    nextTick(resolve)\n  })\n})\n\ndefineExpose({\n  state,\n  openToast,\n  closeToast,\n  handleReset\n})\n\nasync function openToast(options: ToastOptions) {\n  await mountedPromise\n\n  state.zIndex = getIndex()\n  state.type = options.type ?? null\n  state.content = options.content ?? ''\n  state.icon = options.icon ?? props.icon\n  state.iconProps = options.iconProps ?? props.iconProps\n  state.position = options.position ?? props.position\n  state.transition = options.transitionName ?? props.transitionName\n  state.closable = options.closable ?? props.closable\n  state.maskClose = options.maskClose ?? props.maskClose\n  state.showMask = options.showMask ?? props.showMask\n  state.maskClass = options.maskClass ?? props.maskClass\n  state.maskStyle = options.maskStyle ?? props.maskStyle\n  state.parseHtml = options.parseHtml ?? props.parseHtml\n  state.renderer = isFunction(options.renderer) ? options.renderer : props.renderer\n  state.onClose = options.onClose || null\n\n  state.textOnly = !state.icon && !(state.type && effectiveTypes.includes(state.type))\n\n  if (isFunction(state.renderer)) {\n    const render = state.renderer\n\n    state.renderer = () => render(options)\n    state.textOnly = false\n  }\n\n  state.visible = true\n}\n\nfunction closeToast() {\n  state.visible = false\n\n  if (isFunction(state.onClose)) {\n    state.onClose()\n  }\n}\n\nfunction handleReset() {\n  if (state.visible) return\n\n  state.type = null\n  state.content = ''\n  state.icon = props.icon\n  state.iconProps = props.iconProps\n  state.position = props.position\n  state.transition = props.transitionName\n  state.closable = props.closable\n  state.maskClose = props.maskClose\n  state.showMask = props.showMask\n  state.maskClass = props.maskClass\n  state.maskStyle = props.maskStyle\n  state.parseHtml = props.parseHtml\n  state.textOnly = false\n  state.renderer = props.renderer\n  state.onClose = null\n}\n\nfunction handleWrapperClick() {\n  if (state.visible && state.closable) {\n    closeToast()\n  }\n}\n\nfunction handleMaskClick() {\n  if (state.visible && state.maskClose) {\n    closeToast()\n  }\n}\n</script>\n\n<template>\n  <div\n    :class=\"{\n      [nh.b()]: true,\n      [nh.bs('vars')]: true,\n      [nh.bm('text-only')]: state.textOnly\n    }\"\n    role=\"alert\"\n    :style=\"{\n      zIndex: state.zIndex\n    }\"\n    aria-atomic=\"true\"\n    aria-live=\"assertive\"\n  >\n    <Transition :name=\"nh.ns('fade')\">\n      <div\n        v-if=\"state.showMask && state.visible\"\n        :class=\"[nh.be('mask'), state.maskClass]\"\n        :style=\"state.maskStyle\"\n        @click=\"handleMaskClick\"\n        @wheel.stop.prevent\n      ></div>\n    </Transition>\n    <Transition :name=\"state.transition\">\n      <div\n        v-if=\"state.visible\"\n        :class=\"{\n          [nh.be('wrapper')]: true,\n          [nh.bem('wrapper', state.position)]: state.position !== 'center',\n          [nh.bem('wrapper', 'closable')]: state.closable\n        }\"\n        @click=\"handleWrapperClick\"\n        @wheel.stop.prevent\n      >\n        <Renderer v-if=\"isFunction(state.renderer)\" :renderer=\"state.renderer\"></Renderer>\n        <template v-else>\n          <div v-if=\"state.icon || (state.type && effectiveTypes.includes(state.type))\" :class=\"nh.be('icon')\">\n            <Icon\n              v-if=\"state.icon\"\n              :icon=\"state.icon\"\n              :scale=\"1.8\"\n              v-bind=\"state.iconProps\"\n            ></Icon>\n            <Icon v-else v-bind=\"{ ...predefinedIcons[state.type!], scale: 1.8, ...state.iconProps }\"></Icon>\n          </div>\n          <div v-if=\"state.parseHtml\" :class=\"nh.be('content')\" v-html=\"state.content\"></div>\n          <div v-else :class=\"nh.be('content')\">\n            {{ state.content }}\n          </div>\n        </template>\n      </div>\n    </Transition>\n  </div>\n</template>\n"
    }
  ],
  "dependencies": ["vue", "@pocui/hooks", "@pocui/utils", "@pocui/config"],
  "registryDependencies": ["toast.scss", "icon", "renderer"],
  "categories": ["feedback"],
  "meta": { "isReferenceOnly": false }
}
