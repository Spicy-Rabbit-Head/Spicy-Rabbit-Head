{
  "name": "scroll",
  "type": "registry:component",
  "description": "用于需要展示超出一个区域范围的内容，可以使用户滚动浏览。",
  "files": [
    {
      "target": "components/scroll/hooks.ts",
      "content": "import { computed, nextTick, onMounted, reactive, ref, watch } from 'vue'\n\nimport { useManualRef } from '@pocui/hooks'\nimport { multipleFixed, toNumber } from '@pocui/utils'\n\nimport type { Ref } from 'vue'\nimport type { ScrollMode } from './symbol'\n\nexport function useScrollWrapper({\n  mode,\n  disabled,\n  width,\n  height,\n  scrollX,\n  scrollY,\n  onResize,\n  onBeforeRefresh,\n  onAfterRefresh\n}: {\n  mode: Ref<Exclude<ScrollMode, 'horizontal-exact'>>,\n  disabled: Ref<boolean>,\n  width: Ref<number | string>,\n  height: Ref<number | string>,\n  scrollX: Ref<number>,\n  scrollY: Ref<number>,\n  onResize?: (entry: ResizeObserverEntry) => void,\n  onBeforeRefresh?: () => void,\n  onAfterRefresh?: () => void\n}) {\n  const { manualRef, triggerUpdate } = useManualRef()\n\n  const wrapperEl = ref<HTMLElement>()\n  const contentEl = ref<HTMLElement>()\n\n  // 容器长宽\n  const wrapper = reactive({\n    el: wrapperEl,\n    width: toNumber(width.value),\n    height: toNumber(height.value)\n  })\n\n  // 内容长宽\n  const content = reactive({\n    el: contentEl,\n    width: 0,\n    height: 0\n  })\n\n  const x = manualRef(-scrollX.value)\n  const y = manualRef(-scrollY.value)\n\n  const isReady = ref(false)\n\n  const percentX = manualRef(0)\n  const percentY = manualRef(0)\n\n  const xScrollLimit = computed(() => {\n    return wrapper.width ? wrapper.width - content.width : 0\n  })\n  const yScrollLimit = computed(() => {\n    return wrapper.height ? wrapper.height - content.height : 0\n  })\n  const enableXScroll = computed(() => {\n    return !disabled.value && mode.value !== 'vertical' && !!wrapper.width && content.width - wrapper.width > 1\n  })\n  const enableYScroll = computed(() => {\n    return !disabled.value && mode.value !== 'horizontal' && !!wrapper.height && content.height - wrapper.height > 1\n  })\n  const xBarLength = computed(() => {\n    if (wrapper.width) {\n      return Math.max(Math.min((wrapper.width / (content.width || 1)) * 100, 99), 5)\n    }\n\n    return 35\n  })\n  const yBarLength = computed(() => {\n    if (wrapper.height) {\n      return Math.max(Math.min((wrapper.height / (content.height || 1)) * 100, 99), 5)\n    }\n\n    return 35\n  })\n\n  watch(wrapperEl, () => {\n    refreshWrapper()\n  })\n  watch(contentEl, () => {\n    computeContentSize()\n  })\n  watch(scrollX, value => {\n    x.value = -value\n    verifyScroll()\n  })\n  watch(scrollY, value => {\n    y.value = -value\n    verifyScroll()\n  })\n  watch(width, () => {\n    refreshWrapper().then(verifyScroll)\n  })\n  watch(height, () => {\n    refreshWrapper().then(verifyScroll)\n  })\n\n  function computeWrapperSize(sizeType: 'width' | 'height') {\n    return nextTick(() => {\n      if (!wrapper.el) return\n\n      const size = sizeType === 'width' ? width.value : height.value\n      const titleCaseSizeType = sizeType.slice(0, 1).toUpperCase() + sizeType.slice(1)\n\n      // 获取 wrapper 的 px 大小\n      if (typeof size === 'string') {\n        if (!size.endsWith('px') && (!size || Number.isNaN(Number(size)))) {\n          wrapper[sizeType] = wrapper.el[`offset${titleCaseSizeType}` as 'offsetWidth' | 'offsetHeight']\n        } else {\n          wrapper[sizeType] = parseInt(size)\n        }\n      } else {\n        wrapper[sizeType] = size\n      }\n    })\n  }\n\n  async function refreshWrapper() {\n    const promises: Promise<void>[] = []\n\n    if (mode.value !== 'vertical') {\n      promises.push(computeWrapperSize('width'))\n    }\n\n    if (mode.value !== 'horizontal') {\n      promises.push(computeWrapperSize('height'))\n    }\n\n    await Promise.all(promises)\n  }\n\n  let timer: ReturnType<typeof setTimeout>\n\n  function computeContentSize() {\n    clearTimeout(timer)\n\n    return new Promise<void>(resolve => {\n      isReady.value = false\n\n      timer = setTimeout(() => {\n        if (!content.el) {\n          resolve()\n          return\n        }\n\n        if (mode.value !== 'vertical') {\n          content.width = content.el.offsetWidth\n\n          if (wrapper.width >= content.width) {\n            x.value = 0\n          } else {\n            if (x.value === 0) {\n              x.value = -scrollX.value\n            }\n          }\n        }\n\n        if (mode.value !== 'horizontal') {\n          content.height = content.el.offsetHeight\n\n          if (wrapper.height >= content.height) {\n            y.value = 0\n          } else {\n            if (y.value === 0) {\n              y.value = -scrollY.value\n            }\n          }\n        }\n\n        setTimeout(() => {\n          isReady.value = true\n          verifyScroll()\n          resolve()\n        }, 1)\n      }, 0)\n    })\n  }\n\n  /**\n   * 将对百分比滚动值进行后期处理。\n   */\n  function verifyScroll() {\n    if (!isReady.value) {\n      return\n    }\n\n    if (mode.value !== 'vertical') {\n      x.value = Math.min(0, Math.max(x.value, xScrollLimit.value))\n\n      if (mode.value !== 'both') {\n        y.value = 0\n      }\n    }\n\n    if (mode.value !== 'horizontal') {\n      y.value = Math.min(0, Math.max(y.value, yScrollLimit.value))\n\n      if (mode.value !== 'both') {\n        x.value = 0\n      }\n    }\n\n    computePercent()\n    triggerUpdate()\n  }\n\n  function computePercent() {\n    percentX.value = multipleFixed(x.value / (xScrollLimit.value || -1), 100, 2)\n    percentY.value = multipleFixed(y.value / (yScrollLimit.value || -1), 100, 2)\n\n    percentX.value = Math.max(0, Math.min(percentX.value, 100))\n    percentY.value = Math.max(0, Math.min(percentY.value, 100))\n  }\n\n  function handleResize(entity: ResizeObserverEntry) {\n    refresh()\n    onResize?.(entity)\n  }\n\n  let isMounted = false\n\n  onMounted(() => {\n    refresh()\n    isMounted = true\n  })\n\n  async function refresh() {\n    if (typeof onBeforeRefresh === 'function') {\n      onBeforeRefresh()\n    }\n\n    refreshWrapper()\n    await computeContentSize().then(() => {\n      setTimeout(\n        () => {\n          verifyScroll()\n\n          if (typeof onAfterRefresh === 'function') {\n            onAfterRefresh()\n          }\n        },\n        isMounted ? 20 : 100\n      )\n    })\n  }\n\n  return {\n    wrapperEl,\n    contentEl,\n\n    wrapper,\n    content,\n    isReady,\n    x,\n    y,\n    percentX,\n    percentY,\n    xScrollLimit,\n    yScrollLimit,\n    enableXScroll,\n    enableYScroll,\n    xBarLength,\n    yBarLength,\n\n    handleResize,\n    verifyScroll,\n    computePercent,\n    refresh,\n    triggerUpdate\n  }\n}\n"
    },
    {
      "target": "components/scroll/index.ts",
      "content": "import Scroll from './scroll.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Scroll }\nexport { scrollProps } from './props'\n\nexport type ScrollExposed = ComponentPublicInstance & InstanceType<typeof Scroll>\n\nexport type { ScrollProps, ScrollCProps } from './props'\nexport type { ScrollMode, ScrollPayload, BarScrollPayload, ScrollState, ScrollSlotParams } from './symbol'\n"
    },
    {
      "target": "components/scroll/props.ts",
      "content": "import {\n  booleanNumberProp,\n  booleanProp,\n  buildProps,\n  classProp,\n  eventProp,\n  styleProp\n} from '@pocui/config'\n\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { BarScrollPayload, ScrollMode, ScrollPayload } from './symbol'\n\nexport const scrollProps = buildProps({\n  scrollClass: classProp,\n  scrollStyle: styleProp,\n  scrollAttrs: Object as PropType<Record<string, any>>,\n  mode: String as PropType<ScrollMode>,\n  width: [Number, String],\n  height: [Number, String],\n  deltaX: Number,\n  deltaY: Number,\n  disabled: booleanProp,\n  pointer: booleanProp,\n  wheel: booleanProp,\n  scrollX: Number,\n  scrollY: Number,\n  useXBar: booleanProp,\n  useYBar: booleanProp,\n  barFade: Number,\n  barClass: classProp,\n  autoplay: booleanNumberProp,\n  playWaiting: Number,\n  noBuffer: booleanProp,\n  noTransition: booleanProp,\n  onBeforeScroll: Function as PropType<(payload: { signX: number, signY: number }) => boolean>,\n  useBarTrack: booleanProp,\n  scrollTag: String,\n  onResize: eventProp<(entry: ResizeObserverEntry) => void>(),\n  onXEnabledChange: eventProp<(enabled: boolean) => void>(),\n  onYEnabledChange: eventProp<(enabled: boolean) => void>(),\n  onWheel: eventProp<(payload: BarScrollPayload & { sign: 1 | -1 }) => void>(),\n  onScrollStart: eventProp<(payload: Omit<ScrollPayload, 'type'>) => void>(),\n  onScroll: eventProp<(payload: ScrollPayload) => void>(),\n  onScrollEnd: eventProp<(payload: Omit<ScrollPayload, 'type'>) => void>(),\n  onBarScrollStart: eventProp<(payload: BarScrollPayload) => void>(),\n  onBarScroll: eventProp<(payload: BarScrollPayload) => void>(),\n  onBarScrollEnd: eventProp<(payload: BarScrollPayload) => void>(),\n  onReady: eventProp()\n})\n\nexport type ScrollProps = ExtractPropTypes<typeof scrollProps>\nexport type ScrollCProps = ConfigurableProps<ScrollProps, 'scrollX' | 'scrollY', 'onBeforeScroll'>\n"
    },
    {
      "target": "components/scroll/scroll.vue",
      "content": "<script setup lang=\"ts\">\nimport { ResizeObserver } from '@/components/resize-observer'\n\nimport { Scrollbar } from '@/components/scrollbar'\n\nimport { computed, nextTick, onBeforeUnmount, onMounted, ref, shallowReadonly, toRef, watch, watchEffect } from 'vue'\n\nimport { emitEvent, useNameHelper, useProps } from '@pocui/config'\nimport { useSetTimeout } from '@pocui/hooks'\n\nimport { USE_TOUCH, createEventEmitter, isClient, isElement, isTrue } from '@pocui/utils'\n\nimport { useScrollWrapper } from './hooks'\nimport { scrollProps } from './props'\n\nimport { MOVE_EVENT, UP_EVENT, scrollModes } from './symbol'\n\nimport type { ScrollMode, ScrollSlotParams } from './symbol'\n\nimport type { EventHandler } from '@pocui/utils'\n\nimport type { ScrollbarExposed } from '@/components/scrollbar'\n\ndefineOptions({ name: 'Scroll' ,\n  description:'用于需要展示超出一个区域范围的内容，可以使用户滚动浏览。',\n  categories: ['other']})\n\nconst _props = defineProps(scrollProps)\nconst props = useProps('scroll', _props, {\n  scrollClass: null,\n  scrollStyle: null,\n  scrollAttrs: null,\n  mode: {\n    default: 'vertical',\n    validator: value => scrollModes.includes(value)\n  },\n  width: '',\n  height: '',\n  deltaX: 40,\n  deltaY: 40,\n  disabled: false,\n  pointer: USE_TOUCH,\n  wheel: true,\n  scrollX: {\n    default: 0,\n    static: true\n  },\n  scrollY: {\n    default: 0,\n    static: true\n  },\n  useXBar: false,\n  useYBar: false,\n  barFade: 1500,\n  barClass: null,\n  autoplay: false,\n  playWaiting: 500,\n  noBuffer: false,\n  noTransition: false,\n  onBeforeScroll: {\n    default: null,\n    isFunc: true\n  },\n  useBarTrack: false,\n  scrollTag: 'div'\n})\n\ndefineSlots<{\n  default(props: ScrollSlotParams): any,\n  extra(props: ScrollSlotParams): any\n}>()\n\nconst emitter = createEventEmitter()\n\nconst nh = useNameHelper('scroll')\nconst { timer } = useSetTimeout()\n\nconst usingBar = ref(false)\nconst scrolling = ref(false)\nconst transitionDuration = ref<number>(0)\nconst mode = computed(() => (props.mode === 'horizontal-exact' ? 'horizontal' : props.mode))\n\nlet waitDelay = 180\n\nconst xBar = ref<ScrollbarExposed>()\nconst yBar = ref<ScrollbarExposed>()\n\nlet initialized = false\n\nconst {\n  wrapperEl,\n  contentEl,\n\n  wrapper,\n  isReady,\n  x,\n  y,\n  percentX,\n  percentY,\n  xScrollLimit,\n  yScrollLimit,\n  enableXScroll,\n  enableYScroll,\n  xBarLength,\n  yBarLength,\n\n  handleResize,\n  verifyScroll,\n  computePercent,\n  refresh,\n  triggerUpdate\n} = useScrollWrapper({\n  mode,\n  disabled: toRef(props, 'disabled'),\n  width: toRef(props, 'width'),\n  height: toRef(props, 'height'),\n  scrollX: toRef(props, 'scrollX'),\n  scrollY: toRef(props, 'scrollY'),\n  onResize: entry => {\n    emitEvent(props.onResize, entry)\n  },\n  onAfterRefresh: () => {\n    syncBarScroll()\n\n    if (!initialized) {\n      initialized = true\n      startAutoplay()\n    }\n  }\n})\n\nconst slotParams = shallowReadonly({\n  getState,\n  refresh,\n  scrollTo,\n  scrollBy,\n  scrollToElement,\n  ensureInView\n})\n\n// 自动播放\nconst canPlay = ref(false)\n\nconst canAutoplay = computed(() => {\n  return (\n    mode.value !== 'both' &&\n    (isTrue(props.autoplay) || +props.autoplay > 1000) &&\n    ((mode.value === 'horizontal' && enableXScroll.value) || (mode.value === 'vertical' && enableYScroll.value))\n  )\n})\n\nwatch([() => props.autoplay, () => props.playWaiting], () => {\n  stopAutoplay()\n  nextTick(startAutoplay)\n})\n\nfunction startAutoplay() {\n  if (!canAutoplay.value) return\n\n  stopAutoplay()\n\n  const distance = mode.value === 'horizontal' ? 'width' : 'height'\n  const limit = mode.value === 'horizontal' ? xScrollLimit : yScrollLimit\n  const prop = mode.value === 'horizontal' ? x : y\n  const waiting = props.playWaiting < 20 ? 20 : props.playWaiting\n\n  let playSpeed = 0.5\n\n  if (typeof props.autoplay === 'number') {\n    playSpeed = (wrapper[distance] / props.autoplay) * 16\n  }\n\n  const precessScroll = () => {\n    computePercent()\n    triggerUpdate()\n    syncBarScroll()\n    emitScrollEvent(mode.value)\n  }\n  const scroll = () => {\n    prop.value -= playSpeed\n\n    if (prop.value <= limit.value) {\n      prop.value = limit.value\n      canPlay.value = false\n\n      precessScroll()\n\n      timer.end = setTimeout(() => {\n        scrollTo(0, 0, 500)\n\n        timer.start = setTimeout(() => {\n          canPlay.value = true\n\n          emitScrollEvent(mode.value)\n          scroll()\n        }, 500 + waiting)\n      }, waiting)\n    } else {\n      precessScroll()\n\n      if (canPlay.value) {\n        requestAnimationFrame(scroll)\n      }\n    }\n  }\n\n  timer.play = setTimeout(() => {\n    canPlay.value = true\n    scroll()\n  }, waiting)\n}\n\nfunction stopAutoplay() {\n  canPlay.value = false\n\n  clearTimeout(timer.play)\n  clearTimeout(timer.start)\n  clearTimeout(timer.end)\n}\n\nconst className = computed(() => {\n  return [\n    nh.b(),\n    nh.bs('vars'),\n    nh.bm(mode.value),\n    {\n      [nh.inc()]: props.inherit,\n      [nh.bm('using-bar')]: usingBar.value,\n      [nh.bm('scrolling')]: scrolling.value,\n      [nh.bm('no-ready')]: !isReady.value,\n      [nh.bm('no-transition')]: props.noTransition\n    }\n  ]\n})\nconst style = computed(() => {\n  const { width, height } = props\n\n  return {\n    width: width\n      ? typeof width === 'string'\n        ? Number.isNaN(Number(width))\n          ? width\n          : `${Number(width)}px`\n        : `${width}px`\n      : undefined,\n    height: height\n      ? typeof height === 'string'\n        ? Number.isNaN(Number(height))\n          ? height\n          : `${Number(height)}px`\n        : `${height}px`\n      : undefined\n  }\n})\nconst wrapperClass = computed(() => {\n  return [props.scrollAttrs?.class, props.scrollClass, nh.be('wrapper')]\n})\nconst wrapperStyle = computed(() => {\n  return [props.scrollAttrs?.style, props.scrollStyle]\n})\n\nwatch(enableXScroll, value => {\n  emitEvent(props.onXEnabledChange, value)\n})\nwatch(enableYScroll, value => {\n  emitEvent(props.onYEnabledChange, value)\n})\nwatch(isReady, value => {\n  if (value) {\n    transitionDuration.value = -1\n    emitEvent(props.onReady)\n  } else {\n    transitionDuration.value = 0\n  }\n})\nwatchEffect(() => {\n  if (!contentEl.value) return\n\n  contentEl.value.style.transform = `translate3d(${x.value}px, ${y.value}px, 0)`\n})\nwatchEffect(() => {\n  if (!contentEl.value) return\n\n  contentEl.value.style.transitionDuration = transitionDuration.value < 0 ? '' : `${transitionDuration.value}ms`\n})\n\nonMounted(() => {\n  if (!isClient || !wrapperEl.value) return\n\n  const style = getComputedStyle(wrapperEl.value)\n  const duration = style.getPropertyValue(nh.cv('move-duration')).trim()\n\n  if (duration.endsWith('ms')) {\n    waitDelay = parseFloat(duration)\n  } else if (duration.endsWith('s')) {\n    waitDelay = parseFloat(duration) * 1000\n  }\n\n  waitDelay = Number.isNaN(waitDelay) ? 140 : waitDelay\n})\n\nonBeforeUnmount(stopAutoplay)\n\ndefineExpose({\n  percentX,\n  percentY,\n  x,\n  y,\n  isReady,\n\n  xBarLength,\n  yBarLength,\n  enableXScroll,\n  enableYScroll,\n\n  wrapper: wrapperEl,\n  content: contentEl,\n  xBar,\n  yBar,\n\n  refresh,\n  scrollTo,\n  scrollBy,\n  scrollToElement,\n  ensureInView,\n  getXScrollLimit,\n  getYScrollLimit,\n  addScrollListener,\n  removeScrollListener\n})\n\nfunction getCommonPayload() {\n  return {\n    clientX: -x.value,\n    clientY: -y.value,\n    percentX: percentX.value,\n    percentY: percentY.value\n  }\n}\n\nfunction syncBarScroll() {\n  xBar.value?.handleScroll(percentX.value)\n  yBar.value?.handleScroll(percentY.value)\n}\n\nfunction handleMouseDown(event: MouseEvent) {\n  if (!props.pointer || event.button > 0 || USE_TOUCH) {\n    return false\n  }\n\n  handlePointerDown(event)\n}\n\nfunction handleTouchStart(event: TouchEvent) {\n  if (!props.pointer || event.touches.length !== 1) {\n    return false\n  }\n\n  handlePointerDown(event)\n}\n\n// 记录滚动开始位置\nlet xScrollStartAt = 0\nlet yScrollStartAt = 0\n\n// 记录滚动开始鼠标位置\nlet cursorXPosition = 0\nlet cursorYPosition = 0\n\nlet moved = false\nlet target: EventTarget | null = null\nlet lastDate = 0\n\nfunction handlePointerDown(event: MouseEvent | TouchEvent) {\n  if (!enableXScroll.value && !enableYScroll.value) {\n    return false\n  }\n\n  if (event.cancelable) {\n    event.preventDefault()\n  }\n\n  prepareScroll()\n\n  transitionDuration.value = 0\n\n  const pointer = 'touches' in event ? event.touches[0] : event\n\n  xScrollStartAt = x.value\n  yScrollStartAt = y.value\n  cursorXPosition = pointer.clientX\n  cursorYPosition = pointer.clientY\n\n  moved = false\n  target = event.target\n  lastDate = Date.now()\n\n  document.addEventListener(MOVE_EVENT, handlePointerMove)\n  document.addEventListener(UP_EVENT, handlePointerUp)\n\n  emitEvent(props.onScrollStart, getCommonPayload())\n}\n\nfunction handlePointerMove(event: MouseEvent | TouchEvent) {\n  event.stopPropagation()\n\n  if (!USE_TOUCH) {\n    event.preventDefault()\n  }\n\n  const pointer = 'touches' in event ? event.touches[0] : event\n  const signX = pointer.clientX - cursorXPosition > 0 ? 1 : -1\n  const signY = pointer.clientY - cursorYPosition > 0 ? 1 : -1\n\n  if (\n    props.onBeforeScroll?.({\n      signX,\n      signY\n    }) === false\n  ) {\n    return false\n  }\n\n  scrolling.value = true\n\n  if (enableXScroll.value) {\n    x.value = xScrollStartAt + pointer.clientX - cursorXPosition\n    moved = true\n  }\n\n  if (enableYScroll.value) {\n    y.value = yScrollStartAt + pointer.clientY - cursorYPosition\n    moved = true\n  }\n\n  if (props.noBuffer) {\n    verifyScroll()\n  } else {\n    computePercent()\n    triggerUpdate()\n  }\n\n  syncBarScroll()\n  emitScrollEvent(mode.value)\n}\n\nfunction handlePointerUp(event: MouseEvent | TouchEvent) {\n  if (!moved && target && event.target === target && Date.now() - lastDate <= 500) {\n    target.dispatchEvent(new MouseEvent('click', event))\n  }\n\n  document.removeEventListener(MOVE_EVENT, handlePointerMove)\n  document.removeEventListener(UP_EVENT, handlePointerUp)\n\n  transitionDuration.value = -1\n  moved = false\n\n  handleBuffer()\n  verifyScroll()\n  syncBarScroll()\n  emitEvent(props.onScrollEnd, getCommonPayload())\n  startAutoplay()\n}\n\n// 按下 shift 时为横向滚动，保持和原生操作一致\nfunction handleWheel(event: WheelEvent, type: 'vertical' | 'horizontal') {\n  const isVerticalScroll = enableYScroll.value && type === 'vertical'\n  const isHorizontalScroll = enableXScroll.value && type === 'horizontal'\n\n  // 纵横滚动均使用 deltaY 标记\n  const sign = event.deltaY > 0 ? -1 : 1\n\n  if (\n    props.wheel &&\n    (isVerticalScroll || isHorizontalScroll) &&\n    props.onBeforeScroll?.({\n      signX: -sign,\n      signY: -sign\n    }) !== false\n  ) {\n    event.preventDefault()\n    event.stopPropagation()\n  } else {\n    return true\n  }\n\n  if (mode.value !== 'both' && mode.value !== type) return false\n\n  prepareScroll()\n\n  const computedDelta = sign * (type === 'horizontal' ? props.deltaX : props.deltaY)\n\n  if (isVerticalScroll) {\n    y.value += computedDelta\n  } else if (isHorizontalScroll) {\n    x.value += computedDelta\n  }\n\n  verifyScroll()\n  syncBarScroll()\n  emitScrollEvent(type)\n\n  emitEvent(props.onWheel, {\n    ...getCommonPayload(),\n    type,\n    sign: -sign as 1 | -1\n  })\n\n  startAutoplay()\n}\n\nfunction prepareScroll() {\n  stopAutoplay()\n  clearTimeout(timer.buffer)\n}\n\nfunction handleBuffer() {\n  if (props.noBuffer) {\n    timer.buffer = setTimeout(() => {\n      scrolling.value = false\n    }, 300)\n  } else {\n    scrolling.value = false\n  }\n}\n\nfunction handleBarScrollStart(type: 'vertical' | 'horizontal') {\n  usingBar.value = true\n  emitEvent(props.onBarScrollStart, {\n    ...getCommonPayload(),\n    type\n  })\n}\n\nfunction handleBarScrollEnd(type: 'vertical' | 'horizontal') {\n  usingBar.value = false\n  emitEvent(props.onBarScrollEnd, {\n    ...getCommonPayload(),\n    type\n  })\n}\n\nfunction handleXBarScroll(percent: number) {\n  percentX.value = percent\n  x.value = (percent * xScrollLimit.value) / 100\n  triggerUpdate()\n\n  emitEvent(props.onBarScroll, {\n    ...getCommonPayload(),\n    type: 'horizontal'\n  })\n  emitScrollEvent('horizontal')\n}\n\nfunction handleYBarScroll(percent: number) {\n  percentY.value = percent\n  y.value = (percent * yScrollLimit.value) / 100\n  triggerUpdate()\n\n  emitEvent(props.onBarScroll, {\n    ...getCommonPayload(),\n    type: 'vertical'\n  })\n  emitScrollEvent('vertical')\n}\n\nfunction emitScrollEvent(type: Exclude<ScrollMode, 'horizontal-exact'>) {\n  emitEvent(props.onScroll, {\n    ...getCommonPayload(),\n    type\n  })\n  emitter.emit('scroll', {\n    ...getCommonPayload(),\n    type\n  })\n}\n\nfunction ensureScrollOffset() {\n  if (wrapperEl.value) {\n    wrapperEl.value.scrollTop = 0\n    wrapperEl.value.scrollLeft = 0\n  }\n}\n\nfunction getState() {\n  const { clientX: scrollX, clientY: scrollY, percentX, percentY } = getCommonPayload()\n\n  return {\n    scrollX,\n    scrollY,\n    percentX,\n    percentY,\n    enableXScroll: enableXScroll.value,\n    enableYScroll: enableYScroll.value\n  }\n}\n\nfunction waitTransition(duration = waitDelay) {\n  clearTimeout(timer.wait)\n\n  return new Promise<void>(resolve => {\n    timer.wait = setTimeout(() => resolve(), duration + 1)\n  })\n}\n\nfunction scrollTo(clientX: number, clientY: number, duration?: number) {\n  setDuration(duration)\n  nextTick(() => {\n    let changed = false\n\n    if (enableXScroll.value && Math.abs(x.value + clientX) > 0.01) {\n      x.value = -clientX\n      changed = true\n    }\n\n    if (enableYScroll.value && Math.abs(y.value + clientY) > 0.01) {\n      y.value = -clientY\n      changed = true\n    }\n\n    verifyScroll()\n    syncBarScroll()\n\n    if (!changed) transitionDuration.value = -1\n  })\n\n  return waitTransition(duration)\n}\n\nfunction scrollBy(deltaX: number, deltaY: number, duration?: number) {\n  setDuration(duration)\n  nextTick(() => {\n    let changed = false\n\n    if (deltaX && enableXScroll) {\n      x.value -= deltaX\n      changed = true\n    }\n\n    if (deltaY && enableYScroll) {\n      y.value -= deltaY\n      changed = true\n    }\n\n    verifyScroll()\n    syncBarScroll()\n\n    if (!changed) transitionDuration.value = -1\n  })\n\n  return waitTransition(duration)\n}\n\nfunction setDuration(duration?: number) {\n  if (typeof duration === 'number') {\n    transitionDuration.value = duration\n\n    if (transitionDuration.value === 0) {\n      nextTick(() => {\n        transitionDuration.value = -1\n      })\n    }\n  }\n}\n\nfunction scrollToElement(el: string | Element, duration?: number, offset = 0) {\n  if (!contentEl.value) return Promise.resolve()\n\n  if (typeof el === 'string') {\n    el = contentEl.value.querySelector(el)!\n  }\n\n  if (!isElement(el)) return Promise.resolve()\n\n  const wrapperRect = contentEl.value.getBoundingClientRect()\n  const elRect = el.getBoundingClientRect()\n\n  let clientX = 0\n  let clientY = 0\n\n  if (mode.value !== 'vertical') {\n    clientX = elRect.left - wrapperRect.left + offset\n  }\n\n  if (mode.value !== 'horizontal') {\n    clientY = elRect.top - wrapperRect.top + offset\n  }\n\n  return scrollTo(clientX, clientY, duration)\n}\n\nfunction ensureInView(el: string | Element, duration?: number, offset = 0) {\n  if (!wrapperEl.value) return Promise.resolve()\n\n  if (typeof el === 'string') {\n    el = wrapperEl.value.querySelector(el)!\n  }\n\n  if (!isElement(el)) return Promise.resolve()\n\n  const wrapperRect = wrapperEl.value.getBoundingClientRect()\n  const elRect = el.getBoundingClientRect()\n\n  let clientX = 0\n  let clientY = 0\n\n  if (mode.value !== 'vertical') {\n    if (elRect.left < wrapperRect.left + offset) {\n      clientX = elRect.left - wrapperRect.left - offset\n    } else if (elRect.right > wrapperRect.right - offset) {\n      clientX = elRect.right - wrapperRect.right + offset\n    }\n  }\n\n  if (mode.value !== 'horizontal') {\n    if (elRect.top < wrapperRect.top + offset) {\n      clientY = elRect.top - wrapperRect.top - offset\n    } else if (elRect.bottom > wrapperRect.bottom - offset) {\n      clientY = elRect.bottom - wrapperRect.bottom + offset\n    }\n  }\n\n  return scrollBy(clientX, clientY, duration)\n}\n\nfunction getXScrollLimit() {\n  return [0, -xScrollLimit.value]\n}\n\nfunction getYScrollLimit() {\n  return [0, -yScrollLimit.value]\n}\n\nfunction addScrollListener(listener: EventHandler) {\n  emitter.on('scroll', listener)\n}\n\nfunction removeScrollListener(listener: EventHandler) {\n  emitter.off('scroll', listener)\n}\n</script>\n\n<template>\n  <div\n    ref=\"wrapperEl\"\n    :class=\"className\"\n    :style=\"style\"\n    @mousedown=\"handleMouseDown\"\n    @touchstart=\"handleTouchStart\"\n    @scroll=\"ensureScrollOffset\"\n    @wheel.exact=\"handleWheel($event, props.mode === 'horizontal-exact' ? 'horizontal' : 'vertical')\"\n    @wheel.shift=\"handleWheel($event, 'horizontal')\"\n  >\n    <div v-if=\"$slots.extra\" :class=\"nh.be('extra')\">\n      <slot name=\"extra\" v-bind=\"slotParams\"></slot>\n    </div>\n    <ResizeObserver throttle :on-resize=\"handleResize\">\n      <component\n        :is=\"props.scrollTag || 'div'\"\n        v-bind=\"props.scrollAttrs\"\n        ref=\"contentEl\"\n        :class=\"wrapperClass\"\n        :style=\"wrapperStyle\"\n        @transitionend=\"transitionDuration = -1\"\n      >\n        <slot v-bind=\"slotParams\"></slot>\n      </component>\n    </ResizeObserver>\n    <Scrollbar\n      v-if=\"props.useXBar\"\n      ref=\"xBar\"\n      inherit\n      placement=\"bottom\"\n      :class=\"[nh.bem('bar', 'horizontal'), props.barClass]\"\n      :fade=\"props.barFade\"\n      :bar-length=\"xBarLength\"\n      :disabled=\"!enableXScroll\"\n      :duration=\"transitionDuration\"\n      :use-track=\"props.useBarTrack\"\n      @scroll-start=\"handleBarScrollStart('horizontal')\"\n      @scroll=\"handleXBarScroll\"\n      @scroll-end=\"handleBarScrollEnd('horizontal')\"\n    ></Scrollbar>\n    <Scrollbar\n      v-if=\"props.useYBar\"\n      ref=\"yBar\"\n      inherit\n      placement=\"right\"\n      :class=\"[nh.bem('bar', 'vertical'), props.barClass]\"\n      :fade=\"props.barFade\"\n      :bar-length=\"yBarLength\"\n      :disabled=\"!enableYScroll\"\n      :duration=\"transitionDuration\"\n      :use-track=\"props.useBarTrack\"\n      @scroll-start=\"handleBarScrollStart('vertical')\"\n      @scroll=\"handleYBarScroll\"\n      @scroll-end=\"handleBarScrollEnd('vertical')\"\n    ></Scrollbar>\n  </div>\n</template>\n"
    },
    {
      "target": "components/scroll/symbol.ts",
      "content": "import { USE_TOUCH } from '@pocui/utils'\n\nexport type ScrollMode = 'horizontal' | 'horizontal-exact' | 'vertical' | 'both'\n\nexport interface ScrollPayload {\n  type: Exclude<ScrollMode, 'horizontal-exact'>,\n\n  clientX: number,\n\n  clientY: number,\n\n  percentX: number,\n\n  percentY: number\n}\n\nexport interface BarScrollPayload {\n  type: 'vertical' | 'horizontal',\n\n  clientX: number,\n\n  clientY: number,\n\n  percentX: number,\n\n  percentY: number\n}\n\nexport interface ScrollState {\n  scrollX: number,\n\n  scrollY: number,\n\n  percentX: number,\n\n  percentY: number,\n\n  enableXScroll: boolean,\n\n  enableYScroll: boolean\n}\n\nexport interface ScrollSlotParams {\n  getState: () => ScrollState,\n\n  refresh: () => void,\n\n  scrollTo: (clientX: number, clientY: number, duration?: number) => void,\n\n  scrollBy: (deltaX: number, deltaY: number, duration?: number) => void,\n\n  scrollToElement: (el: string | Element, duration?: number, offset?: number) => void,\n\n  ensureInView: (el: string | Element, duration?: number, offset?: number) => void\n}\n\nexport const scrollModes = Object.freeze<ScrollMode[]>(['horizontal', 'horizontal-exact', 'vertical', 'both'])\n\nexport const MOVE_EVENT = USE_TOUCH ? 'touchmove' : 'mousemove'\nexport const UP_EVENT = USE_TOUCH ? 'touchend' : 'mouseup'\n"
    }
  ],
  "dependencies": ["vue", "@pocui/hooks", "@pocui/utils", "@pocui/config"],
  "registryDependencies": ["scroll.scss", "resize-observer", "scrollbar"],
  "categories": ["other"],
  "meta": { "isReferenceOnly": false }
}
