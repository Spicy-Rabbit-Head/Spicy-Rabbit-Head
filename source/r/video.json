{
  "name": "video",
  "type": "registry:components",
  "description": "快速为视频播放创建一系列控件。",
  "files": [
    {
      "target": "components/video/helper.ts",
      "content": "import { IconOptions, IconValue } from '@pocui/config'\nimport { doubleDigits, leaveNumber } from '@pocui/utils'\n\nexport function formatSeconds(seconds: number) {\n  if (seconds <= 0) return '00:00'\n\n  const remainders = leaveNumber(Math.ceil(seconds), 60, 2)\n\n  if (remainders.length < 2) {\n    remainders.unshift(0)\n  }\n\n  return remainders.length < 3\n    ? remainders.map(doubleDigits).join(':')\n    : remainders.map((r, i) => (i ? doubleDigits(r) : r)).join(':')\n}\n\nexport function mergeIconScale(scale: number, icon: IconOptions & { icon: IconValue }) {\n  return {\n    ...icon,\n    scale: +(icon.scale || 1) * scale\n  }\n}\n"
    },
    {
      "target": "components/video/index.ts",
      "content": "import Video from './video'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Video }\nexport { videoProps } from './props'\nexport { videoDefaultShortcuts, videoDefaultControlLayout } from './symbol'\n\nexport type VideoExposed = ComponentPublicInstance & InstanceType<typeof Video>\n\nexport type { VideoProps, VideoCProps } from './props'\nexport type {\n  VideoPresetControl,\n  VideoControlName,\n  VideoControlConfig,\n  VideoControlLayout,\n  VideoPlaybackRate,\n  VideoControlType,\n  VideoControlOption,\n  VideoSegment\n} from './symbol'\n"
    },
    {
      "target": "components/video/props.ts",
      "content": "import { FullScreenType } from '@/components/full-screen'\nimport { IconEffect } from '@/components/icon'\n\nimport { ClassType, booleanProp, buildProps, eventProp } from '@pocui/config'\n\nimport {\n  VideoControlLayout,\n  VideoControlOption,\n  VideoControlType,\n  VideoPlaybackRate,\n  VideoSegment,\n  VideoShortcutOptions\n} from './symbol'\n\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\n\nexport const videoProps = buildProps({\n  src: String,\n  srcList: Array as PropType<string[]>,\n  noControls: booleanProp,\n  videoAttrs: Object,\n  time: Number,\n  volume: Number,\n  playbackRate: Number,\n  playbackRates: Array as PropType<(number | VideoPlaybackRate)[]>,\n  controlLayout: Object as PropType<VideoControlLayout>,\n  poster: String,\n  video: Object as PropType<HTMLVideoElement>,\n  segments: Array as PropType<(number | VideoSegment)[]>,\n  loading: booleanProp,\n  loadingIcon: Object,\n  loadingEffect: String as PropType<IconEffect>,\n  shortcuts: Object as PropType<VideoShortcutOptions>,\n  onPlay: eventProp(),\n  onPause: eventProp(),\n  onEnded: eventProp(),\n  onTimeChange: eventProp<(time: number) => void>(),\n  onVolumeChange: eventProp<(volume: number) => void>(),\n  onRateChange: eventProp<(rate: number) => void>(),\n  onToggleFlip: eventProp<(flip: boolean) => void>(),\n  onTogglePip: eventProp<(pip: boolean) => void>(),\n  onToggleFull: eventProp<(full: false | FullScreenType) => void>(),\n  onPrev: eventProp(),\n  onNext: eventProp(),\n  onRefresh: eventProp()\n})\n\nexport type VideoProps = ExtractPropTypes<typeof videoProps>\nexport type VideoCProps = ConfigurableProps<ExtractPropTypes<typeof videoProps>>\n\nexport const videoControlProps = buildProps({\n  type: String as PropType<VideoControlType>,\n  label: String,\n  tipClass: [String, Array, Object] as PropType<ClassType>,\n  disabled: booleanProp,\n  shortcut: String,\n  focusable: booleanProp,\n  value: [Number, String],\n  options: Array as PropType<(string | VideoControlOption)[]>,\n  onClick: eventProp(),\n  onEnter: eventProp(),\n  onLeave: eventProp(),\n  onFocus: eventProp<(event: FocusEvent) => void>(),\n  onBlur: eventProp<(event: FocusEvent) => void>(),\n  onSelect: eventProp<(option: VideoControlOption) => void>()\n})\n\nexport type VideoControlProps = ExtractPropTypes<typeof videoControlProps>\nexport type VideoControlCProps = ConfigurableProps<ExtractPropTypes<typeof videoControlProps>>\n"
    },
    {
      "target": "components/video/symbol.ts",
      "content": "import type { InjectionKey } from 'vue'\n\nexport type VideoPresetControl =\n  | 'play'\n  | 'play-prev'\n  | 'play-next'\n  | 'refresh'\n  | 'timer'\n  | 'playback-rate'\n  | 'flip'\n  | 'volume'\n  | 'pip'\n  | 'full-window'\n  | 'full-browser'\nexport type VideoShortcutOptions = Partial<Record<VideoPresetControl, string>>\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type VideoControlName = VideoPresetControl | (string & {})\nexport type VideoControlConfig = VideoControlName | [VideoControlName, any]\n\nexport interface VideoControlLayout {\n  left?: VideoControlConfig[],\n\n  center?: VideoControlConfig[],\n\n  right?: VideoControlConfig[]\n}\n\nexport interface VideoPlaybackRate {\n  label?: string,\n\n  value: number\n}\n\nexport type VideoControlType = 'button' | 'select' | 'panel'\n\nexport interface VideoControlOption {\n  value: string | number,\n\n  label?: string,\n\n  selectedLabel?: string,\n\n  disabled?: boolean,\n\n  divided?: boolean,\n\n  title?: string\n}\n\nexport interface VideoSegment {\n  time: number,\n\n  title?: string\n}\n\nexport interface VideoState {\n  placeId?: string,\n\n  iconScale: number,\n\n  addShortcut: (key: string, cb: () => void) => () => void\n}\n\nconst defaultLayout: Required<VideoControlLayout> = {\n  left: ['play-prev', 'play', 'play-next', 'refresh', 'timer'],\n  center: [],\n  right: ['playback-rate', 'volume', 'flip', 'pip', 'full-window', 'full-browser']\n}\n\nfor (const key of Object.keys(defaultLayout) as (keyof VideoControlLayout)[]) {\n  defaultLayout[key] = Object.freeze(defaultLayout[key]) as any\n}\n\nexport const videoDefaultControlLayout = Object.freeze(defaultLayout)\n\nexport const videoDefaultShortcuts = Object.freeze({\n  play: 'Space',\n  'play-prev': 'PageUp',\n  'play-next': 'PageDown',\n  refresh: 'R',\n  flip: 'C',\n  volume: 'M',\n  pip: 'P',\n  'full-window': 'G',\n  'full-browser': 'F'\n})\n\nexport const VIDEO_STATE: InjectionKey<VideoState> = Symbol('VIDEO_STATE')\n"
    },
    {
      "target": "components/video/video-control.vue",
      "content": "<script setup lang=\"ts\">\nimport { Option } from '@/components/option'\nimport { Tooltip } from '@/components/tooltip'\n\nimport { computed, inject, onBeforeUnmount, ref, watch } from 'vue'\n\nimport { emitEvent, useNameHelper, useProps } from '@pocui/config'\nimport { listToMap } from '@pocui/utils'\n\nimport { videoControlProps } from './props'\n\nimport { VIDEO_STATE } from './symbol'\n\nimport type { VideoControlOption } from './symbol'\n\ndefineOptions({ name: 'VideoControl',\n  description:'视频控制组件，用于视频播放器的各种控制按钮。',\n  categories: ['display'] })\n\nconst _props = defineProps(videoControlProps)\nconst props = useProps('videoControl', _props, {\n  type: 'button',\n  label: {\n    static: true,\n    default: ''\n  },\n  tipClass: null,\n  disabled: false,\n  shortcut: {\n    static: true,\n    default: ''\n  },\n  focusable: false,\n  value: null,\n  options: () => []\n})\n\ndefineSlots<{\n  selected(props: { option: VideoControlOption }): any,\n  default(): any,\n  label(): any,\n  panel(): any,\n  option(props: { option: VideoControlOption, index: number, selected: boolean }): any\n}>()\n\nconst nh = useNameHelper('video')\n\nconst videoState = inject(VIDEO_STATE)!\n\nconst currentValue = ref(props.value)\n\nconst className = computed(() => {\n  return {\n    [nh.be('control')]: true,\n    [nh.bem('control', props.type)]: props.type !== 'button',\n    [nh.bem('control', 'disabled')]: props.disabled\n  }\n})\nconst tipClass = computed(() => {\n  return props.type === 'button' ? nh.be('control-tip') : nh.be('control-panel')\n})\nconst objectOptions = computed(() => {\n  return props.options.map(option => {\n    return typeof option === 'string' ? { value: option } : option\n  })\n})\nconst optionMap = computed(() => listToMap(objectOptions.value, 'value', undefined, true))\nconst currentOption = computed(() => optionMap.value.get(currentValue.value))\n\nlet removeShortcut: (() => void) | undefined\n\nwatch(\n  () => props.shortcut,\n  value => {\n    removeShortcut?.()\n\n    if (value) {\n      removeShortcut = videoState.addShortcut(value, handleClick)\n    }\n  },\n  { immediate: true }\n)\n\nonBeforeUnmount(() => removeShortcut?.())\n\nfunction handleClick() {\n  !props.disabled && emitEvent(props.onClick)\n}\n\nfunction handleSelect(option: VideoControlOption) {\n  if (props.disabled || option.disabled) return\n\n  currentValue.value = option.value\n  emitEvent(props.onSelect, option)\n}\n</script>\n\n<template>\n  <div :class=\"className\">\n    <Tooltip\n      :trigger=\"props.focusable ? 'hover-focus' : 'hover'\"\n      raw\n      shift\n      :transfer=\"videoState.placeId && `#${videoState.placeId}`\"\n      :tip-class=\"[tipClass, props.tipClass]\"\n      :no-hover=\"props.type === 'button'\"\n      :disabled=\"props.type === 'button' ? !props.label : props.disabled\"\n      @tip-enter=\"emitEvent(props.onEnter)\"\n      @tip-leave=\"emitEvent(props.onLeave)\"\n    >\n      <template #trigger>\n        <button\n          :class=\"nh.be('control-button')\"\n          type=\"button\"\n          @focus=\"emitEvent(props.onFocus, $event)\"\n          @blur=\"emitEvent(props.onBlur, $event)\"\n          @click=\"handleClick\"\n        >\n          <slot v-if=\"currentOption\" name=\"selected\" :option=\"currentOption\">\n            {{ currentOption.selectedLabel || currentOption.label || currentOption.value }}\n          </slot>\n          <slot v-else></slot>\n        </button>\n      </template>\n      <template v-if=\"props.type === 'button'\">\n        <span :class=\"nh.be('control-name')\">\n          <slot name=\"label\">\n            {{ props.label }}\n            <span v-if=\"props.shortcut\" :class=\"nh.be('control-shortcut')\">\n              {{ `(${props.shortcut})` }}\n            </span>\n          </slot>\n        </span>\n      </template>\n      <slot v-else name=\"panel\">\n        <ul v-if=\"props.type === 'select'\" :class=\"nh.be('control-options')\">\n          <Option\n            v-for=\"(option, index) in objectOptions\"\n            :key=\"option.value\"\n            :class=\"{\n              [nh.be('control-option')]: true,\n              [nh.bem('control-option', 'selected')]: option.value === currentValue\n            }\"\n            :label=\"option.label\"\n            :value=\"option.value\"\n            :disabled=\"option.disabled\"\n            :divided=\"option.disabled\"\n            :title=\"option.title\"\n            no-hover\n            @select=\"handleSelect(option)\"\n          >\n            <slot\n              name=\"option\"\n              :option=\"option\"\n              :index=\"index\"\n              :selected=\"option.value === currentValue\"\n            >\n              {{ option.label || option.value }}\n            </slot>\n          </Option>\n        </ul>\n      </slot>\n    </Tooltip>\n  </div>\n</template>\n"
    },
    {
      "target": "components/video/video-progress.vue",
      "content": "<script setup lang=\"ts\">\nimport { ResizeObserver } from '@/components/resize-observer'\n\nimport { Slider } from '@/components/slider'\n\nimport { computed, ref } from 'vue'\n\nimport { getStepByWord, useLocale, useNameHelper } from '@pocui/config'\n\nimport { useListener, useSetTimeout } from '@pocui/hooks'\nimport { boundRange, throttle } from '@pocui/utils'\n\nimport { formatSeconds } from './helper'\n\nimport type { PropType } from 'vue'\n\nimport type { SliderExposed } from '@/components/slider'\n\nimport type { VideoSegment } from './symbol'\n\ninterface PointState {\n  start: number,\n\n  startPercent: number,\n\n  end: number,\n\n  endPercent: number,\n\n  duration: number,\n\n  durationPercent: number,\n\n  width: number\n}\n\ndefineOptions({ name: 'VideoProgress',\n  description:'视频进度组件，用于显示和控制视频播放进度。',\n  categories: ['display'] })\n\nconst props = defineProps({\n  time: {\n    type: Number,\n    default: 0\n  },\n  duration: {\n    type: Number,\n    default: 0\n  },\n  segments: {\n    type: Array as PropType<VideoSegment[]>,\n    default: () => []\n  },\n  noPreview: {\n    type: Boolean,\n    default: false\n  },\n  previewSrc: {\n    type: String,\n    default: ''\n  }\n})\n\ndefineSlots<{\n  trigger(): any,\n  preview(): any\n}>()\n\nconst emit = defineEmits(['change'])\n\nconst nh = useNameHelper('video')\nconst locale = useLocale('video')\n\nconst { timer } = useSetTimeout()\n\nconst slidTime = ref(0)\nconst hovered = ref(false)\nconst hoveredTime = ref(0)\nconst indicatorLeft = ref(0)\nconst previewLeft = ref(0)\n\nlet paddingX = [0, 0]\nlet sliderWidth = 100\nlet previewWidth = 60\n\nconst wrapper = ref<HTMLElement>()\nconst slider = ref<SliderExposed>()\nconst sliderEl = computed(() => slider.value?.$el as HTMLElement | undefined)\nconst preview = ref<HTMLElement>()\n\nconst sliding = computed(() => !!slider.value?.sliding[1])\nconst percent = computed(() => {\n  return props.duration ? ((sliding.value ? slidTime.value : props.time) / props.duration) * 100 : 0\n})\nconst className = computed(() => {\n  return {\n    [nh.be('progress')]: true,\n    [nh.bem('progress', 'sliding')]: sliding.value,\n    [nh.bem('progress', 'disabled')]: props.duration <= 0\n  }\n})\nconst points = computed<PointState[]>(() => {\n  const duration = Math.max(1, props.duration)\n\n  let times = props.segments.map(segment => segment.time)\n\n  if (!times.length) times = [0, duration]\n\n  times = times.at(-1) === duration ? times : [...times, duration]\n  times = times[0] === 0 ? times : [0, ...times]\n\n  const points: PointState[] = []\n\n  for (let i = 0, len = times.length - 1; i < len; ++i) {\n    const start = times[i]\n    const end = times[i + 1]\n    const pointDuration = end - start\n\n    points.push({\n      start,\n      startPercent: (start / duration) * 100,\n      end,\n      endPercent: (end / duration) * 100,\n      duration: pointDuration,\n      durationPercent: (pointDuration / duration) * 100,\n      width: ((end - start) / duration) * 100\n    })\n  }\n\n  return points\n})\nconst segmentLabel = computed(() => {\n  const time = hoveredTime.value\n  const segments = props.segments\n\n  if (!segments.length) return ''\n\n  let index = -1\n\n  if (time <= 0) {\n    index = 0\n  } else {\n    for (let i = 1, len = segments.length; i < len; ++i) {\n      if (segments[i].time > time) {\n        index = i - 1\n        break\n      }\n    }\n  }\n\n  if (index < 0) {\n    index = segments.length - 1\n  }\n\n  const title = segments[index]?.title || getStepByWord(locale.value.chapterCount, index + 1)\n\n  return title && ` (${title})`\n})\n\nuseListener(sliderEl, 'pointerenter', () => {\n  clearTimeout(timer.hover)\n\n  timer.hover = setTimeout(() => {\n    hovered.value = true\n  }, 100)\n})\nuseListener(sliderEl, 'pointerleave', () => {\n  clearTimeout(timer.hover)\n\n  timer.hover = setTimeout(() => {\n    hovered.value = false\n  }, 100)\n})\nuseListener(\n  sliderEl,\n  'pointermove',\n  throttle((event: PointerEvent) => {\n    if (!sliding.value) {\n      processMoveOnTrack(event)\n    }\n  })\n)\n\nfunction processMoveOnTrack(event: PointerEvent) {\n  if (!sliderEl.value) return\n\n  const offsetX = boundRange(event.clientX - sliderEl.value.getBoundingClientRect().left, 0, sliderWidth)\n\n  hoveredTime.value = (offsetX / sliderWidth) * props.duration\n  indicatorLeft.value = offsetX + paddingX[0]\n  previewLeft.value = boundRange(\n    offsetX - previewWidth * 0.5 + paddingX[0],\n    0,\n    sliderWidth - previewWidth + paddingX[0] + paddingX[1]\n  )\n}\n\nfunction onSliderResize(entry: ResizeObserverEntry) {\n  if (!wrapper.value) return\n\n  const style = getComputedStyle(wrapper.value)\n\n  paddingX = [parseFloat(style.paddingLeft), parseFloat(style.paddingRight)]\n  sliderWidth = entry.borderBoxSize?.[0]?.inlineSize ?? entry.contentRect.width\n}\n\nfunction onPreviewResize(entry: ResizeObserverEntry) {\n  previewWidth = entry.borderBoxSize?.[0]?.inlineSize ?? entry.contentRect.width\n}\n\nfunction handleChange(permillage: number) {\n  emit('change', (permillage / 1000) * props.duration)\n}\n\nconst onSlideMove = throttle(processMoveOnTrack)\n\nfunction onSlideStart() {\n  slidTime.value = props.time\n\n  document.addEventListener('pointermove', onSlideMove)\n  document.addEventListener('pointerup', onSlideEnd)\n}\n\nfunction onSlideEnd() {\n  document.removeEventListener('pointermove', onSlideMove)\n  document.removeEventListener('pointerup', onSlideEnd)\n}\n</script>\n\n<template>\n  <div ref=\"wrapper\" :class=\"className\">\n    <ResizeObserver :on-resize=\"onSliderResize\">\n      <Slider\n        ref=\"slider\"\n        :class=\"nh.be('progress-slider')\"\n        :value=\"percent * 10\"\n        :max=\"1000\"\n        :vertical=\"false\"\n        :range=\"false\"\n        hide-tip\n        trigger-fade\n        flip-marker\n        :disabled=\"duration <= 0\"\n        @change=\"handleChange\"\n        @pointerdown=\"onSlideStart\"\n      >\n        <template #filler=\"state\">\n          <div\n            v-for=\"(point, index) in points\"\n            :key=\"index\"\n            :class=\"nh.be('progress-segment')\"\n            :style=\"{ width: `${point.width}%` }\"\n          >\n            <div :class=\"nh.be('progress-track')\">\n              <div\n                :class=\"nh.be('progress-filler')\"\n                :style=\"{\n                  visibility: state.percent[1] < point.startPercent ? 'hidden' : undefined,\n                  transform: `translateX(${Math.min(\n                    (Math.max(state.percent[1] - point.startPercent, 0) / point.durationPercent) * 100 - 100,\n                    0\n                  )}%) translateZ(0)`\n                }\"\n              ></div>\n            </div>\n          </div>\n        </template>\n        <template #trigger>\n          <slot name=\"trigger\">\n            <div :class=\"nh.be('progress-trigger')\"></div>\n          </slot>\n        </template>\n      </Slider>\n    </ResizeObserver>\n    <div\n      :class=\"{\n        [nh.be('progress-indicator')]: true,\n        [nh.bem('progress-indicator', 'active')]: hovered && !sliding\n      }\"\n      :style=\"{ transform: `translateX(${indicatorLeft}px) translateZ(0)` }\"\n    ></div>\n    <ResizeObserver v-if=\"!noPreview\" :on-resize=\"onPreviewResize\">\n      <div\n        ref=\"preview\"\n        :class=\"{\n          [nh.be('preview')]: true,\n          [nh.bem('preview', 'has-image')]: previewSrc,\n          [nh.bem('preview', 'active')]: hovered || sliding\n        }\"\n        :style=\"{ transform: `translateX(${previewLeft}px) translateZ(0)` }\"\n      >\n        <slot name=\"preview\">\n          <div v-if=\"previewSrc\" :class=\"nh.be('preview-image')\">\n            <img :src=\"previewSrc\" alt=\"\" />\n          </div>\n          <div :class=\"nh.be('preview-time')\">\n            {{ formatSeconds(hoveredTime) + segmentLabel }}\n          </div>\n        </slot>\n      </div>\n    </ResizeObserver>\n  </div>\n</template>\n"
    },
    {
      "target": "components/video/video-timer.vue",
      "content": "<script setup lang=\"ts\">\nimport { Input } from '@/components/input'\n\nimport { computed, nextTick, onMounted, ref, watch } from 'vue'\n\nimport { useNameHelper } from '@pocui/config'\nimport { getRangeWidth, isValidNumber, toNumber } from '@pocui/utils'\n\nimport { formatSeconds } from './helper'\n\ndefineOptions({ name: 'VideoTimer',\n  description:'视频计时器组件，用于显示视频播放时间信息。',\n  categories: ['display'] })\n\nconst props = defineProps({\n  time: {\n    type: Number,\n    default: 0\n  },\n  duration: {\n    type: Number,\n    default: 0\n  },\n  disabled: {\n    type: Boolean,\n    default: false\n  }\n})\n\nconst emit = defineEmits(['change'])\n\nconst nh = useNameHelper('video')\n\nconst currentTime = ref(props.time)\nconst editing = ref(false)\nconst width = ref(84)\nconst inputTime = ref('')\n\nconst input = ref<HTMLInputElement>()\nconst durationEl = ref<HTMLElement>()\n\nconst formattedTime = computed(() => formatSeconds(currentTime.value))\n\nwatch(\n  () => props.time,\n  value => {\n    currentTime.value = value\n  }\n)\nwatch(\n  () => props.disabled,\n  value => {\n    if (value) {\n      editing.value = false\n    }\n  }\n)\n\nonMounted(() => {\n  watch(\n    () => props.duration,\n    () => {\n      nextTick(() => {\n        width.value = durationEl.value ? getRangeWidth(durationEl.value) * 2 + 20 : 84\n      })\n    },\n    { immediate: true }\n  )\n})\n\nfunction handleClick() {\n  if (!props.disabled && !editing.value) {\n    editing.value = true\n    inputTime.value = formattedTime.value\n    nextTick(() => {\n      input.value?.focus()\n    })\n  }\n}\n\nfunction finishInput(confirm: boolean) {\n  editing.value = false\n\n  if (confirm) {\n    const units = inputTime.value.trim().split(':')\n\n    if (units.every(unit => isValidNumber(unit))) {\n      currentTime.value = units\n        .map(toNumber)\n        .reverse()\n        .slice(0, 3)\n        .reduce((seconds, unit, i) => seconds + 60 ** i * unit, 0)\n      currentTime.value = Math.min(currentTime.value, props.duration)\n      emit('change', currentTime.value)\n    }\n  }\n}\n</script>\n\n<template>\n  <div\n    :class=\"[nh.be('control'), nh.be('timer'), props.disabled && nh.bem('control', 'disabled')]\"\n    :style=\"{ width: `${width}px` }\"\n    @click=\"handleClick\"\n  >\n    <Input\n      v-if=\"editing\"\n      ref=\"input\"\n      v-model:value=\"inputTime\"\n      :class=\"nh.be('timer-input')\"\n      size=\"small\"\n      transparent\n      @blur=\"finishInput(false)\"\n      @enter=\"finishInput(true)\"\n    ></Input>\n    <template v-else>\n      <span>\n        {{ formattedTime }}\n      </span>\n      <span :class=\"nh.be('timer-separator')\">/</span>\n      <span ref=\"durationEl\">\n        {{ formatSeconds(duration) }}\n      </span>\n    </template>\n  </div>\n</template>\n"
    },
    {
      "target": "components/video/video-volume.vue",
      "content": "<script setup lang=\"ts\">\nimport { Icon } from '@/components/icon'\nimport { Slider } from '@/components/slider'\n\nimport { computed, inject, ref, watch } from 'vue'\n\nimport { useIcons, useNameHelper } from '@pocui/config'\n\nimport { mergeIconScale } from './helper'\n\nimport { VIDEO_STATE } from './symbol'\nimport VideoControl from './video-control.vue'\n\ndefineOptions({ name: 'VideoVolume',description:'视频音量组件，用于控制视频音量大小。',\n  categories: ['display'] })\n\nconst props = defineProps({\n  volume: {\n    type: Number,\n    default: 1\n  }\n})\n\nconst emit = defineEmits(['change'])\n\nconst nh = useNameHelper('video')\nconst icons = useIcons()\n\nconst videoState = inject(VIDEO_STATE)!\n\nconst currentVolume = ref(props.volume)\nconst muted = ref(false)\n\nconst volumeIcon = computed(() => {\n  return muted.value\n    ? icons.value.volumeMute\n    : currentVolume.value < 0.5\n      ? icons.value.volumeLow\n      : icons.value.volumeHigh\n})\n\nwatch(\n  () => props.volume,\n  value => {\n    currentVolume.value = value\n  }\n)\n\ndefineExpose({ toggleMute })\n\nlet prevVolume = currentVolume.value\n\nfunction toggleMute() {\n  if (muted.value) {\n    currentVolume.value = prevVolume <= 0 ? 0.5 : prevVolume\n  } else {\n    prevVolume = currentVolume.value\n    currentVolume.value = 0\n  }\n\n  muted.value = !muted.value\n\n  emit('change', currentVolume.value)\n}\n\nfunction handleSlide(value: number) {\n  value /= 100\n  prevVolume = value\n  currentVolume.value = value\n  muted.value = value <= 0\n\n  emit('change', currentVolume.value)\n}\n</script>\n\n<template>\n  <VideoControl\n    :class=\"nh.be('volume')\"\n    type=\"panel\"\n    :tip-class=\"nh.be('volume-panel')\"\n    @click=\"toggleMute\"\n  >\n    <Icon v-bind=\"mergeIconScale(videoState.iconScale, volumeIcon)\"></Icon>\n    <template #panel>\n      <div :class=\"nh.be('volume-text')\">\n        {{ (currentVolume * 100).toFixed() }}\n      </div>\n      <Slider\n        :value=\"currentVolume * 100\"\n        :class=\"nh.be('volume-slider')\"\n        :min=\"0\"\n        :max=\"100\"\n        vertical\n        hide-tip\n        reverse\n        @input=\"handleSlide\"\n      ></Slider>\n    </template>\n  </VideoControl>\n</template>\n"
    },
    {
      "target": "components/video/video.tsx",
      "content": "import { FullScreen } from '@/components/full-screen'\nimport { Icon } from '@/components/icon'\nimport { Progress } from '@/components/progress'\n\nimport {\n  SlotsType,\n  Transition,\n  computed,\n  defineComponent,\n  nextTick,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  renderSlot,\n  shallowReadonly,\n  watch\n} from 'vue'\n\nimport { createSlotRender, useListener, useModifier, useSetTimeout } from '@pocui/hooks'\nimport { decide, decimalLength, isClient, noop, toCapitalCase, toNumber } from '@pocui/utils'\n\nimport { emitEvent, useIcons, useLocale, useNameHelper, useProps } from '@pocui/config'\n\nimport { videoProps } from './props'\n\nimport { VIDEO_STATE, videoDefaultControlLayout, videoDefaultShortcuts } from './symbol'\nimport VideoControl from './video-control.vue'\nimport VideoProgress from './video-progress.vue'\nimport VideoTimer from './video-timer.vue'\nimport VideoVolume from './video-volume.vue'\n\nimport type { VideoControlConfig, VideoPlaybackRate } from './symbol'\nimport type { FullScreenExposed, FullScreenType } from '@/components/full-screen'\n\nexport default defineComponent({\n  name: 'Video',\n  description:'快速为视频播放创建一系列控件。',\n  categories: ['display'],\n  props: videoProps,\n  emits: ['update:src', 'update:time', 'update:volume', 'update:playback-rate'],\n  slots: Object as SlotsType<{\n    default(): any,\n    extra(): any,\n    loading(): any,\n    player(): any,\n    poster?(): any,\n    state(props: { active: boolean }): any,\n    [key: `control-${string}`]: () => any\n  }>,\n  setup(_props, { slots, emit, expose }) {\n    const props = useProps('video', _props, {\n      src: {\n        static: true,\n        default: ''\n      },\n      srcList: {\n        static: true,\n        default: null\n      },\n      noControls: false,\n      videoAttrs: null,\n      time: {\n        static: true,\n        default: 0\n      },\n      volume: 1,\n      playbackRate: 1,\n      playbackRates: () => [0.5, 1, 1.25, 1.5, 2],\n      controlLayout: () => videoDefaultControlLayout,\n      poster: '',\n      video: {\n        static: true,\n        default: null\n      },\n      segments: () => [],\n      loading: false,\n      loadingIcon: null,\n      loadingEffect: null,\n      shortcuts: () => ({})\n    })\n\n    const nh = useNameHelper('video')\n    const locale = useLocale('video')\n    const icons = useIcons()\n\n    const { timer } = useSetTimeout()\n\n    const pipEnabled = isClient && document.pictureInPictureEnabled\n\n    const currentSrc = ref(props.src || props.srcList?.[0] || (props.videoAttrs?.src as string) || '')\n    const playing = ref(false)\n    const currentTime = ref(props.time)\n    const canPlay = ref(false)\n    const duration = ref(0)\n    const currentVolume = ref(props.volume) // 0 ~ 1\n    const pip = ref(false)\n    const stateShow = ref(true)\n    // 记录状态不可见（是否完成转换）\n    const stateHidden = ref(false)\n    const currentRate = ref(props.playbackRate)\n    const interacting = ref(false)\n    const hasPlayed = ref(false)\n    const flipped = ref(false)\n    const iconScale = ref(1.3)\n\n    const screen = ref<FullScreenExposed>()\n    const wrapper = computed(() => screen.value?.wrapper as HTMLElement | undefined)\n    const video = ref<HTMLVideoElement>()\n    const volumeRef = ref<InstanceType<typeof VideoVolume>>()\n\n    const placeId = computed(() => screen.value?.placeId)\n    const full = computed<false | FullScreenType>(() => screen.value?.full ?? false)\n    const videoRef = computed<HTMLVideoElement | undefined>(() => video.value || props.video)\n\n    const shortcutRecord = reactive({} as Record<string, () => void>)\n    const shortcuts = computed(() => ({ ...videoDefaultShortcuts, ...props.shortcuts }))\n\n    function addShortcut(key: string, cb: () => void) {\n      if (shortcutRecord[key]) {\n        console.warn(`[pocui:Video] 重复的快捷键 '${key}' 将被忽略`)\n\n        return noop\n      }\n\n      shortcutRecord[key] = cb\n\n      return () => {\n        delete shortcutRecord[key]\n      }\n    }\n\n    useModifier({\n      target: wrapper,\n      passive: false,\n      onKeyDown: (event, modifier) => {\n        if (event.ctrlKey || event.shiftKey || event.altKey || event.metaKey) return\n\n        decide(\n          [\n            [\n              () => modifier.up,\n              () => {\n                currentVolume.value = Math.min(1, currentVolume.value + 0.05)\n              }\n            ],\n            [() => modifier.down, () => (currentVolume.value = Math.max(0, currentVolume.value - 0.05))],\n            [() => modifier.right, () => (currentTime.value = Math.min(duration.value, currentTime.value + 5))],\n            [() => modifier.left, () => (currentTime.value = Math.max(0, currentTime.value - 5))],\n            [() => modifier[shortcuts.value.volume || 'M'], () => volumeRef.value?.toggleMute()],\n            ...Object.keys(shortcutRecord).map(key => {\n              return [() => modifier[key], shortcutRecord[key]] as [() => boolean, () => void]\n            })\n          ],\n          { afterMatchAny: modifier.resetAll }\n        ).then()\n      }\n    })\n\n    const className = computed(() => {\n      return [\n        nh.b(),\n        nh.bs('vars'),\n        {\n          [nh.bm('loading')]: props.loading\n        }\n      ]\n    })\n    const playIcon = computed(() => (playing.value ? icons.value.pause : icons.value.play))\n    const stateIcon = computed(() => {\n      return playing.value ? icons.value.pauseState : icons.value.playState\n    })\n    const rateOptions = computed(() => {\n      const rates = props.playbackRates\n        .map(raw => {\n          const rate = typeof raw === 'number' ? { value: raw } : raw\n\n          rate.value = toNumber(rate.value)\n          rate.label = rate.label || `${decimalLength(rate.value) ? rate.value : rate.value.toFixed(1)}x`\n\n          return rate\n        })\n        .filter(rate => rate.value > 0)\n        .sort((prev, next) => next.value - prev.value)\n\n      if (!rates.find(rate => rate.value === 1)) {\n        const index = rates.findIndex(rate => rate.value < 1)\n\n        rates.splice((index + rates.length) % rates.length, 0, {\n          value: 1,\n          label: '1.0x'\n        })\n      }\n\n      return rates\n    })\n    const segments = computed(() => {\n      return props.segments\n        .map(segment => (typeof segment === 'number' ? { time: segment } : segment))\n        .filter(segment => segment.time >= 0 && segment.time <= duration.value)\n        .sort((prev, next) => prev.time - next.time)\n    })\n    const percent = computed(() => {\n      return duration.value ? (currentTime.value / duration.value) * 100 : 0\n    })\n    const srcFullList = computed(() => {\n      const src = props.src || (props.videoAttrs?.src as string) || ''\n\n      if (src && props.srcList && !props.srcList.includes(src)) {\n        return [src].concat(props.srcList)\n      }\n\n      return props.srcList || [src]\n    })\n    const srcIndex = computed(() => {\n      return srcFullList.value ? srcFullList.value.indexOf(currentSrc.value) : -1\n    })\n\n    const slotParams = shallowReadonly(\n      reactive({\n        playing,\n        currentTime,\n        currentVolume,\n        currentRate,\n        interacting,\n        flipped,\n        canPlay,\n        duration,\n        pip,\n        hasPlayed,\n        togglePlaying,\n        togglePip,\n        changeRate,\n        changeTime,\n        changeVolume,\n        toggleFull\n      })\n    )\n\n    watch(\n      () => props.src,\n      value => {\n        resetMetaState()\n        currentSrc.value = value\n      },\n      { flush: 'pre' }\n    )\n    watch(\n      () => props.time,\n      value => {\n        changeTime(value, false)\n      }\n    )\n    watch(\n      () => props.volume,\n      value => {\n        changeVolume(value, false)\n      }\n    )\n    watch(\n      () => props.playbackRate,\n      value => {\n        changeRate(value, false)\n      }\n    )\n    watch(playing, value => {\n      if (value) {\n        requestAnimationFrame(() => {\n          stateShow.value = false\n        })\n      } else {\n        stateShow.value = true\n      }\n    })\n    watch(canPlay, value => {\n      if (!value) {\n        playing.value = false\n      }\n    })\n    watch(stateShow, value => {\n      if (value) {\n        stateHidden.value = false\n      }\n    })\n\n    onMounted(() => {\n      nextTick(() => {\n        if (isClient && !videoRef.value && screen.value?.wrapper) {\n          video.value = (screen.value.wrapper as HTMLElement).querySelector('video') ?? undefined\n        }\n\n        if (videoRef.value && currentTime.value > 0) {\n          videoRef.value.currentTime = currentTime.value\n        }\n      })\n    })\n\n    provide(\n      VIDEO_STATE,\n      reactive({\n        placeId,\n        iconScale,\n        addShortcut\n      })\n    )\n\n    useListener(videoRef, 'canplay', () => {\n      canPlay.value = true\n      duration.value = videoRef.value?.duration ?? 0\n    })\n    useListener(videoRef, 'timeupdate', () => {\n      currentTime.value = videoRef.value?.currentTime ?? 0\n\n      emit('update:time', currentTime.value)\n      emitEvent(props.onTimeChange, currentTime.value)\n    })\n    useListener(videoRef, 'ended', handleEnded)\n    // useListener(videoRef, 'loadeddata', () => {\n    //   loadedData.value = true\n    // })\n    useListener(videoRef, 'enterpictureinpicture', () => {\n      pip.value = true\n      emitEvent(props.onTogglePip, true)\n    })\n    useListener(videoRef, 'leavepictureinpicture', () => {\n      pip.value = false\n      emitEvent(props.onTogglePip, false)\n    })\n\n    expose({\n      currentSrc,\n      playing,\n      currentTime,\n      duration,\n      pip,\n      interacting,\n      stateHidden,\n      wrapper,\n      video,\n      resetMetaState\n    })\n\n    function togglePlaying(value = !playing.value) {\n      if (!canPlay.value) {\n        playing.value = false\n\n        return\n      }\n\n      playing.value = value\n\n      if (playing.value) {\n        hasPlayed.value = true\n        videoRef.value?.play().then()\n      } else {\n        videoRef.value?.pause()\n      }\n\n      wrapper.value?.focus()\n      emitEvent(playing.value ? props.onPlay : props.onPause)\n    }\n\n    function handleEnded() {\n      playing.value = false\n\n      videoRef.value?.pause()\n      emitEvent(props.onEnded)\n    }\n\n    async function togglePip() {\n      if (!pipEnabled || !videoRef.value) return\n\n      if (pip.value) {\n        await document.exitPictureInPicture()\n      } else {\n        await videoRef.value.requestPictureInPicture()\n      }\n    }\n\n    function changeRate(rate: number, dispatch = true) {\n      currentRate.value = rate\n\n      if (videoRef.value) {\n        videoRef.value.playbackRate = rate\n      }\n\n      if (dispatch) {\n        emit('update:playback-rate', rate)\n        emitEvent(props.onRateChange, rate)\n      }\n    }\n\n    function changeTime(time: number, dispatch = true) {\n      currentTime.value = time\n\n      if (videoRef.value && time !== videoRef.value.currentTime) {\n        videoRef.value.currentTime = time\n        time = videoRef.value.currentTime\n      }\n\n      if (dispatch) {\n        emit('update:time', time)\n        emitEvent(props.onTimeChange, time)\n      }\n    }\n\n    function changeVolume(volume: number, dispatch = true) {\n      currentVolume.value = volume\n\n      if (videoRef.value) {\n        videoRef.value.volume = volume\n      }\n\n      if (dispatch) {\n        emit('update:volume', volume)\n        emitEvent(props.onVolumeChange, volume)\n      }\n    }\n\n    function toggleFlip(value = !flipped.value, dispatch = true) {\n      flipped.value = value\n\n      if (dispatch) {\n        emitEvent(props.onToggleFlip, flipped.value)\n      }\n    }\n\n    function onFullChange(full: false | FullScreenType) {\n      nextTick(() => {\n        wrapper.value?.focus()\n        emitEvent(props.onToggleFull, full)\n      })\n    }\n\n    function resetMetaState() {\n      playing.value = false\n      currentTime.value = 0\n      canPlay.value = false\n      duration.value = 0\n      // loadedData.value = false\n      pip.value = false\n      hasPlayed.value = false\n\n      videoRef.value?.pause()\n    }\n\n    function handleInteract() {\n      clearTimeout(timer.interact)\n\n      interacting.value = true\n      timer.interact = setTimeout(() => {\n        interacting.value = false\n      }, 3000)\n    }\n\n    function handlePointerLeave() {\n      clearTimeout(timer.interact)\n      timer.interact = setTimeout(() => {\n        interacting.value = false\n      }, 500)\n    }\n\n    function adjustSrc(amount: number) {\n      const list = srcFullList.value\n\n      if (props.srcList) {\n        currentSrc.value = list[(srcIndex.value + amount + list.length) % list.length]\n        emit('update:src', currentSrc.value)\n      }\n    }\n\n    function playPrev() {\n      adjustSrc(-1)\n      emitEvent(props.onPrev)\n    }\n\n    function playNext() {\n      adjustSrc(1)\n      emitEvent(props.onNext)\n    }\n\n    function toggleFull(type: FullScreenType) {\n      screen.value?.toggle(type)\n    }\n\n    function handleRefresh() {\n      emitEvent(props.onRefresh)\n    }\n\n    function renderPlayPrev() {\n      return (\n        <VideoControl\n          class={nh.be('play-prev')}\n          label={locale.value.playPrev}\n          shortcut={shortcuts.value['play-prev']}\n          disabled={!!props.srcList && !srcIndex.value}\n          onClick={playPrev}\n        >\n          <Icon {...icons.value.playPrev} scale={+(icons.value.playPrev.scale || 1) * iconScale.value}></Icon>\n        </VideoControl>\n      )\n    }\n\n    function renderPlay() {\n      return (\n        <VideoControl\n          class={nh.be('play')}\n          label={playing.value ? locale.value.pause : locale.value.play}\n          shortcut={shortcuts.value.play}\n          disabled={!canPlay.value}\n          onClick={togglePlaying}\n        >\n          <Icon {...playIcon.value} scale={+(playIcon.value.scale || 1) * iconScale.value * 1.16}></Icon>\n        </VideoControl>\n      )\n    }\n\n    function renderPlayNext() {\n      return (\n        <VideoControl\n          class={nh.be('play-next')}\n          label={locale.value.playNext}\n          shortcut={shortcuts.value['play-next']}\n          disabled={!!props.srcList && srcIndex.value === srcFullList.value.length - 1}\n          onClick={playNext}\n        >\n          <Icon {...icons.value.playNext} scale={+(icons.value.playNext.scale || 1) * iconScale.value}></Icon>\n        </VideoControl>\n      )\n    }\n\n    function renderRefresh() {\n      return (\n        <VideoControl\n          class={nh.be('play-refresh')}\n          label={locale.value.refresh}\n          shortcut={shortcuts.value.refresh}\n          onClick={handleRefresh}\n        >\n          <Icon {...icons.value.refresh} scale={+(icons.value.refresh.scale || 1) * iconScale.value}></Icon>\n        </VideoControl>\n      )\n    }\n\n    function renderTimer() {\n      return (\n        <VideoTimer\n          time={currentTime.value}\n          duration={duration.value}\n          disabled={!canPlay.value}\n          onChange={changeTime}\n        ></VideoTimer>\n      )\n    }\n\n    function renderPlaybackRate() {\n      return (\n        <VideoControl\n          class={nh.be('playback-rate')}\n          type='select'\n          value={currentRate.value}\n          options={rateOptions.value}\n          onSelect={(rate: VideoPlaybackRate) => changeRate(rate.value)}\n        ></VideoControl>\n      )\n    }\n\n    function renderVolume() {\n      return <VideoVolume ref={volumeRef} volume={currentVolume.value} onChange={changeVolume}></VideoVolume>\n    }\n\n    function renderFlip() {\n      return (\n        <VideoControl\n          class={nh.be('flip')}\n          label={locale.value.flip}\n          shortcut={shortcuts.value.flip}\n          onClick={toggleFlip}\n        >\n          <Icon {...icons.value.flipX} scale={+(icons.value.flipX.scale || 1) * iconScale.value}></Icon>\n        </VideoControl>\n      )\n    }\n\n    function renderPip() {\n      if (!pipEnabled || !video.value) return null\n\n      return (\n        <VideoControl\n          class={nh.be('pip')}\n          label={pip.value ? locale.value.exitPip : locale.value.requestPip}\n          shortcut={shortcuts.value.pip}\n          disabled={!canPlay.value}\n          onClick={togglePip}\n        >\n          <Icon {...icons.value.pip} scale={+(icons.value.pip.scale || 1) * iconScale.value}></Icon>\n        </VideoControl>\n      )\n    }\n\n    function renderFullWindow() {\n      return (\n        <VideoControl\n          class={nh.be('full-window')}\n          label={full.value === 'window' ? locale.value.fullWindowExit : locale.value.fullWindow}\n          shortcut={shortcuts.value['full-window']}\n          onClick={() => toggleFull('window')}\n        >\n          <Icon {...icons.value.fullWindow} scale={+(icons.value.fullWindow.scale || 1) * iconScale.value}></Icon>\n        </VideoControl>\n      )\n    }\n\n    function renderFullBrowser() {\n      return (\n        <VideoControl\n          class={nh.be('full-browser')}\n          label={full.value === 'browser' ? locale.value.fullScreenExit : locale.value.fullScreen}\n          shortcut={shortcuts.value['full-browser']}\n          onClick={() => toggleFull('browser')}\n        >\n          <Icon {...icons.value.fullScreen} scale={+(icons.value.fullScreen.scale || 1) * iconScale.value}></Icon>\n        </VideoControl>\n      )\n    }\n\n    function renderControl(name: VideoControlConfig) {\n      switch (name) {\n        case 'play-prev':\n          return renderPlayPrev()\n        case 'play':\n          return renderPlay()\n        case 'play-next':\n          return renderPlayNext()\n        case 'refresh':\n          return renderRefresh()\n        case 'timer':\n          return renderTimer()\n        case 'playback-rate':\n          return renderPlaybackRate()\n        case 'volume':\n          return renderVolume()\n        case 'flip':\n          return renderFlip()\n        case 'pip':\n          return renderPip()\n        case 'full-window':\n          return renderFullWindow()\n        case 'full-browser':\n          return renderFullBrowser()\n        default:\n          return createSlotRender(slots, [`control-${name}`, `control${toCapitalCase(name as string)}`])?.(slotParams)\n      }\n    }\n\n    function renderControls() {\n      if (props.noControls) {\n        return (\n          <Progress\n            class={nh.be('progress-line')}\n            percentage={percent.value}\n            stroke-width={1}\n            info-type='none'\n          ></Progress>\n        )\n      }\n\n      return (\n        <div\n          class={{\n            [nh.be('controls')]: true,\n            [nh.bem('controls', 'collapsed')]: hasPlayed.value && !interacting.value\n          }}\n        >\n          <section class={nh.be('controls-top')}>\n            <VideoProgress\n              time={currentTime.value}\n              duration={duration.value}\n              segments={segments.value}\n              onChange={changeTime}\n            ></VideoProgress>\n          </section>\n          <section class={nh.be('controls-bottom')}>\n            <div class={nh.be('controls-left')}>\n              {(props.controlLayout.left ?? videoDefaultControlLayout.left).map(renderControl)}\n            </div>\n            <div class={nh.be('controls-center')}>\n              {(props.controlLayout.center ?? videoDefaultControlLayout.center).map(renderControl)}\n            </div>\n            <div class={nh.be('controls-right')}>\n              {(props.controlLayout.right ?? videoDefaultControlLayout.right).map(renderControl)}\n            </div>\n          </section>\n        </div>\n      )\n    }\n\n    function renderMain() {\n      return (\n        <div class={nh.be('main')}>\n          <div class={[nh.be('player'), flipped.value && nh.bem('player', 'flipped')]} onClick={() => togglePlaying()}>\n            {renderSlot(slots, 'player', {}, () => [\n              <video\n                {...props.videoAttrs}\n                ref={video}\n                class={nh.be('video')}\n                src={currentSrc.value || props.videoAttrs?.src}\n              >\n                {renderSlot(slots, 'default')}\n              </video>\n            ])}\n          </div>\n          {!hasPlayed.value && (props.poster || slots.poster) && (\n            <div class={nh.be('poster')}>\n              {renderSlot(slots, 'poster', {}, () => [<img src={props.poster} alt='' />])}\n            </div>\n          )}\n          <Transition name={nh.bs('state-effect')} onAfterLeave={() => (stateHidden.value = true)}>\n            {canPlay.value && stateShow.value && (\n              <div class={nh.be('state')}>\n                {renderSlot(slots, 'state', { active: stateShow.value }, () => [\n                  <Icon {...stateIcon.value} scale={+(stateIcon.value.scale || 1) * 7}></Icon>\n                ])}\n              </div>\n            )}\n          </Transition>\n          <Transition name={nh.ns('fade')}>\n            {((!canPlay.value && !stateShow.value) || (props.loading && stateHidden.value)) && (\n              <div class={nh.be('loading')}>\n                {renderSlot(slots, 'loading', {}, () => [\n                  <Icon\n                    {...icons.value.loading}\n                    icon={props.loadingIcon || icons.value.loading.icon}\n                    label='loading'\n                    effect={props.loadingEffect || icons.value.loading.effect}\n                    scale={+(stateIcon.value.scale || 1) * 7}\n                  ></Icon>\n                ])}\n              </div>\n            )}\n          </Transition>\n          {renderControls()}\n          {renderSlot(slots, 'extra')}\n        </div>\n      )\n    }\n\n    return () => {\n      return (\n        <FullScreen\n          ref={screen}\n          class={className.value}\n          tabindex='-1'\n          onToggle={onFullChange}\n          onPointermove={handleInteract}\n          onPointerleave={handlePointerLeave}\n        >\n          {{ default: renderMain }}\n        </FullScreen>\n      )\n    }\n  }\n})\n"
    }
  ],
  "dependencies": ["@pocui/config", "@pocui/utils", "vue", "@pocui/hooks"],
  "registryDependencies": [
    "video.scss",
    "full-screen",
    "icon",
    "option",
    "tooltip",
    "resize-observer",
    "slider",
    "input",
    "progress"
  ],
  "categories": ["display"],
  "meta": { "isReferenceOnly": false }
}
