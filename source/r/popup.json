{
  "name": "popup",
  "type": "registry:component",
  "description": "弹出框组件，用于在页面中创建模态或非模态的弹出内容。",
  "files": [
    {
      "target": "components/popup/index.ts",
      "content": "import Popup from './popup.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Popup }\nexport type PopupExposed = ComponentPublicInstance & InstanceType<typeof Popup>\n\nexport type { PopupPlacement } from './symbol'\n"
    },
    {
      "target": "components/popup/popup-item.vue",
      "content": "<script setup lang=\"ts\">\nimport { Renderer } from '@/components/renderer'\n\nimport { computed, inject, nextTick, onMounted, ref } from 'vue'\n\nimport { classProp, useNameHelper, useZIndex } from '@pocui/config'\nimport { noop } from '@pocui/utils'\n\nimport { DELETE_HANDLER } from './symbol'\n\nimport type { PropType } from 'vue'\n\nimport type { PopupItemState } from './symbol'\n\ndefineOptions({ name: 'PopupItem',\n  description:'弹出项组件，作为弹出框的子项，管理单个弹出内容的生命周期。',\n  categories: ['feedback'] })\n\nconst props = defineProps({\n  state: {\n    type: Object as PropType<PopupItemState>,\n    default: () => ({})\n  },\n  transitionName: {\n    type: String,\n    default: null\n  },\n  innerClass: {\n    type: classProp,\n    default: null\n  }\n})\n\nconst emit = defineEmits(['enter', 'leave'])\ndefineSlots<{\n  default(props: PopupItemState): any\n}>()\n\nconst handleDelete = inject(DELETE_HANDLER, noop)\nconst nh = useNameHelper('popup')\nconst getIndex = useZIndex()\n\nconst wrapper = ref<HTMLElement>()\n\nconst transition = computed(() => props.transitionName || nh.ns('popup-top'))\n\nonMounted(() => {\n  nextTick(() => {\n    const state = props.state\n\n    if (state && wrapper.value) {\n      state.height = wrapper.value.offsetHeight\n    }\n  })\n})\n</script>\n\n<template>\n  <Transition appear :name=\"transition\" @after-leave=\"handleDelete(state.key)\">\n    <div\n      v-show=\"state.visible\"\n      ref=\"wrapper\"\n      :class=\"nh.be('item')\"\n      :style=\"{ zIndex: getIndex() }\"\n      :poc-index=\"state.key\"\n      @pointerenter=\"emit('enter')\"\n      @pointerleave=\"emit('leave')\"\n    >\n      <div :class=\"[nh.be('item-inner'), innerClass]\">\n        <slot v-bind=\"state\">\n          <Renderer v-if=\"typeof state.renderer === 'function'\" :renderer=\"state.renderer\"></Renderer>\n          <template v-else>\n            {{ state.content }}\n          </template>\n        </slot>\n      </div>\n    </div>\n  </Transition>\n</template>\n"
    },
    {
      "target": "components/popup/popup.vue",
      "content": "<script setup lang=\"ts\">\nimport { computed, provide, reactive, ref, watch } from 'vue'\n\nimport { classProp, useNameHelper } from '@pocui/config'\nimport { getGlobalCount, isFunction, noop } from '@pocui/utils'\n\nimport PopupItem from './popup-item.vue'\n\nimport { DELETE_HANDLER, popupPlacements } from './symbol'\n\nimport type { CSSProperties } from 'vue'\n\nimport type { Key, PopupItemState, PopupPlacement } from './symbol'\n\ntype QueueState =\n  | {\n    type: 'add',\n    param: Record<string, unknown>\n  }\n  | {\n    type: 'clear',\n    param: Key\n  }\n\ndefineOptions({ name: 'Popup',\n  description:'弹出框组件，用于在页面中创建模态或非模态的弹出内容。',\n  categories: ['feedback'] })\n\nconst props = defineProps({\n  transitionName: {\n    type: String,\n    default: null\n  },\n  innerClass: {\n    type: classProp,\n    default: null\n  },\n  startOffset: {\n    type: Number,\n    default: 30\n  },\n  placement: {\n    default: 'top-right' as PopupPlacement,\n    validator: (value: PopupPlacement) => popupPlacements.includes(value)\n  },\n  itemOffset: {\n    type: Number,\n    default: 16\n  },\n  itemType: {\n    type: Function\n  }\n})\n\ndefineSlots<{ item(props: PopupItemState): any }>()\n\nconst nh = useNameHelper('popup')\nconst items = ref<PopupItemState[]>([])\nconst queue: QueueState[] = []\n\nconst wrapper = ref<HTMLElement>()\n\nlet pending = false\n\nconst placementArray = computed(() => {\n  return props.placement.split('-') as ['top' | 'bottom', 'right' | 'center' | 'left']\n})\nconst transition = computed(() => props.transitionName || nh.ns('popup-top'))\n\nwatch(\n  () => props.startOffset,\n  (value, prevValue) => {\n    items.value.forEach(item => {\n      item.verticalPosition += value - prevValue\n    })\n  }\n)\n\nprovide(DELETE_HANDLER, deleteItem)\n\ndefineExpose({\n  items,\n  wrapper,\n  add,\n  remove,\n  has,\n  find,\n  clear\n})\n\nfunction getItemStyle(item: PopupItemState) {\n  const [verticalStyle, horizontalStyle] = placementArray.value\n  const style: CSSProperties = { [verticalStyle]: `${item.verticalPosition}px` }\n\n  if (horizontalStyle === 'center') {\n    style.left = '50%'\n    style.transform = 'translateX(-50%)'\n  } else {\n    style[horizontalStyle] = '24px'\n  }\n\n  const zIndex = parseInt(item.zIndex as string)\n\n  if (!Number.isNaN(zIndex)) {\n    style.zIndex = zIndex\n  }\n\n  return style\n}\n\nfunction add(options: Record<string, any>) {\n  return new Promise<Key>(resolve => {\n    const onOpen = isFunction(options.onOpen) ? options.onOpen : noop\n\n    options.onOpen = (key: Key) => {\n      resolve(key)\n      onOpen()\n    }\n\n    queue.push({\n      type: 'add',\n      param: options\n    })\n\n    if (!pending) {\n      pending = true\n      queueOut()\n    }\n  })\n}\n\nfunction remove(key: Key) {\n  return new Promise<boolean>(resolve => {\n    const item = find(key)\n\n    if (!item) return resolve(false)\n\n    const onClose = isFunction(item.onClose) ? item.onClose : noop\n\n    item.onClose = (result: boolean) => {\n      resolve(result)\n      onClose(result)\n    }\n\n    queue.push({\n      type: 'clear',\n      param: key\n    })\n\n    if (!pending) {\n      pending = true\n      queueOut()\n    }\n  })\n}\n\nfunction queueOut() {\n  if (queue.length) {\n    const state = queue.shift()!\n\n    if (state.type === 'add') {\n      renderItem(state.param)\n    } else {\n      removeItem(state.param)\n    }\n\n    requestAnimationFrame(queueOut)\n  } else {\n    pending = false\n  }\n}\n\nfunction renderItem(options: Record<string, any>) {\n  let item = options.key ? find(options.key as Key) : null\n\n  if (!item?.visible) {\n    const index = getGlobalCount()\n    const key = (options.key as Key) ?? nh.bs(`${index}`)\n\n    let currentVertical = props.startOffset\n\n    items.value.forEach(existingItem => {\n      if (existingItem.visible) {\n        currentVertical += existingItem.height + props.itemOffset\n      }\n    })\n\n    item = reactive(\n      Object.assign(\n        {\n          key,\n          content: '',\n          closable: false,\n          onOpen: noop,\n          onClose: noop,\n          onEnter: noop,\n          onLeave: noop\n        },\n        options,\n        {\n          height: 0,\n          visible: true,\n          verticalPosition: currentVertical\n        }\n      )\n    )\n\n    items.value.push(item)\n  }\n\n  // 使用 options 上的回调以防止重复 key 时指向不正确\n  isFunction(options.onOpen) && options.onOpen(item.key)\n}\n\nfunction removeItem(key: Key) {\n  const index = items.value.findIndex(item => item.key === key)\n\n  if (~index) {\n    const item = items.value[index]\n    const removeHeight = item.height\n\n    item.visible = false\n\n    for (let i = index + 1, len = items.value.length; i < len; ++i) {\n      items.value[i].verticalPosition -= removeHeight + props.itemOffset\n    }\n\n    // 关闭回调\n    isFunction(item.onClose) && item.onClose(true)\n  }\n}\n\nfunction deleteItem(key: Key) {\n  const index = items.value.findIndex(item => item.key === key)\n\n  if (~index) {\n    items.value.splice(index, 1)\n  }\n}\n\nfunction has(key: Key) {\n  return !~items.value.findIndex(item => item.key === key)\n}\n\nfunction find(key: Key) {\n  return items.value.find(item => item.key === key)\n}\n\nfunction clear() {\n  queue.length = 0\n  items.value = []\n}\n\nfunction enterItem(item: PopupItemState) {\n  isFunction(item.onEnter) && item.onEnter()\n}\n\nfunction leaveItem(item: PopupItemState) {\n  isFunction(item.onLeave) && item.onLeave()\n}\n</script>\n\n<template>\n  <div :class=\"[nh.b(), nh.bm(placement)]\">\n    <PopupItem\n      v-for=\"item in items\"\n      :key=\"item.key\"\n      :state=\"item\"\n      :transition-name=\"transition\"\n      :inner-class=\"innerClass\"\n      :style=\"getItemStyle(item)\"\n      @enter=\"enterItem(item)\"\n      @leave=\"leaveItem(item)\"\n    >\n      <template #default=\"itemData\">\n        <slot name=\"item\" v-bind=\"itemData\"></slot>\n      </template>\n    </PopupItem>\n  </div>\n</template>\n"
    },
    {
      "target": "components/popup/symbol.ts",
      "content": "import type { InjectionKey } from 'vue'\n\nexport type Key = string | number\nexport type PopupPlacement =\n  | 'top-right'\n  | 'top-center'\n  | 'top-left'\n  | 'bottom-right'\n  | 'bottom-center'\n  | 'bottom-left'\n\nexport interface PopupItemState extends Record<string, unknown> {\n  key: Key,\n  content: string,\n  closable: boolean,\n  height: number,\n  visible: boolean,\n  verticalPosition: number,\n  type?: string,\n  className?: any,\n  style?: any,\n  icon?: Record<string, any> | (() => any),\n  iconColor?: string,\n  onOpen: (key: Key) => void,\n  onClose: (result: boolean) => void,\n  onEnter: () => void,\n  onLeave: () => void\n}\n\nexport const DELETE_HANDLER: InjectionKey<(key: Key) => void> = Symbol('DELETE_HANDLER')\n\nexport const popupPlacements = Object.freeze<PopupPlacement[]>([\n  'top-right',\n  'top-center',\n  'top-left',\n  'bottom-right',\n  'bottom-center',\n  'bottom-left'\n])\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/utils"],
  "registryDependencies": ["renderer", "popup.scss"],
  "categories": ["feedback"],
  "meta": { "isReferenceOnly": false }
}
