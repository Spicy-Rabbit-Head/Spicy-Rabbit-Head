{
  "name": "cascader",
  "type": "registry:component",
  "description": "当需要从一组相关联的数据集合进行一系列选择时使用，常用于在选择省市区、分类的事物等。",
  "files": [
    {
      "target": "components/cascader/cascader-panel.vue",
      "content": "<script lang=\"ts\">\nimport { Checkbox } from '@/components/checkbox'\nimport { Icon } from '@/components/icon'\nimport { Option } from '@/components/option'\n\nimport { VirtualList } from '@/components/virtual-list'\n\nimport { defineComponent, onBeforeUnmount, onMounted, ref, watch } from 'vue'\n\nimport { useIcons, useNameHelper } from '@pocui/config'\n\nimport { useModifier } from '@pocui/hooks'\nimport { boundRange, decide, isNullish } from '@pocui/utils'\n\nimport type { PropType, SlotsType } from 'vue'\nimport type { VirtualListExposed } from '@/components/virtual-list'\n\nimport type { CascaderOptionState } from './symbol'\n\nexport default defineComponent({\n  name: 'CascaderPanel',\n  description: '级联选择的选项面板，通常由 Cascader 组件使用。',\n  categories: ['form'],\n  components: {\n    Checkbox,\n    Icon,\n    Option,\n    VirtualList\n  },\n  props: {\n    options: {\n      type: Array as PropType<CascaderOptionState[]>,\n      default: () => []\n    },\n    openedId: {\n      type: Number,\n      default: null\n    },\n    values: {\n      type: Array as PropType<string[]>,\n      default: () => []\n    },\n    ready: {\n      type: Boolean,\n      default: false\n    },\n    multiple: {\n      type: Boolean,\n      default: false\n    },\n    checkIcon: {\n      type: Object,\n      default: null\n    },\n    isAsync: {\n      type: Boolean,\n      default: false\n    },\n    merged: {\n      type: Boolean,\n      default: false\n    },\n    noCascaded: {\n      type: Boolean,\n      default: false\n    },\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    labeledBy: {\n      type: String,\n      default: undefined\n    }\n  },\n  emits: ['select', 'check', 'hover', 'open', 'back', 'close'],\n  slots: Object as SlotsType<{\n    default(props: {\n      option: CascaderOptionState,\n      index: number,\n      selected: boolean,\n      canCheck: boolean,\n      hasChild: boolean\n    }): any,\n    label(props: {\n      option: CascaderOptionState,\n      index: number,\n      selected: boolean,\n      canCheck: boolean,\n      hasChild: boolean,\n      handleSelect(option: CascaderOptionState, index: number): void\n    }): any\n  }>,\n  setup(props, { emit }) {\n    const nh = useNameHelper('cascader')\n    const icons = useIcons()\n    const currentHitting = ref(-1)\n\n    const list = ref<VirtualListExposed>()\n\n    const { target: wrapper } = useModifier({\n      passive: false,\n      onKeyDown: (event, modifier) => {\n        if (modifier.escape) {\n          emit('close')\n          return\n        }\n\n        decide(\n          [\n            [\n              () => modifier.up || modifier.down,\n              () => {\n                if (currentHitting.value < 0) {\n                  currentHitting.value = props.options.findIndex(isSelected)\n\n                  if (currentHitting.value < 0) {\n                    currentHitting.value = 0\n                  }\n\n                  return\n                }\n\n                currentHitting.value = boundRange(\n                  findEnabledIndex(currentHitting.value + (modifier.up ? -1 : 1), modifier.up ? -1 : 1),\n                  0,\n                  props.options.length - 1\n                )\n                ensureOptionInView(currentHitting.value, modifier.up ? 'top' : 'bottom')\n              }\n            ],\n            [\n              () => modifier.left || modifier.right,\n              () => {\n                if (modifier.right) {\n                  const option = props.options[currentHitting.value]\n\n                  if (option && hasChildren(option)) {\n                    emit('open', option)\n                  }\n                } else {\n                  emit('back')\n                }\n              }\n            ],\n            [\n              () => modifier.enter || modifier.space,\n              () => {\n                event.stopPropagation()\n\n                const option = props.options[currentHitting.value]\n\n                if (option) {\n                  if (props.multiple) {\n                    handleToggleCheck(option)\n                  } else {\n                    handleSelect(option, currentHitting.value)\n                  }\n                }\n              }\n            ]\n          ],\n          {\n            beforeMatchAny: () => event.preventDefault(),\n            afterMatchAny: modifier.resetAll\n          }\n        )\n      }\n    })\n\n    let listHeight = 0\n    let hoverTimer: ReturnType<typeof setTimeout>\n\n    watch([() => props.ready, () => props.options], () => {\n      requestAnimationFrame(computeListHeight)\n\n      if (props.ready) {\n        list.value?.refresh()\n        currentHitting.value = props.options.findIndex(isSelected)\n      } else {\n        currentHitting.value = -1\n      }\n    })\n\n    onMounted(() => {\n      requestAnimationFrame(computeListHeight)\n    })\n    onBeforeUnmount(handleMouseLeave)\n\n    function hasChildren(option: CascaderOptionState) {\n      return !!(option.hasChild || option.children?.length)\n    }\n\n    function isSelected(option: CascaderOptionState) {\n      return (hasChildren(option) && option.id === props.openedId) || props.values.includes(option.fullValue)\n    }\n\n    function isCheckboxDisabled(option: CascaderOptionState) {\n      return (\n        option.disabled ||\n        (!props.merged && props.multiple && props.isAsync && hasChildren(option) && !option.childrenLoaded)\n      )\n    }\n\n    function handleSelect(option: CascaderOptionState, index: number | undefined) {\n      if (option.disabled || isNullish(index)) return\n\n      currentHitting.value = index\n\n      if (props.multiple || props.noCascaded) {\n        hasChildren(option) ? emit('select', option) : handleToggleCheck(option)\n      } else {\n        emit('select', option)\n      }\n    }\n\n    function handleToggleCheck(option: CascaderOptionState) {\n      !isCheckboxDisabled(option) && emit('check', option)\n    }\n\n    function handleMouseEnter(option: CascaderOptionState) {\n      clearTimeout(hoverTimer)\n\n      hoverTimer = setTimeout(() => {\n        !option.disabled && emit('hover', option)\n      }, 100)\n    }\n\n    function handleMouseLeave() {\n      clearTimeout(hoverTimer)\n    }\n\n    function computeListHeight() {\n      const el = list.value?.wrapper\n\n      if (el) {\n        const style = getComputedStyle(el)\n        const paddingTop = parseInt(style.paddingTop)\n        const paddingBottom = parseInt(style.paddingBottom)\n\n        listHeight = el.offsetHeight - paddingTop - paddingBottom\n      }\n    }\n\n    function queryEnabledIndex(index: number, step: number) {\n      const options = props.options\n      step = step / Math.abs(step)\n\n      while (options[index]?.disabled) {\n        index += step\n\n        if (index < 0 || index >= options.length) break\n      }\n\n      return index\n    }\n\n    function findEnabledIndex(index: number, sign: 1 | -1 = 1) {\n      const options = props.options\n\n      if (options[index]?.disabled) {\n        index = queryEnabledIndex(index, sign)\n\n        if (sign > 0 ? index >= options.length : index < 0) {\n          index = queryEnabledIndex(index, -sign)\n\n          // 全禁用\n          if (sign > 0 ? index < 0 : index >= options.length) index = -1\n        }\n      }\n\n      return index\n    }\n\n    function ensureOptionInView(index: number, direction: 'top' | 'bottom') {\n      const option = props.options[index]\n      const optionHeight = 32\n\n      if (!option || !list.value) return\n\n      if (direction === 'bottom') {\n        const target = (index + 1) * optionHeight\n\n        if (list.value.scrollOffset + listHeight < target) {\n          list.value.scrollTo(target - listHeight)\n        }\n      } else {\n        const target = index * optionHeight\n\n        if (list.value.scrollOffset > target) {\n          list.value.scrollTo(target)\n        }\n      }\n    }\n\n    return {\n      nh,\n      icons,\n      currentHitting,\n\n      wrapper,\n      list,\n\n      hasChildren,\n      isSelected,\n      isCheckboxDisabled,\n      handleSelect,\n      handleToggleCheck,\n      handleMouseEnter,\n      handleMouseLeave,\n      computeListHeight\n    }\n  }\n})\n</script>\n\n<template>\n  <div\n    ref=\"wrapper\"\n    :class=\"nh.be('panel')\"\n    tabindex=\"-1\"\n    :aria-labelledby=\"labeledBy\"\n    @mouseleave=\"handleMouseLeave\"\n  >\n    <VirtualList\n      ref=\"list\"\n      inherit\n      :items=\"options\"\n      :item-size=\"32\"\n      height=\"100%\"\n      id-key=\"id\"\n      :items-attrs=\"{\n        class: [\n          nh.be('options'),\n          multiple ? nh.bem('options', 'multiple') : null,\n          noCascaded ? nh.bem('options', 'no-cascaded') : null\n        ],\n        role: 'listbox',\n        ariaMultiselectable: multiple\n      }\"\n      @resize=\"computeListHeight\"\n    >\n      <template #default=\"{ item, index }\">\n        <Option\n          :class=\"{\n            [nh.ns('option--error')]: item.error\n          }\"\n          :value=\"item.value\"\n          :label=\"item.label\"\n          :disabled=\"item.disabled\"\n          :selected=\"isSelected(item)\"\n          :hitting=\"index === currentHitting\"\n          @select=\"handleSelect(item, index)\"\n          @mouseenter=\"handleMouseEnter(item)\"\n        >\n          <slot\n            :option=\"item\"\n            :index=\"index\"\n            :selected=\"isSelected(item)\"\n            :can-check=\"isCheckboxDisabled(item)\"\n            :has-child=\"hasChildren(item)\"\n          >\n            <Checkbox\n              v-if=\"multiple || noCascaded\"\n              inherit\n              :class=\"nh.be('checkbox')\"\n              :checked=\"item.checked\"\n              :control=\"hasChildren(item)\"\n              :partial=\"item.partial\"\n              :disabled=\"isCheckboxDisabled(item)\"\n              size=\"small\"\n              @click.prevent.stop=\"handleToggleCheck(item)\"\n            ></Checkbox>\n            <span :class=\"nh.be('label')\">\n              <slot\n                name=\"label\"\n                :option=\"item\"\n                :index=\"index\"\n                :selected=\"isSelected(item)\"\n                :can-check=\"isCheckboxDisabled(item)\"\n                :has-child=\"hasChildren(item)\"\n                :handle-select=\"() => handleSelect(item, index)\"\n              >\n                {{ item.label }}\n              </slot>\n            </span>\n            <div :class=\"nh.be('icon')\">\n              <Icon v-if=\"item.loading\" v-bind=\"icons.loading\"></Icon>\n              <Icon v-else-if=\"item.error\" v-bind=\"icons.refresh\"></Icon>\n              <template v-else-if=\"hasChildren(item)\">\n                <Icon v-bind=\"icons.angleRight\"></Icon>\n              </template>\n              <Icon\n                v-else-if=\"!multiple && !noCascaded && checkIcon && values.includes(item.fullValue)\"\n                v-bind=\"icons.check\"\n                :icon=\"checkIcon || icons.check.icon\"\n              ></Icon>\n            </div>\n          </slot>\n        </Option>\n      </template>\n    </VirtualList>\n  </div>\n</template>\n"
    },
    {
      "target": "components/cascader/cascader.vue",
      "content": "<script lang=\"ts\">\nimport { useFieldStore } from '@/components/form'\nimport { Icon } from '@/components/icon'\nimport { NativeScroll } from '@/components/native-scroll'\nimport { Overflow } from '@/components/overflow'\n\nimport { Popper } from '@/components/popper'\nimport { Tag } from '@/components/tag'\nimport { Tooltip } from '@/components/tooltip'\n\nimport { computed, defineComponent, nextTick, onBeforeUpdate, reactive, ref, toRef, watch, watchEffect } from 'vue'\n\nimport {\n  createIconProp,\n  createSizeProp,\n  createStateProp,\n  emitEvent,\n  useIcons,\n  useLocale,\n  useNameHelper,\n  useProps\n} from '@pocui/config'\nimport { placementWhileList, useClickOutside, useHover, usePopper } from '@pocui/hooks'\nimport {\n  flatTree,\n  getLast,\n  isNullish,\n  isPromise,\n  isString,\n  toAttrValue,\n  transformTree\n} from '@pocui/utils'\n\nimport CascaderPanel from './cascader-panel.vue'\nimport { cascaderProps } from './props'\n\nimport type { SlotsType } from 'vue'\n\nimport type { PopperExposed } from '@/components/popper'\nimport type { CascaderKeyConfig, CascaderOptionState, CascaderValue, Data } from './symbol'\n\ntype ChangeListener = (value: CascaderValue, data: Data[] | Data[][]) => void\n\nconst ID_KEY = Symbol('ID_KEY')\nconst PARENT_KEY = Symbol('PARENT_KEY')\n\nconst defaultKeyConfig: Required<CascaderKeyConfig> = {\n  value: 'value',\n  label: 'label',\n  children: 'children',\n  disabled: 'disabled',\n  hasChild: 'hasChild'\n}\n\nexport default defineComponent({\n  name: 'Cascader',\n  description: '当需要从一组相关联的数据集合进行一系列选择时使用，常用于在选择省市区、分类的事物等。',\n  categories: ['form'],\n  components: {\n    CascaderPanel,\n    Icon,\n    NativeScroll,\n    Overflow,\n    Popper,\n    Tag,\n    Tooltip\n  },\n  props: cascaderProps,\n  emits: ['update:value', 'update:visible'],\n  slots: Object as SlotsType<{\n    control(): any,\n    default(props: {\n      option: CascaderOptionState,\n      index: number,\n      selected: boolean,\n      canCheck: boolean,\n      hasChild: boolean\n    }): any,\n    suffix(): any,\n    prefix(): any,\n    empty(): any,\n    label(props: {\n      option: CascaderOptionState,\n      index: number,\n      selected: boolean,\n      canCheck: boolean,\n      hasChild: boolean\n    }): any\n  }>,\n  setup(_props, { emit, slots }) {\n    const { idFor, labelId, state, disabled, loading, size, validateField, clearField, getFieldValue, setFieldValue } =\n      useFieldStore<CascaderValue>(() => reference.value?.focus())\n\n    const nh = useNameHelper('cascader')\n    const props = useProps('cascader', _props, {\n      size: createSizeProp(size),\n      state: createStateProp(state),\n      locale: null,\n      value: {\n        default: () => getFieldValue(),\n        static: true\n      },\n      visible: {\n        default: false,\n        static: true\n      },\n      options: {\n        default: () => [],\n        static: true\n      },\n      placeholder: null,\n      prefix: createIconProp(),\n      prefixColor: '',\n      suffix: createIconProp(),\n      suffixColor: '',\n      noCascaded: false,\n      multiple: false,\n      disabled: () => disabled.value,\n      clearable: false,\n      placement: {\n        default: 'bottom-start',\n        validator: value => placementWhileList.includes(value)\n      },\n      transfer: false,\n      staticSuffix: false,\n      noSuffix: false,\n      transitionName: () => nh.ns('drop'),\n      outsideClose: true,\n      keyConfig: () => ({}),\n      separator: {\n        default: '/',\n        validator: value => value.length === 1\n      },\n      hoverTrigger: false,\n      maxTagCount: 0,\n      briefLabel: false,\n      noRestTip: false,\n      onAsyncLoad: {\n        default: null,\n        isFunc: true\n      },\n      mergeTags: false,\n      tagType: null,\n      emptyText: null,\n      loading: () => loading.value,\n      loadingIcon: createIconProp(),\n      loadingLock: false,\n      loadingEffect: null,\n      transparent: false,\n      popperAlive: null\n    })\n\n    const icons = useIcons()\n    const locale = useLocale('select', toRef(props, 'locale'))\n\n    const currentVisible = ref(props.visible)\n    const currentValues = ref<string[]>([])\n    const currentLabels = ref<string[]>([])\n    const mergedValues = ref<string[]>([])\n    const mergedLabels = ref<string[]>([])\n    const isPopperShow = ref(false)\n    const placement = toRef(props, 'placement')\n    const transfer = toRef(props, 'transfer')\n\n    const emittedValue = ref<CascaderValue | null>(null)\n    const optionTree = ref<CascaderOptionState[]>(null!)\n    const isAsyncLoad = computed(() => typeof props.onAsyncLoad === 'function')\n    const usingMerged = computed(() => props.mergeTags && !props.noCascaded)\n    const templateValues = computed(() => (usingMerged.value ? mergedValues.value : currentValues.value))\n    const templateLabels = computed(() => (usingMerged.value ? mergedLabels.value : currentLabels.value))\n\n    let optionList: CascaderOptionState[] = null!\n    let optionIdMap: Map<number, CascaderOptionState> = null!\n    let optionValueMap: Map<string, CascaderOptionState> = null!\n    let outsideClosed = false\n    let prevClosedId = -1\n    let flattedOptions: Record<any, any>[]\n\n    const updateTrigger = ref(0)\n\n    watchEffect(() => {\n      /* eslint-disable @typescript-eslint/no-unused-expressions */\n      props.keyConfig.value\n      props.keyConfig.label\n      props.keyConfig.disabled\n      props.keyConfig.hasChild\n      props.separator\n      isAsyncLoad.value\n\n      flattedOptions = flatTree(props.options as Record<any, any>[], {\n        keyField: ID_KEY,\n        parentField: PARENT_KEY,\n        childField: props.keyConfig.children ?? defaultKeyConfig.children,\n        forceInject: true\n      })\n\n      updateTrigger.value++\n    })\n\n    watch(updateTrigger, initOptionStates, { immediate: true })\n\n    function initOptionStates() {\n      const separator = props.separator\n      const isAsync = isAsyncLoad.value\n\n      optionList = createOptionStates(flattedOptions)\n      optionIdMap = new Map()\n      optionValueMap = new Map()\n\n      for (let i = 0, len = optionList.length; i < len; ++i) {\n        const option = optionList[i]\n\n        initOptionFull(option, separator)\n        optionIdMap.set(option.id, option)\n        optionValueMap.set(option.fullValue, option)\n\n        if (isAsync) {\n          option.childrenLoaded = queryChildrenLoaded(option)\n        }\n      }\n\n      optionTree.value = transformTree(optionList)\n      initValueAndLabel(emittedValue.value)\n    }\n\n    const openedIds = ref<number[]>([])\n    const optionsList = computed(() => {\n      return [optionTree.value, ...openedIds.value.map(id => optionIdMap.get(id)?.children).filter(Boolean)]\n    })\n\n    const wrapper = useClickOutside(handleClickOutside)\n    const popper = ref<PopperExposed>()\n    const { reference, transferTo, updatePopper } = usePopper({\n      placement,\n      transfer,\n      wrapper,\n      popper: computed(() => popper.value?.wrapper),\n      isDrop: true\n    })\n    const { isHover } = useHover(reference)\n\n    const panelElList = ref<InstanceType<typeof CascaderPanel>[]>([])\n    const restTagCount = ref(0)\n    const restTipShow = ref(false)\n    const selectorWidth = ref(0)\n\n    const className = computed(() => {\n      return {\n        [nh.b()]: true,\n        [nh.ns('input-vars')]: true,\n        [nh.bs('vars')]: true,\n        [nh.in()]: props.inherit,\n        [nh.bm('multiple')]: props.multiple,\n        [nh.bm('responsive')]: props.multiple && props.maxTagCount <= 0\n      }\n    })\n    const readonly = computed(() => props.loading && props.loadingLock)\n    const selectorClass = computed(() => {\n      const baseCls = nh.be('selector')\n\n      return {\n        [baseCls]: true,\n        [`${baseCls}--focused`]: !props.disabled && currentVisible.value,\n        [`${baseCls}--disabled`]: props.disabled,\n        [`${baseCls}--readonly`]: readonly.value,\n        [`${baseCls}--loading`]: props.loading,\n        [`${baseCls}--${props.size}`]: props.size !== 'default',\n        [`${baseCls}--${props.state}`]: props.state !== 'default',\n        [`${baseCls}--has-prefix`]: hasPrefix.value,\n        [`${baseCls}--has-suffix`]: !props.noSuffix,\n        [`${baseCls}--transparent`]: props.transparent\n      }\n    })\n    const hasPrefix = computed(() => {\n      return !!(slots.prefix || props.prefix)\n    })\n    const hasValue = computed(() => !!templateValues.value[0])\n    const usingHover = computed(() => props.hoverTrigger && !isAsyncLoad.value)\n    const showClear = computed(() => {\n      return !props.disabled && !readonly.value && props.clearable && isHover.value && hasValue.value\n    })\n\n    watch(\n      () => props.visible,\n      value => {\n        currentVisible.value = value\n      }\n    )\n    watch(currentVisible, async value => {\n      if (value) {\n        restTipShow.value = false\n        selectorWidth.value = wrapper.value?.offsetWidth || 0\n\n        await updatePopper()\n        nextTick(() => {\n          getLast(panelElList.value)?.$el?.focus()\n        })\n      } else {\n        isPopperShow.value = false\n\n        if (reference.value && !outsideClosed) {\n          reference.value.focus()\n        }\n      }\n\n      outsideClosed = false\n    })\n\n    let outsideChanged = false\n\n    watch(emittedValue, () => {\n      outsideChanged = true\n    })\n    watch(\n      () => props.value,\n      value => {\n        if (value !== emittedValue.value || outsideChanged) {\n          emittedValue.value = value\n          initValueAndLabel(value)\n          nextTick(() => {\n            outsideChanged = false\n          })\n        }\n      },\n      { immediate: true }\n    )\n    watch(\n      () => props.briefLabel,\n      brief => {\n        currentLabels.value = currentValues.value\n          .map(value => optionValueMap.get(value)?.[brief ? 'label' : 'fullLabel'] as string)\n          .filter(Boolean)\n      }\n    )\n    watch(isAsyncLoad, value => {\n      if (value) {\n        for (const option of optionIdMap.values()) {\n          option.childrenLoaded = queryChildrenLoaded(option)\n        }\n      }\n    })\n    watch(usingMerged, value => {\n      if (value) {\n        mergedValues.value.length = 0\n        mergedLabels.value.length = 0\n\n        updateMergedProps()\n      }\n\n      if (isAsyncLoad.value) {\n        const originalOptions: CascaderOptionState[] = []\n\n        for (const option of optionIdMap.values()) {\n          if (option.checked) {\n            originalOptions.push(option)\n          }\n\n          if (option.hasChild && !option.children.length && !option.loaded) {\n            option.checked = false\n          }\n        }\n\n        for (let i = 0, len = originalOptions.length; i < len; ++i) {\n          const option = originalOptions[i]\n\n          updateCheckedUpward(option)\n          updateCheckedDown(option)\n        }\n      }\n\n      emitMultipleChange()\n    })\n    watch(\n      () => optionsList.value.length,\n      () => {\n        updatePopper()\n        nextTick(() => {\n          getLast(panelElList.value)?.$el?.focus()\n          prevClosedId = -1\n        })\n      }\n    )\n    watch(\n      () => props.disabled,\n      value => {\n        if (value) {\n          setVisible(false)\n        }\n      }\n    )\n    watch(readonly, value => {\n      if (value) {\n        setVisible(false)\n      }\n    })\n\n    onBeforeUpdate(() => {\n      panelElList.value.length = 0\n    })\n\n    function createOptionStates(rawOptions: Record<string | symbol, any>[]) {\n      const {\n        value: valueKey,\n        label: labelKey,\n        disabled: disabledKey,\n        hasChild: hasChildKey\n      } = { ...defaultKeyConfig, ...props.keyConfig }\n\n      return rawOptions.map(rawOption => {\n        const {\n          [ID_KEY]: id,\n          [PARENT_KEY]: parent,\n          [valueKey]: value,\n          [labelKey]: label,\n          [disabledKey]: disabled,\n          [hasChildKey]: hasChild\n        } = rawOption\n\n        return reactive<CascaderOptionState>({\n          id,\n          parent,\n          value,\n          disabled,\n          hasChild,\n          label: label || String(value),\n          fullValue: '',\n          fullLabel: '',\n          children: [],\n          checked: false,\n          partial: false,\n          loading: false,\n          loaded: false,\n          error: false,\n          childrenLoaded: false,\n          data: rawOption\n        })\n      })\n    }\n\n    function initOptionFull(option: CascaderOptionState, separator: string) {\n      let value = option.value as string\n      let label = option.label\n      let parent = optionIdMap.get(option.parent)\n\n      while (parent) {\n        value = `${parent.value}${separator}${value}`\n        label = `${parent.label}${separator}${label}`\n        parent = optionIdMap.get(parent.parent)\n      }\n\n      option.fullValue = value\n      option.fullLabel = label\n    }\n\n    function queryChildrenLoaded(option: CascaderOptionState) {\n      if (option.hasChild && !option.children?.length) {\n        return option.loaded\n      }\n\n      const loop: CascaderOptionState[] = [...option.children]\n\n      while (loop.length) {\n        const child = loop.shift()!\n\n        if (child.childrenLoaded) continue\n\n        if (child.hasChild && !child.children?.length) {\n          child.childrenLoaded = child.loaded\n\n          if (!child.loaded) return false\n        }\n\n        loop.push(...child.children)\n      }\n\n      return true\n    }\n\n    function updateMergedProps() {\n      const baseValues = isAsyncLoad.value ? currentValues.value.concat(mergedValues.value) : currentValues.value\n      const values = new Set(baseValues)\n      const loop = [...baseValues]\n\n      while (loop.length) {\n        const value = loop.shift()!\n\n        const option = optionValueMap.get(value)\n\n        if (option) {\n          const parent = optionIdMap.get(option.parent)\n\n          if (parent?.checked) {\n            values.delete(value)\n            values.add(parent.fullValue)\n            loop.push(parent.fullValue)\n          }\n        }\n      }\n\n      const briefLabel = props.briefLabel\n\n      mergedValues.value = Array.from(values).filter(value => optionValueMap.has(value))\n      mergedLabels.value = mergedValues.value\n        .map(value => {\n          const option = optionValueMap.get(value)!\n\n          return briefLabel ? option.label : option.fullLabel\n        })\n        .filter(Boolean)\n    }\n\n    function isFlatArray<T extends string | number>(value: T[] | T[][]): value is T[] {\n      return !!value.length && !Array.isArray(value[0])\n    }\n\n    function isComplexArray<T extends string | number>(value: T[] | T[][]): value is T[][] {\n      return !!value.length && Array.isArray(value[0])\n    }\n\n    function initValueAndLabel(value: CascaderValue | null) {\n      const processMerged = () => {\n        if (usingMerged.value) {\n          if (isAsyncLoad.value) {\n            mergedValues.value = Array.from(optionIdMap.values())\n              .filter(option => option.checked)\n              .map(option => option.fullValue)\n          }\n\n          updateMergedProps()\n        }\n      }\n\n      for (const option of optionList) {\n        option.checked = false\n        option.partial = false\n      }\n\n      if (!value?.length) {\n        currentValues.value = []\n        currentLabels.value = []\n        processMerged()\n        return\n      }\n\n      const briefLabel = props.briefLabel\n\n      if (props.multiple) {\n        const normalizedValue = isFlatArray(value) ? [value] : value\n        const valueSet = new Set<string>(normalizedValue.map(v => v.join(props.separator)))\n        const selectedValues: string[] = []\n        const selectedLabels: string[] = []\n        const selectedOptions: CascaderOptionState[] = []\n\n        valueSet.forEach(value => {\n          const option = optionValueMap.get(value)\n\n          if (option) {\n            option.checked = true\n            option.partial = false\n\n            selectedValues.push(value)\n            selectedLabels.push(briefLabel ? option.label : option.fullLabel)\n            selectedOptions.push(option)\n          }\n        })\n\n        if (!props.noCascaded) {\n          const originalOptions = selectedOptions.concat(\n            Array.from(optionIdMap.values()).filter(option => option.disabled && option.checked)\n          )\n\n          for (let i = 0, len = originalOptions.length; i < len; ++i) {\n            const option = originalOptions[i]\n\n            updateCheckedUpward(option)\n            updateCheckedDown(option)\n          }\n        }\n\n        currentValues.value = selectedValues\n        currentLabels.value = selectedLabels\n      } else {\n        const normalizedValue = isComplexArray(value) ? value[0] : value\n        const stringValue = normalizedValue.join(props.separator)\n        const option = optionValueMap.get(stringValue)\n\n        if (option) {\n          currentValues.value = [stringValue]\n          currentLabels.value = [briefLabel ? option.label : option.fullLabel]\n\n          if (props.noCascaded) {\n            option.checked = true\n            option.partial = false\n          }\n        } else {\n          currentValues.value = []\n          currentLabels.value = []\n        }\n      }\n\n      processMerged()\n\n      if (openedIds.value.length) return\n\n      const firstValue = currentValues.value[0]\n\n      if (firstValue) {\n        const option = optionValueMap.get(firstValue)!\n        const ids = [option.id]\n\n        let parent = optionIdMap.get(option.parent)\n\n        while (parent) {\n          ids.push(parent.id)\n          parent = optionIdMap.get(parent.parent)\n        }\n\n        openedIds.value = ids.reverse().slice(0, -1)\n      }\n    }\n\n    function setVisible(visible: boolean) {\n      if (currentVisible.value === visible) return\n\n      currentVisible.value = visible\n\n      emit('update:visible', visible)\n      emitEvent(props.onToggle, visible)\n    }\n\n    async function handlePanelOpen(option: CascaderOptionState, depth: number) {\n      if (!option.hasChild && !option.children?.length) return\n\n      if (isAsyncLoad.value && !option.children?.length && !option.loaded) {\n        option.loading = true\n\n        let result: ReturnType<typeof props.onAsyncLoad>\n\n        try {\n          result = props.onAsyncLoad(option.data)\n          result = isPromise(result) ? await result : result\n        } catch (e) {\n          option.error = true\n          option.loading = false\n          return\n        }\n\n        const rawOptions = result as any[]\n\n        if (!Array.isArray(rawOptions) || !rawOptions.length) {\n          option.hasChild = false\n        } else {\n          const options = createOptionStates(rawOptions)\n          const parentId = option.id\n          const separator = props.separator\n\n          option.children.push(...options)\n\n          let idCount = Math.max(...Array.from(optionIdMap.keys()).map(Number)) + 1\n\n          options.forEach(option => {\n            option.id = idCount++\n            option.parent = parentId\n\n            initOptionFull(option, separator)\n\n            optionIdMap.set(option.id, option)\n            optionValueMap.set(option.fullValue, option)\n          })\n\n          optionList.push(...options)\n        }\n\n        option.loaded = true\n        option.loading = false\n\n        const upstream = queryUpstreamOptions(option)\n        upstream.forEach(option => {\n          option.childrenLoaded = queryChildrenLoaded(option)\n        })\n      }\n\n      if (depth < openedIds.value.length) {\n        openedIds.value = openedIds.value.slice(0, depth)\n      }\n\n      openedIds.value.push(option.id)\n      requestAnimationFrame(() => {\n        getLast(panelElList.value)?.$el?.focus()\n      })\n    }\n\n    function handleOptionSelect(option: CascaderOptionState, depth: number) {\n      if (!option) return\n\n      if (option.hasChild || option.children?.length) {\n        handlePanelOpen(option, depth)\n      } else {\n        handleSingleSelect(option.fullValue)\n      }\n    }\n\n    function queryUpstreamOptions(option: CascaderOptionState) {\n      const options = [option]\n      let parent = optionIdMap.get(option.parent)\n\n      while (parent) {\n        options.push(parent)\n        parent = optionIdMap.get(parent.parent)\n      }\n\n      return options\n    }\n\n    function updateCheckedUpward(originalOption: CascaderOptionState) {\n      let option = originalOption\n\n      while (!isNullish(option.parent)) {\n        const parent = optionIdMap.get(option.parent)\n\n        if (!parent) break\n\n        if (option.checked === parent.checked && option.partial === parent.partial) {\n          break\n        }\n\n        if (option.checked) {\n          parent.checked = parent.children.every((item: CascaderOptionState) => item.disabled || item.checked)\n          parent.partial = !parent.checked\n        } else {\n          parent.checked = false\n          parent.partial = parent.children.some((item: CascaderOptionState) => item.checked || item.partial)\n        }\n\n        option = parent\n      }\n    }\n\n    function updateCheckedDown(originalOption: CascaderOptionState) {\n      const checked = originalOption.checked\n      const partial = originalOption.partial\n\n      const loop = [...originalOption.children]\n\n      let option\n\n      while (loop.length) {\n        option = loop.shift()!\n\n        if (option.disabled) continue\n\n        option.checked = checked\n        option.partial = partial\n\n        if (option.children?.length) {\n          loop.push(...option.children)\n        }\n      }\n    }\n\n    function handleOptionCheck(option: CascaderOptionState) {\n      if (!option) return\n\n      const options = Array.from(optionIdMap.values())\n      const checked = !option.checked\n\n      if (!props.multiple) {\n        for (let i = 0, len = options.length; i < len; ++i) {\n          options[i].checked = false\n        }\n\n        option.checked = checked\n        option.partial = false\n\n        return handleSingleSelect(option.fullValue)\n      }\n\n      option.checked = checked\n      option.partial = false\n\n      if (!props.noCascaded) {\n        const originalOptions = [option].concat(options.filter(option => option.disabled && option.checked))\n\n        for (let i = 0, len = originalOptions.length; i < len; ++i) {\n          const option = originalOptions[i]\n\n          updateCheckedUpward(option)\n          updateCheckedDown(option)\n        }\n      }\n\n      emitEvent(props[checked ? 'onSelect' : 'onCancel'], option.fullValue, option.data)\n      emitMultipleChange()\n    }\n\n    function emitMultipleChange() {\n      const options = Array.from(optionIdMap.values())\n      const selectedOptions = props.noCascaded\n        ? options.filter(option => option.checked)\n        : options.filter(option => option.checked && !(option.hasChild || option.children?.length))\n\n      const selectedValues: string[] = []\n      const selectedLabels: string[] = []\n\n      const values: (string | number)[][] = []\n      const dataList: Data[][] = []\n      const briefLabel = props.briefLabel\n\n      selectedOptions.forEach(option => {\n        selectedValues.push(option.fullValue)\n        selectedLabels.push(briefLabel ? option.label : option.fullLabel)\n\n        const { value, data } = queryArrayMeta(option.fullValue)\n\n        values.push(value)\n        dataList.push(data)\n      })\n\n      currentValues.value = selectedValues\n      currentLabels.value = selectedLabels\n\n      if (usingMerged.value) {\n        if (isAsyncLoad.value) {\n          mergedValues.value = options.filter(option => option.checked).map(option => option.fullValue)\n        }\n\n        updateMergedProps()\n      }\n\n      if (usingMerged.value && isAsyncLoad.value) {\n        values.length = 0\n        dataList.length = 0\n\n        mergedValues.value.forEach(fullValue => {\n          const option = optionValueMap.get(fullValue)\n\n          if (option) {\n            const { value, data } = queryArrayMeta(option.fullValue)\n\n            values.push(value)\n            dataList.push(data)\n          }\n        })\n      }\n\n      emitChangeEvent(values, dataList)\n      nextTick(updatePopper)\n    }\n\n    function handleSingleSelect(fullValue: string) {\n      const option = optionValueMap.get(fullValue)\n\n      if (!option) return\n\n      emitEvent(props.onSelect, fullValue, option.data)\n\n      if (fullValue) {\n        currentValues.value[0] = fullValue\n        currentLabels.value[0] = props.briefLabel ? option.label : option.fullLabel\n      } else {\n        currentValues.value.length = 0\n        currentLabels.value.length = 0\n      }\n\n      const { value, data } = queryArrayMeta(fullValue)\n\n      emitChangeEvent(value, data)\n      setVisible(false)\n    }\n\n    function emitChangeEvent(value: CascaderValue, data: Data[] | Data[][]) {\n      emittedValue.value = value\n\n      nextTick(() => {\n        outsideChanged = false\n\n        emit('update:value', value)\n        setFieldValue(value)\n        emitEvent(props.onChange as ChangeListener, value, data)\n        validateField()\n      })\n    }\n\n    function queryArrayMeta(fullValue: string) {\n      let option = optionValueMap.get(fullValue)!\n\n      if (!option) {\n        return {\n          value: [],\n          data: []\n        }\n      }\n\n      const value = [option.value]\n      const data = [option.data]\n\n      while (option.parent) {\n        const parent = optionIdMap.get(option.parent)\n\n        if (!parent) break\n\n        value.push(parent.value)\n        data.push(parent.data)\n        option = parent\n      }\n\n      return {\n        value: value.reverse(),\n        data: data.reverse()\n      }\n    }\n\n    function toggleVisible(visible = !currentVisible.value) {\n      if (props.disabled || readonly.value) return\n\n      setVisible(visible)\n    }\n\n    function handleClickOutside() {\n      restTipShow.value = false\n      emitEvent(props.onClickOutside)\n\n      if (props.outsideClose && currentVisible.value) {\n        setVisible(false)\n        outsideClosed = true\n        emitEvent(props.onOutsideClose)\n      }\n    }\n\n    function handleClear() {\n      if (props.disabled || readonly.value) return\n\n      if (props.clearable) {\n        const prev = emittedValue.value\n\n        currentValues.value.length = 0\n        currentLabels.value.length = 0\n        mergedValues.value.length = 0\n        mergedLabels.value.length = 0\n        openedIds.value.length = 0\n        emittedValue.value = prev?.length === 0 ? prev : []\n        restTipShow.value = false\n\n        for (const option of optionIdMap.values()) {\n          option.checked = false\n          option.partial = false\n        }\n\n        if (prev?.length !== 0) {\n          emit('update:value', emittedValue.value)\n          emitEvent(props.onChange as ChangeListener, emittedValue.value, [])\n        }\n\n        emitEvent(props.onClear)\n        clearField(emittedValue.value)\n      }\n    }\n\n    function toggleShowRestTip() {\n      if (!currentVisible.value) {\n        restTipShow.value = !restTipShow.value\n      } else {\n        restTipShow.value = false\n      }\n    }\n\n    function handleTipClose(fullValue: string | Record<string, any>) {\n      if (props.disabled || readonly.value || !isString(fullValue)) return\n\n      if (props.multiple) {\n        handleOptionCheck(optionValueMap.get(fullValue)!)\n      } else {\n        handleSingleSelect(fullValue)\n      }\n    }\n\n    function handlePanelKeyOpen(option: CascaderOptionState, depth: number) {\n      handlePanelOpen(option, depth)\n\n      requestAnimationFrame(() => {\n        const panel = getLast(panelElList.value)\n\n        if (panel && panel.currentHitting < 0) {\n          panel.currentHitting = panel.options.findIndex(option => option.id === prevClosedId)\n\n          if (panel.currentHitting < 0) {\n            panel.currentHitting = 0\n          }\n        }\n      })\n    }\n\n    function handlePanelBack() {\n      prevClosedId = openedIds.value.pop()!\n    }\n\n    function handlePanelsEnter() {\n      requestAnimationFrame(() => {\n        isPopperShow.value = true\n      })\n    }\n\n    return {\n      props,\n      nh,\n      icons,\n      locale,\n      idFor,\n      labelId,\n      currentVisible,\n      isPopperShow,\n      currentValues,\n      currentLabels,\n      transferTo,\n      isHover,\n      openedIds,\n      restTagCount,\n      restTipShow,\n      selectorWidth,\n\n      optionsList,\n      className,\n      selectorClass,\n      hasValue,\n      hasPrefix,\n      isAsyncLoad,\n      usingMerged,\n      templateValues,\n      templateLabels,\n      usingHover,\n      showClear,\n\n      wrapper,\n      reference,\n      popper,\n      panelElList,\n\n      toAttrValue,\n      handlePanelOpen,\n      handleOptionSelect,\n      handleOptionCheck,\n      toggleVisible,\n      handleClear,\n      toggleShowRestTip,\n      handleTipClose,\n      handlePanelKeyOpen,\n      handlePanelBack,\n      handlePanelsEnter,\n\n      focus: (options?: FocusOptions) => reference.value?.focus(options),\n      blur: () => reference.value?.blur()\n    }\n  }\n})\n</script>\n\n<template>\n  <div\n    :id=\"idFor\"\n    ref=\"wrapper\"\n    :class=\"className\"\n    role=\"group\"\n    :aria-disabled=\"toAttrValue(props.disabled)\"\n    :aria-expanded=\"toAttrValue(currentVisible)\"\n    aria-haspopup=\"dialog\"\n    :aria-labelledby=\"labelId\"\n    @click=\"toggleVisible()\"\n  >\n    <div\n      ref=\"reference\"\n      :class=\"selectorClass\"\n      tabindex=\"0\"\n      @keydown.space.prevent=\"toggleVisible()\"\n      @keydown.tab=\"toggleVisible(false)\"\n    >\n      <div v-if=\"hasPrefix\" :class=\"[nh.be('icon'), nh.be('prefix')]\" :style=\"{ color: props.prefixColor }\">\n        <slot name=\"prefix\">\n          <Icon :icon=\"props.prefix\"></Icon>\n        </slot>\n      </div>\n      <div :class=\"nh.be('control')\">\n        <slot name=\"control\">\n          <Overflow\n            v-if=\"props.multiple\"\n            inherit\n            :class=\"[nh.be('tags')]\"\n            :items=\"templateValues\"\n            :max-count=\"props.maxTagCount\"\n            @rest-change=\"restTagCount = $event\"\n          >\n            <template #default=\"{ item, index }\">\n              <Tag\n                inherit\n                :class=\"nh.be('tag')\"\n                :type=\"props.tagType\"\n                closable\n                :disabled=\"props.disabled\"\n                @click.stop=\"toggleVisible()\"\n                @close=\"handleTipClose(item)\"\n              >\n                {{ templateLabels[index] }}\n              </Tag>\n            </template>\n            <template #counter=\"{ count }\">\n              <Tag\n                v-if=\"props.noRestTip\"\n                inherit\n                :class=\"[nh.be('tag'), nh.be('counter')]\"\n                :type=\"props.tagType\"\n                :disabled=\"props.disabled\"\n              >\n                {{ `+${count}` }}\n              </Tag>\n              <span v-else>\n                <Tooltip\n                  inherit\n                  :transfer=\"false\"\n                  :visible=\"restTipShow\"\n                  trigger=\"custom\"\n                  placement=\"top-end\"\n                  :tip-class=\"nh.be('rest-tip')\"\n                  @click.stop=\"toggleShowRestTip\"\n                >\n                  <template #trigger>\n                    <Tag\n                      inherit\n                      :class=\"[nh.be('tag'), nh.be('counter')]\"\n                      :type=\"props.tagType\"\n                      :disabled=\"props.disabled\"\n                    >\n                      {{ `+${count}` }}\n                    </Tag>\n                  </template>\n                  <NativeScroll inherit use-y-bar>\n                    <template v-for=\"(item, index) in templateValues\" :key=\"index\">\n                      <Tag\n                        v-if=\"index >= templateValues.length - restTagCount\"\n                        inherit\n                        :class=\"nh.be('tag')\"\n                        closable\n                        :type=\"props.tagType\"\n                        :disabled=\"props.disabled\"\n                        @close=\"handleTipClose(item)\"\n                      >\n                        {{ templateLabels[index] }}\n                      </Tag>\n                    </template>\n                  </NativeScroll>\n                </Tooltip>\n              </span>\n            </template>\n          </Overflow>\n          <template v-else>\n            {{ currentLabels[0] }}\n          </template>\n          <span v-if=\"(props.placeholder ?? locale.placeholder) && !hasValue\" :class=\"nh.be('placeholder')\">\n            {{ props.placeholder ?? locale.placeholder }}\n          </span>\n        </slot>\n      </div>\n      <div\n        v-if=\"!props.noSuffix\"\n        :class=\"[nh.be('icon'), nh.be('suffix')]\"\n        :style=\"{\n          color: props.suffixColor,\n          opacity: showClear || props.loading ? '0%' : ''\n        }\"\n      >\n        <slot name=\"suffix\">\n          <Icon\n            v-if=\"props.suffix\"\n            :icon=\"props.suffix\"\n            :class=\"{\n              [nh.be('arrow')]: !props.staticSuffix\n            }\"\n          ></Icon>\n          <Icon v-else v-bind=\"icons.angleDown\" :class=\"nh.be('arrow')\"></Icon>\n        </slot>\n      </div>\n      <div\n        v-else-if=\"props.clearable || props.loading\"\n        :class=\"[nh.be('icon'), nh.bem('icon', 'placeholder'), nh.be('suffix')]\"\n      ></div>\n      <Transition :name=\"nh.ns('fade')\" appear>\n        <button\n          v-if=\"showClear\"\n          :class=\"[nh.be('icon'), nh.be('clear')]\"\n          type=\"button\"\n          tabindex=\"-1\"\n          :aria-label=\"locale.ariaLabel.clear\"\n          @click.stop=\"handleClear\"\n        >\n          <Icon v-bind=\"icons.clear\"></Icon>\n        </button>\n        <div v-else-if=\"props.loading\" :class=\"[nh.be('icon'), nh.be('loading')]\">\n          <Icon\n            v-bind=\"icons.loading\"\n            :effect=\"props.loadingEffect || icons.loading.effect\"\n            :icon=\"props.loadingIcon || icons.loading.icon\"\n          ></Icon>\n        </div>\n      </Transition>\n    </div>\n    <Popper\n      ref=\"popper\"\n      :class=\"[nh.be('popper'), nh.ns('input-vars'), nh.bs('vars')]\"\n      :visible=\"currentVisible\"\n      :to=\"transferTo\"\n      :transition=\"props.transitionName\"\n      :alive=\"props.popperAlive ?? !transferTo\"\n      @click.stop\n      @enter=\"handlePanelsEnter\"\n    >\n      <div\n        :class=\"{\n          [nh.be('panels')]: true,\n          [nh.bem('panels', 'empty')]: !optionsList[0] || !optionsList[0].length\n        }\"\n      >\n        <template v-if=\"optionsList[0] && optionsList[0].length\">\n          <CascaderPanel\n            v-for=\"(items, index) in optionsList\"\n            :key=\"index\"\n            :ref=\"(panel: any) => panel && panelElList.push(panel)\"\n            :options=\"items\"\n            :opened-id=\"openedIds[index]\"\n            :values=\"currentValues\"\n            :ready=\"isPopperShow\"\n            :multiple=\"props.multiple\"\n            :is-async=\"isAsyncLoad\"\n            :merged=\"usingMerged\"\n            :no-cascaded=\"props.noCascaded\"\n            :labeled-by=\"labelId\"\n            @select=\"handleOptionSelect($event, index)\"\n            @hover=\"usingHover && handlePanelOpen($event, index)\"\n            @check=\"handleOptionCheck($event)\"\n            @open=\"handlePanelKeyOpen($event, index)\"\n            @back=\"handlePanelBack\"\n            @close=\"currentVisible = false\"\n          >\n            <template #default=\"payload\">\n              <slot v-bind=\"payload\"></slot>\n            </template>\n            <template #label=\"payload\">\n              <slot name=\"label\" v-bind=\"payload\"></slot>\n            </template>\n          </CascaderPanel>\n        </template>\n        <div v-else :class=\"nh.be('empty')\" :style=\"{ width: `${selectorWidth}px` }\">\n          <slot name=\"empty\">\n            {{ props.emptyText ?? locale.empty }}\n          </slot>\n        </div>\n      </div>\n    </Popper>\n  </div>\n</template>\n"
    },
    {
      "target": "components/cascader/index.ts",
      "content": "import Cascader from './cascader.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Cascader }\nexport { cascaderProps } from './props'\n\nexport type CascaderExposed = ComponentPublicInstance & InstanceType<typeof Cascader>\n\nexport type { CascaderProps, CascaderCProps } from './props'\nexport type { CascaderKeyConfig } from './symbol'\n"
    },
    {
      "target": "components/cascader/props.ts",
      "content": "import {\n  booleanProp,\n  booleanStringProp,\n  buildProps,\n  eventProp,\n  iconProp,\n  localeProp,\n  sizeProp,\n  stateProp\n} from '@pocui/config'\n\nimport type { IconEffect } from '@/components/icon'\nimport type { TagType } from '@/components/tag'\nimport type { ConfigurableProps } from '@pocui/config'\nimport type { Placement } from '@pocui/hooks'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { CascaderKeyConfig, CascaderValue, Data } from './symbol'\n\ntype ChangeEvent =\n  | ((value: CascaderValue, data: Data[] | Data[][]) => void)\n  | ((value: (string | number)[], data: Data[]) => void)\n  | ((value: string[], data: Data[]) => void)\n  | ((value: number[], data: Data[]) => void)\n  | ((value: (string | number)[][], data: Data[][]) => void)\n  | ((value: string[][], data: Data[][]) => void)\n  | ((value: number[][], data: Data[][]) => void)\n\nexport const cascaderProps = buildProps({\n  size: sizeProp,\n  state: stateProp,\n  locale: localeProp('select'),\n  value: Array as PropType<CascaderValue>,\n  visible: booleanProp,\n  options: Array as PropType<Data[]>,\n  placeholder: String,\n  prefix: iconProp,\n  prefixColor: String,\n  suffix: iconProp,\n  suffixColor: String,\n  noCascaded: booleanProp,\n  multiple: booleanProp,\n  disabled: booleanProp,\n  clearable: booleanProp,\n  placement: String as PropType<Placement>,\n  transfer: booleanStringProp,\n  staticSuffix: booleanProp,\n  noSuffix: booleanProp,\n  transitionName: String,\n  outsideClose: booleanProp,\n  keyConfig: Object as PropType<CascaderKeyConfig>,\n  separator: String,\n  hoverTrigger: booleanProp,\n  maxTagCount: Number,\n  briefLabel: booleanProp,\n  noRestTip: booleanProp,\n  onAsyncLoad: Function as PropType<(data: Data) => any[] | Promise<any[]>>,\n  mergeTags: booleanProp,\n  tagType: String as PropType<TagType>,\n  emptyText: String,\n  loading: booleanProp,\n  loadingIcon: iconProp,\n  loadingLock: booleanProp,\n  loadingEffect: String as PropType<IconEffect>,\n  transparent: booleanProp,\n  popperAlive: booleanProp,\n  onToggle: eventProp<(visible: boolean) => void>(),\n  onSelect: eventProp<(fullValue: string, data: Data) => void>(),\n  onCancel: eventProp<(fullValue: string, data: Data) => void>(),\n  onChange: eventProp<ChangeEvent>(),\n  onClickOutside: eventProp(),\n  onOutsideClose: eventProp(),\n  onClear: eventProp()\n})\n\nexport type CascaderProps = ExtractPropTypes<typeof cascaderProps>\nexport type CascaderCProps = ConfigurableProps<CascaderProps, never, 'onAsyncLoad'>\n"
    },
    {
      "target": "components/cascader/symbol.ts",
      "content": "export type Data = Record<string, any>\nexport type CascaderValue = (string | number)[] | (string | number)[][]\n\nexport interface CascaderKeyConfig {\n  value?: string,\n\n  label?: string,\n\n  children?: string,\n\n  disabled?: string,\n\n  hasChild?: string\n}\n\nexport type CascaderOptionState =\n  | {\n    id: number,\n\n    parent: number,\n\n    value: string | number,\n\n    fullValue: string,\n\n    label: string,\n\n    fullLabel: string,\n\n    children: CascaderOptionState[],\n\n    disabled: boolean,\n\n    hasChild: boolean,\n\n    checked: boolean,\n\n    partial: boolean,\n\n    loading: boolean,\n\n    loaded: boolean,\n\n    error: boolean,\n\n    childrenLoaded: boolean,\n\n    data: Data\n  }\n  | Record<string, any>\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/hooks", "@pocui/utils"],
  "registryDependencies": [
    "checkbox",
    "icon",
    "option",
    "virtual-list",
    "cascader.scss",
    "form",
    "native-scroll",
    "overflow",
    "popper",
    "tag",
    "tooltip"
  ],
  "categories": ["form"],
  "meta": { "isReferenceOnly": false }
}
