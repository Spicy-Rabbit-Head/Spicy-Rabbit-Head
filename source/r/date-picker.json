{
  "name": "date-picker",
  "type": "registry:component",
  "description": "用于选择或输入一个日期。",
  "files": [
    {
      "target": "components/date-picker/date-control.vue",
      "content": "<script setup lang=\"ts\">\nimport { computed, ref } from 'vue'\n\nimport { useNameHelper } from '@pocui/config'\n\nimport { doubleDigits, getLastDayOfMonth } from '@pocui/utils'\n\nimport { handleKeyEnter } from './helper'\n\nimport type { LocaleConfig } from '@pocui/config'\n\nimport type { PropType } from 'vue'\n\nimport type { DateTimeType } from './symbol'\n\ndefineOptions({ name: 'DateControl',\n  description:'顶部快捷控制栏，缩短用户在大跨度日期选择时的操作路径。',\n  categories: ['form'] })\n\nconst props = defineProps({\n  unitType: {\n    type: String as PropType<DateTimeType | ''>,\n    default: ''\n  },\n  enabled: {\n    type: Object as PropType<Record<DateTimeType, boolean>>,\n    default: () => ({})\n  },\n  activated: {\n    type: Object as PropType<Record<DateTimeType, boolean>>,\n    default: () => ({})\n  },\n  dateValue: {\n    type: Object as PropType<Record<DateTimeType, number>>,\n    default: () => ({})\n  },\n  dateSeparator: {\n    type: String,\n    default: '/'\n  },\n  timeSeparator: {\n    type: String,\n    default: ':'\n  },\n  visible: {\n    type: Boolean,\n    default: false\n  },\n  focused: {\n    type: Boolean,\n    default: false\n  },\n  filler: {\n    type: String,\n    default: '-',\n    validator: (value: string) => {\n      return value.length === 1\n    }\n  },\n  steps: {\n    type: Array as PropType<number[]>,\n    default: () => [1, 1, 1]\n  },\n  ctrlSteps: {\n    type: Array as PropType<number[]>,\n    default: () => [5, 5, 5]\n  },\n  labels: {\n    type: Object as PropType<Partial<Record<DateTimeType, string>>>,\n    default: () => ({})\n  },\n  hasError: {\n    type: Boolean,\n    default: false\n  },\n  placeholder: {\n    type: String,\n    default: ''\n  },\n  readonly: {\n    type: Boolean,\n    default: false\n  },\n  labeledBy: {\n    type: String,\n    default: undefined\n  },\n  locale: {\n    type: Object as PropType<LocaleConfig['calendar'] & LocaleConfig['datePicker']>,\n    default: () => ({})\n  }\n})\n\nconst emit = defineEmits(['input', 'plus', 'minus', 'enter', 'cancel', 'unit-focus', 'prev-unit', 'next-unit', 'blur'])\n\nconst nh = useNameHelper('date-picker')\n\nconst wrapper = ref<HTMLElement>()\n\nconst label = computed(() => props.locale.ariaLabel ?? {})\nconst isActivated = computed(() => {\n  return (Object.keys(props.enabled) as DateTimeType[]).every(type => {\n    return !props.enabled[type] || props.activated[type]\n  })\n})\nconst className = computed(() => {\n  return {\n    [nh.be('input')]: true,\n    [nh.bem('input', 'activated')]: isActivated.value,\n    [nh.bem('input', 'error')]: props.hasError\n  }\n})\nconst showTimeUnits = computed(() => {\n  return props.enabled.hour || props.enabled.minute || props.enabled.second\n})\nconst formattedYear = computed(() => {\n  return formatValue('year')\n})\nconst formattedMonth = computed(() => {\n  return formatValue('month')\n})\nconst formattedDate = computed(() => {\n  return formatValue('date')\n})\nconst formattedHour = computed(() => {\n  return formatValue('hour')\n})\nconst formattedMinute = computed(() => {\n  return formatValue('minute')\n})\nconst formattedSecond = computed(() => {\n  return formatValue('second')\n})\nconst maxDateCount = computed(() => {\n  return getLastDayOfMonth(props.dateValue.year, props.dateValue.month)\n})\n\ndefineExpose({\n  isActivated,\n  wrapper,\n  focus: () => {\n    wrapper.value?.focus()\n  },\n  blur: () => {\n    wrapper.value?.blur()\n  }\n})\n\nfunction formatValue(type: DateTimeType) {\n  const isYear = type === 'year'\n  const filler = props.filler\n\n  return props.activated[type]\n    ? isYear\n      ? props.dateValue.year.toString().padStart(4, '0')\n      : doubleDigits(props.dateValue[type])\n    : `${isYear ? `${filler}${filler}` : ''}${filler}${filler}`\n}\n\nfunction getUnitFocusClass(type: DateTimeType) {\n  return props.visible && props.unitType === type ? nh.bem('unit', 'focused') : null\n}\n\nfunction handleInputFocus(type: DateTimeType) {\n  if (props.readonly) return\n\n  emit('unit-focus', type)\n}\n\nfunction handleInput(event: KeyboardEvent) {\n  if (!props.visible) return\n\n  const type = handleKeyEnter(event)\n\n  if (props.readonly) {\n    switch (type) {\n      case 'ok': {\n        emit('enter')\n        break\n      }\n      case 'esc': {\n        emit('cancel')\n        break\n      }\n    }\n\n    return\n  }\n\n  switch (type) {\n    case 'next': {\n      emit('next-unit')\n      break\n    }\n    case 'prev': {\n      emit('prev-unit')\n      break\n    }\n    case 'up': {\n      emit('minus', event.ctrlKey)\n      break\n    }\n    case 'down': {\n      emit('plus', event.ctrlKey)\n      break\n    }\n    case 'ok': {\n      emit('enter')\n      break\n    }\n    case 'esc': {\n      emit('cancel')\n      break\n    }\n    default: {\n      if (typeof type === 'number') {\n        emit('input', type)\n      }\n    }\n  }\n}\n\nfunction handleBlur() {\n  emit('blur')\n}\n</script>\n\n<template>\n  <div\n    ref=\"wrapper\"\n    :class=\"className\"\n    role=\"none\"\n    tabindex=\"-1\"\n    @keydown=\"handleInput\"\n    @blur=\"handleBlur\"\n  >\n    <div v-if=\"!focused && !isActivated\" :class=\"nh.be('placeholder')\">\n      {{ placeholder }}\n    </div>\n    <template v-else>\n      <div\n        v-if=\"enabled.year\"\n        :class=\"[nh.be('unit'), getUnitFocusClass('year')]\"\n        role=\"spinbutton\"\n        :aria-label=\"label.year\"\n        :aria-valuenow=\"props.dateValue.year\"\n        :aria-valuetext=\"formattedYear\"\n        :aria-valuemin=\"1\"\n        :aria-valuemax=\"9999\"\n        :aria-labelledby=\"labeledBy\"\n        @click=\"handleInputFocus('year')\"\n      >\n        {{ formattedYear }}\n      </div>\n      <div\n        v-if=\"labels.year\"\n        :class=\"nh.be('label')\"\n        aria-hidden=\"true\"\n        @click=\"handleInputFocus('year')\"\n      >\n        {{ labels.year }}\n      </div>\n      <template v-if=\"enabled.month\">\n        <div v-if=\"enabled.year\" :class=\"nh.be('separator')\" aria-hidden=\"true\">\n          {{ dateSeparator }}\n        </div>\n        <div\n          :class=\"[nh.be('unit'), getUnitFocusClass('month')]\"\n          role=\"spinbutton\"\n          :aria-label=\"label.month\"\n          :aria-valuenow=\"props.dateValue.month\"\n          :aria-valuetext=\"formattedMonth\"\n          :aria-valuemin=\"1\"\n          :aria-valuemax=\"12\"\n          :aria-labelledby=\"labeledBy\"\n          @click=\"handleInputFocus('month')\"\n        >\n          {{ formattedMonth }}\n        </div>\n        <div\n          v-if=\"labels.month\"\n          :class=\"nh.be('label')\"\n          aria-hidden=\"true\"\n          @click=\"handleInputFocus('month')\"\n        >\n          {{ labels.month }}\n        </div>\n      </template>\n      <template v-if=\"enabled.date\">\n        <div v-if=\"enabled.month || enabled.year\" :class=\"nh.be('separator')\" aria-hidden=\"true\">\n          {{ dateSeparator }}\n        </div>\n        <div\n          :class=\"[nh.be('unit'), getUnitFocusClass('date')]\"\n          role=\"spinbutton\"\n          :aria-label=\"label.date\"\n          :aria-valuenow=\"props.dateValue.date\"\n          :aria-valuetext=\"formattedDate\"\n          :aria-valuemin=\"1\"\n          :aria-valuemax=\"maxDateCount || 31\"\n          :aria-labelledby=\"labeledBy\"\n          @click=\"handleInputFocus('date')\"\n        >\n          {{ formattedDate }}\n        </div>\n        <div\n          v-if=\"labels.date\"\n          :class=\"nh.be('label')\"\n          aria-hidden=\"true\"\n          @click=\"handleInputFocus('date')\"\n        >\n          {{ labels.date }}\n        </div>\n      </template>\n\n      <template v-if=\"showTimeUnits\">\n        <div :class=\"nh.be('pad')\"></div>\n        <div\n          v-if=\"enabled.hour\"\n          :class=\"[nh.be('unit'), getUnitFocusClass('hour')]\"\n          role=\"spinbutton\"\n          :aria-label=\"label.hour\"\n          :aria-valuenow=\"props.dateValue.hour\"\n          :aria-valuetext=\"formattedHour\"\n          :aria-valuemin=\"0\"\n          :aria-valuemax=\"23\"\n          :aria-labelledby=\"labeledBy\"\n          @click=\"handleInputFocus('hour')\"\n        >\n          {{ formattedHour }}\n        </div>\n        <div\n          v-if=\"labels.hour\"\n          :class=\"nh.be('label')\"\n          aria-hidden=\"true\"\n          @click=\"handleInputFocus('hour')\"\n        >\n          {{ labels.hour }}\n        </div>\n        <template v-if=\"enabled.minute\">\n          <div v-if=\"enabled.hour\" :class=\"nh.be('separator')\" aria-hidden=\"true\">\n            {{ timeSeparator }}\n          </div>\n          <div\n            :class=\"[nh.be('unit'), getUnitFocusClass('minute')]\"\n            role=\"spinbutton\"\n            :aria-label=\"label.minute\"\n            :aria-valuenow=\"props.dateValue.minute\"\n            :aria-valuetext=\"formattedMinute\"\n            :aria-valuemin=\"0\"\n            :aria-valuemax=\"59\"\n            :aria-labelledby=\"labeledBy\"\n            @click=\"handleInputFocus('minute')\"\n          >\n            {{ formattedMinute }}\n          </div>\n          <div\n            v-if=\"labels.minute\"\n            :class=\"nh.be('label')\"\n            aria-hidden=\"true\"\n            @click=\"handleInputFocus('minute')\"\n          >\n            {{ labels.minute }}\n          </div>\n        </template>\n        <template v-if=\"enabled.second\">\n          <div v-if=\"enabled.minute || enabled.hour\" :class=\"nh.be('separator')\" aria-hidden=\"true\">\n            {{ timeSeparator }}\n          </div>\n          <div\n            :class=\"[nh.be('unit'), getUnitFocusClass('second')]\"\n            role=\"spinbutton\"\n            :aria-label=\"label.second\"\n            :aria-valuenow=\"props.dateValue.second\"\n            :aria-valuetext=\"formattedSecond\"\n            :aria-valuemin=\"0\"\n            :aria-valuemax=\"59\"\n            :aria-labelledby=\"labeledBy\"\n            @click=\"handleInputFocus('second')\"\n          >\n            {{ formattedSecond }}\n          </div>\n          <div\n            v-if=\"labels.second\"\n            :class=\"nh.be('label')\"\n            aria-hidden=\"true\"\n            @click=\"handleInputFocus('second')\"\n          >\n            {{ labels.second }}\n          </div>\n        </template>\n      </template>\n    </template>\n  </div>\n</template>\n"
    },
    {
      "target": "components/date-picker/date-panel.vue",
      "content": "<script setup lang=\"ts\">\nimport { Button } from '@/components/button'\n\nimport { CalendarPanel } from '@/components/calendar-panel'\n\nimport { Icon } from '@/components/icon'\n\nimport { computed, onMounted, ref, watch } from 'vue'\n\nimport { useIcons, useNameHelper } from '@pocui/config'\n\nimport { callIfFunc, range as rangeNumbers, toDate } from '@pocui/utils'\n\nimport { datePickerTypes } from './symbol'\n\nimport TimeWheel from './time-wheel.vue'\n\nimport type { MonthIndex } from '@/components/calendar'\n\nimport type { LocaleConfig } from '@pocui/config'\n\nimport type { Dateable } from '@pocui/utils'\n\nimport type { PropType } from 'vue'\n\nimport type {\n  DatePickerType,\n  DateShortcut,\n  DateShortcutsPlacement,\n  DateTimeType,\n  DateType,\n  DisabledTime,\n  TimeType\n} from './symbol'\n\ndefineOptions({ name: 'DatePanel',\n  description:'日历面板容器，负责渲染月/周/日视图、管理选中状态、禁用规则及翻页动画。',\n  categories: ['form'] })\n\nconst props = defineProps({\n  type: {\n    default: 'date' as DatePickerType,\n    validator: (value: DatePickerType) => datePickerTypes.includes(value)\n  },\n  enabled: {\n    type: Object as PropType<Record<DateTimeType, boolean>>,\n    default: () => ({})\n  },\n  startValue: {\n    type: Object as PropType<Record<DateTimeType, number>>,\n    default: null\n  },\n  endValue: {\n    type: Object as PropType<Record<DateTimeType, number>>,\n    default: null\n  },\n  shortcuts: {\n    type: Array as PropType<DateShortcut[]>,\n    default: () => []\n  },\n  confirmText: {\n    type: String,\n    default: null\n  },\n  cancelText: {\n    type: String,\n    default: null\n  },\n  today: {\n    type: [Number, String, Date] as PropType<Dateable>,\n    default: () => new Date()\n  },\n  disabledDate: {\n    type: Function as PropType<(date: Date) => boolean>,\n    default: () => false\n  },\n  noAction: {\n    type: Boolean,\n    default: false\n  },\n  steps: {\n    type: Array as PropType<number[]>,\n    default: () => [1, 1, 1]\n  },\n  range: {\n    type: Boolean,\n    default: false\n  },\n  startActivated: {\n    type: Object as PropType<Record<DateTimeType, boolean>>,\n    default: () => ({})\n  },\n  endActivated: {\n    type: Object as PropType<Record<DateTimeType, boolean>>,\n    default: () => ({})\n  },\n  min: {\n    type: [Number, String, Date] as PropType<Dateable>,\n    default: null\n  },\n  max: {\n    type: [Number, String, Date] as PropType<Dateable>,\n    default: null\n  },\n  disabledTime: {\n    type: Object as PropType<DisabledTime>,\n    default: () => ({})\n  },\n  hasError: {\n    type: Boolean,\n    default: false\n  },\n  locale: {\n    type: Object as PropType<LocaleConfig['calendar'] & LocaleConfig['datePicker']>,\n    default: () => ({})\n  },\n  selectingType: {\n    type: String as PropType<'start' | 'end'>,\n    default: 'start'\n  },\n  weekStart: {\n    type: Number,\n    default: null\n  },\n  staticWheel: {\n    type: Boolean,\n    default: false\n  },\n  shortcutsPlacement: {\n    type: String as PropType<DateShortcutsPlacement>,\n    default: 'left'\n  },\n  labeledBy: {\n    type: String,\n    default: undefined\n  }\n})\n\nconst emit = defineEmits([\n  'click',\n  'shortcut',\n  'toggle-col',\n  'change',\n  'cancel',\n  'confirm',\n  'hover',\n  'type-change',\n  'time-change'\n])\n\nconst nh = useNameHelper('date-picker')\nconst icons = useIcons()\n\nconst today = toDate(props.today)\nconst monthRange = rangeNumbers(12, 1, 1)\n\nconst currentPane = ref<DateType>(props.type === 'year' ? 'year' : props.type === 'month' ? 'month' : 'date')\nconst calendarYear = ref(today.getFullYear())\nconst calendarMonth = ref(today.getMonth() + 1) // 1 ~ 12\nconst hoveredYear = ref(0) // 0 表示无悬停 (falsy)\nconst hoveredMonth = ref(0) // 0 表示无悬停 (falsy)\nconst yearRange = ref<number[]>([])\n\nconst startActivated = computed(() => {\n  const activated = props.startActivated\n\n  return activated.year && activated.month && activated.date\n})\nconst endActivated = computed(() => {\n  const activated = props.endActivated\n\n  return activated.year && activated.month && activated.date\n})\n\nconst isDatetime = computed(() => {\n  return props.type === 'datetime'\n})\nconst calendarValue = computed(() => {\n  return props.range\n    ? startActivated.value || endActivated.value\n      ? [getStringValue('start'), getStringValue('end')]\n      : ['', '']\n    : startActivated.value\n      ? getStringValue('start')\n      : ''\n})\nconst weekDays = computed(() => {\n  return [\n    props.locale.week7,\n    props.locale.week1,\n    props.locale.week2,\n    props.locale.week3,\n    props.locale.week4,\n    props.locale.week5,\n    props.locale.week6\n  ].map(week => week.slice(0, 2))\n})\n\nwatch(\n  calendarYear,\n  value => {\n    yearRange.value = rangeNumbers(12, Math.floor(value / 10) * 10, 1)\n  },\n  { immediate: true }\n)\n\nonMounted(() => {\n  refreshCalendar('start')\n})\n\ndefineExpose({ refreshCalendar })\n\nfunction getStringValue(type: 'start' | 'end') {\n  const value = type === 'start' ? props.startValue : props.endValue\n\n  return value ? `${value.year}-${value.month}-${value.date}` : ''\n}\n\nfunction getMonthLabel(index: number) {\n  return props.locale[`month${index as MonthIndex}`]\n}\n\nfunction togglePane(type: DateType) {\n  currentPane.value = type\n}\n\nfunction adjustCalendar(type: 'year' | 'month', amount: number) {\n  if (type === 'year') {\n    calendarYear.value += amount\n  } else {\n    // 月份存在进位\n    calendarMonth.value += amount\n\n    const date = new Date(calendarYear.value, calendarMonth.value - 1, 1)\n\n    calendarYear.value = date.getFullYear()\n    calendarMonth.value = date.getMonth() + 1\n  }\n}\n\nfunction handleClick(event: MouseEvent) {\n  emit('click', event)\n}\n\nfunction handleShortcut(index: number) {\n  const { value, name } = props.shortcuts[index]\n\n  emit('shortcut', name, callIfFunc(value))\n}\n\nfunction handleSelectDate(date: Date) {\n  emitChange([date.getFullYear(), date.getMonth() + 1, date.getDate()])\n}\n\nfunction handleSelectYear(year: number) {\n  if (isDisabledYear(year)) return\n\n  calendarYear.value = year\n\n  if (props.type !== 'year') {\n    togglePane('month')\n  } else {\n    emitChange([year, 1, 1])\n  }\n}\n\nfunction handleSelectMonth(month: number) {\n  if (isDisabledMonth(month)) return\n\n  calendarMonth.value = month\n\n  if (props.type !== 'month') {\n    togglePane('date')\n  } else {\n    emitChange([calendarYear.value, month, 1])\n  }\n}\n\nfunction emitChange(values: number[]) {\n  emit('change', values)\n}\n\nfunction handleStartTimeChange(type: TimeType, time: number) {\n  emit('time-change', 'start', type, time)\n}\n\nfunction handleEndTimeChange(type: TimeType, time: number) {\n  emit('time-change', 'end', type, time)\n}\n\nfunction handleDoublePrevClick() {\n  if (currentPane.value === 'year') {\n    yearRange.value = rangeNumbers(12, yearRange.value[0] - 10, 1)\n  } else {\n    adjustCalendar('year', -1)\n  }\n}\n\nfunction handleDoubleNextClick() {\n  if (currentPane.value === 'year') {\n    yearRange.value = rangeNumbers(12, yearRange.value[10], 1)\n  } else {\n    adjustCalendar('year', 1)\n  }\n}\n\nfunction handleCancel() {\n  emit('cancel')\n}\n\nfunction handleConfirm() {\n  emit('confirm')\n}\n\nfunction handleHoverDate(date: Date | null) {\n  emit('hover', date)\n}\n\nfunction isSelectedYear(year: number) {\n  if (!year) return false\n\n  return (\n    (props.startActivated.year && props.startValue.year === year) ||\n    (props.endActivated.year && props.endValue.year === year)\n  )\n}\n\nfunction isSelectedMonth(month: number) {\n  if (!month) return false\n\n  const monthYear = 100 * calendarYear.value + month\n\n  return (\n    (props.startActivated.month && 100 * props.startValue.year + props.startValue.month === monthYear) ||\n    (props.endActivated.month && 100 * props.endValue.year + props.endValue.month === monthYear)\n  )\n}\n\nfunction isDisabledYear(year: number) {\n  if (props.type === 'year') {\n    return props.disabledDate(new Date(year, 0))\n  }\n\n  for (let i = 1; i <= 12; ++i) {\n    if (!isDisabledMonth(i, year)) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isDisabledMonth(month: number, year = calendarYear.value) {\n  if (props.type === 'year') return false\n\n  if (props.type === 'month') {\n    return props.disabledDate(new Date(year, month - 1))\n  }\n\n  const current = new Date(year, month - 1)\n  const end = new Date(year, month, 0)\n  const dayCount = end.getDate()\n\n  for (let i = 1; i <= dayCount; ++i) {\n    current.setDate(i)\n\n    if (!props.disabledDate(current)) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction handleYearHover(year: number) {\n  hoveredYear.value = isDisabledYear(year) ? 0 : year\n}\n\nfunction handleMonthHover(month: number) {\n  hoveredMonth.value = isDisabledMonth(month) ? 0 : month\n}\n\nfunction isYearInRange(year: number) {\n  if (!props.range || (!hoveredYear.value && !props.startActivated.year && !props.endActivated.year)) {\n    return false\n  }\n\n  const startYear = props.startValue.year\n  const endYear = props.endValue.year\n\n  let min: number\n  let max: number\n\n  if (!hoveredYear.value && props.startActivated.year && props.endActivated.year) {\n    min = Math.min(startYear, endYear)\n    max = Math.max(startYear, endYear)\n  } else if (hoveredYear.value) {\n    if (!props.startActivated.year && !props.endActivated.year) return false\n\n    if (!props.startActivated.year || !props.endActivated.year) {\n      const selectedYear = props.startActivated.year ? startYear : endYear\n\n      min = Math.min(hoveredYear.value, selectedYear)\n      max = Math.max(hoveredYear.value, selectedYear)\n    } else {\n      const minYear = Math.min(startYear, endYear)\n      const maxYear = Math.max(startYear, endYear)\n\n      min = Math.min(hoveredYear.value, minYear)\n      max = Math.max(hoveredYear.value, maxYear)\n    }\n  } else {\n    return false\n  }\n\n  return year >= min && year <= max\n}\n\nfunction isMonthInRange(month: number) {\n  if (!props.range || (!hoveredMonth.value && !props.startActivated.month && !props.endActivated.month)) {\n    return false\n  }\n\n  const startMonthYear = 100 * props.startValue.year + props.startValue.month\n  const endMonthYear = 100 * props.endValue.year + props.endValue.month\n\n  let min: number\n  let max: number\n\n  if (!hoveredMonth.value && props.startActivated.month && props.endActivated.month) {\n    min = Math.min(startMonthYear, endMonthYear)\n    max = Math.max(startMonthYear, endMonthYear)\n  } else if (hoveredMonth.value) {\n    if (!props.startActivated.month && !props.endActivated.month) return false\n\n    const hoveredMonthYear = 100 * calendarYear.value + hoveredMonth.value\n\n    if (!props.startActivated.month || !props.endActivated.month) {\n      const selectedMonthYear = props.startActivated.month ? startMonthYear : endMonthYear\n\n      min = Math.min(hoveredMonthYear, selectedMonthYear)\n      max = Math.max(hoveredMonthYear, selectedMonthYear)\n    } else {\n      const minMonthYear = Math.min(startMonthYear, endMonthYear)\n      const maxMonthYear = Math.max(startMonthYear, endMonthYear)\n\n      min = Math.min(hoveredMonthYear, minMonthYear)\n      max = Math.max(hoveredMonthYear, maxMonthYear)\n    }\n  } else {\n    return false\n  }\n\n  const monthYear = 100 * calendarYear.value + month\n\n  return monthYear >= min && monthYear <= max\n}\n\n// 重新计算日历页面\nfunction refreshCalendar(valueType: 'start' | 'end') {\n  const today = toDate(props.today)\n\n  if (valueType === 'start') {\n    calendarYear.value = props.startActivated.year ? props.startValue.year : today.getFullYear()\n    calendarMonth.value = props.startActivated.month ? props.startValue.month : today.getMonth() + 1\n  } else {\n    calendarYear.value = props.endActivated.year ? props.endValue.year : today.getFullYear()\n    calendarMonth.value = props.endActivated.month ? props.endValue.month : today.getMonth() + 1\n  }\n}\n</script>\n\n<template>\n  <div\n    :class=\"{\n      [nh.be('panel')]: true,\n      [nh.bem('panel', 'vertical')]:\n        shortcuts.length && (shortcutsPlacement === 'top' || shortcutsPlacement === 'bottom')\n    }\"\n    :aria-labelledby=\"labeledBy\"\n    @click=\"handleClick\"\n  >\n    <div\n      v-if=\"shortcuts.length\"\n      :class=\"[nh.be('list'), nh.bem('list', 'sub'), nh.be('shortcuts'), nh.bem('shortcuts', shortcutsPlacement)]\"\n    >\n      <div\n        v-for=\"(item, index) in shortcuts\"\n        :key=\"index\"\n        :class=\"nh.be('shortcut')\"\n        :title=\"item.name\"\n        @click=\"handleShortcut(index)\"\n      >\n        {{ item.name }}\n      </div>\n    </div>\n    <div :class=\"nh.be('list')\" role=\"application\">\n      <div :class=\"nh.be('panel-body')\">\n        <div :class=\"nh.be('date-panel')\">\n          <div :class=\"nh.be('header')\">\n            <div :class=\"[nh.be('arrow'), nh.be('prev-year')]\" @click=\"handleDoublePrevClick\">\n              <Icon v-bind=\"icons.anglesLeft\"></Icon>\n            </div>\n            <div\n              v-show=\"currentPane === 'date'\"\n              :class=\"[nh.be('arrow'), nh.be('prev-month')]\"\n              @click=\"adjustCalendar('month', -1)\"\n            >\n              <Icon v-bind=\"icons.angleLeft\"></Icon>\n            </div>\n            <div :class=\"nh.be('year-month')\">\n              <div key=\"year\" :class=\"nh.be('year')\" @click.stop=\"togglePane('year')\">\n                <template v-if=\"currentPane === 'year'\">\n                  {{ `${yearRange[0]}${locale.year} - ${yearRange[9]}${locale.year}` }}\n                </template>\n                <template v-else>\n                  {{ `${calendarYear}${locale.year}` }}\n                </template>\n              </div>\n              <div v-show=\"currentPane === 'date'\" :class=\"nh.be('month')\" @click.stop=\"togglePane('month')\">\n                {{ getMonthLabel(calendarMonth) }}\n              </div>\n            </div>\n            <div\n              v-show=\"currentPane === 'date'\"\n              :class=\"[nh.be('arrow'), nh.be('next-month')]\"\n              @click=\"adjustCalendar('month', 1)\"\n            >\n              <Icon v-bind=\"icons.angleRight\"></Icon>\n            </div>\n            <div :class=\"[nh.be('arrow'), nh.be('next-year')]\" @click=\"handleDoubleNextClick\">\n              <Icon v-bind=\"icons.anglesRight\"></Icon>\n            </div>\n          </div>\n          <div :class=\"nh.be('calendar')\">\n            <div v-if=\"currentPane === 'year'\" :class=\"nh.be('year-panel')\" @mouseleave=\"hoveredYear = 0\">\n              <div\n                v-for=\"(item, index) in yearRange\"\n                :key=\"index\"\n                :class=\"{\n                  [nh.be('year-item')]: true,\n                  [nh.bem('year-item', 'selected')]: isSelectedYear(item),\n                  [nh.bem('year-item', 'next')]: index > 9,\n                  [nh.bem('year-item', 'disabled')]: isDisabledYear(item),\n                  [nh.bem('year-item', 'in-range')]: isYearInRange(item)\n                }\"\n                @click.stop=\"handleSelectYear(item)\"\n                @mouseenter=\"handleYearHover(item)\"\n              >\n                <div :class=\"nh.be('year-label')\">\n                  <div :class=\"nh.be('year-label-inner')\">\n                    {{ item }}\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div v-else-if=\"currentPane === 'month'\" :class=\"nh.be('month-panel')\" @mouseleave=\"hoveredMonth = 0\">\n              <div\n                v-for=\"index in monthRange\"\n                :key=\"index\"\n                :class=\"{\n                  [nh.be('month-item')]: true,\n                  [nh.bem('month-item', 'selected')]: isSelectedMonth(index),\n                  [nh.bem('month-item', 'disabled')]: isDisabledMonth(index),\n                  [nh.bem('month-item', 'in-range')]: isMonthInRange(index)\n                }\"\n                @click.stop=\"handleSelectMonth(index)\"\n                @mouseenter=\"handleMonthHover(index)\"\n              >\n                <div :class=\"nh.be('month-label')\">\n                  <div :class=\"nh.be('month-label-inner')\">\n                    {{ getMonthLabel(index) }}\n                  </div>\n                </div>\n              </div>\n            </div>\n            <CalendarPanel\n              v-else\n              inherit\n              :value=\"calendarValue\"\n              :year=\"calendarYear\"\n              :month=\"calendarMonth\"\n              :value-type=\"selectingType\"\n              :disabled-date=\"disabledDate\"\n              :range=\"range\"\n              :min=\"min\"\n              :max=\"max\"\n              :week-start=\"weekStart\"\n              :week-days=\"weekDays\"\n              @select=\"handleSelectDate\"\n              @hover=\"handleHoverDate\"\n            ></CalendarPanel>\n          </div>\n        </div>\n        <div v-if=\"isDatetime\" :class=\"nh.be('time-panel')\">\n          <div :class=\"[nh.be('header'), nh.bem('header', 'time')]\">\n            <template v-if=\"range\">\n              <div :class=\"nh.be('title')\">\n                {{ locale.startTime }}\n              </div>\n              <div :class=\"nh.be('title')\">\n                {{ locale.endTime }}\n              </div>\n            </template>\n          </div>\n          <div :class=\"nh.be('wheel')\">\n            <TimeWheel\n              :hour=\"startValue.hour\"\n              :minute=\"startValue.minute\"\n              :second=\"startValue.second\"\n              :candidate=\"3\"\n              :steps=\"steps\"\n              :disabled-time=\"disabledTime\"\n              :no-transition=\"staticWheel\"\n              @change=\"handleStartTimeChange\"\n            ></TimeWheel>\n            <TimeWheel\n              v-if=\"range\"\n              :hour=\"endValue.hour\"\n              :minute=\"endValue.minute\"\n              :second=\"endValue.second\"\n              :candidate=\"3\"\n              :steps=\"steps\"\n              :disabled-time=\"disabledTime\"\n              :no-transition=\"staticWheel\"\n              @change=\"handleEndTimeChange\"\n            ></TimeWheel>\n          </div>\n        </div>\n      </div>\n      <div v-if=\"!noAction\" :class=\"nh.be('action')\">\n        <Button\n          inherit\n          text\n          size=\"small\"\n          @click=\"handleCancel\"\n        >\n          {{ cancelText || locale.cancel }}\n        </Button>\n        <Button\n          inherit\n          type=\"primary\"\n          size=\"small\"\n          :disabled=\"hasError\"\n          @click=\"handleConfirm\"\n        >\n          {{ confirmText || locale.confirm }}\n        </Button>\n      </div>\n    </div>\n  </div>\n</template>\n"
    },
    {
      "target": "components/date-picker/date-picker.vue",
      "content": "<script setup lang=\"ts\">\nimport { useFieldStore } from '@/components/form'\nimport { Icon } from '@/components/icon'\n\nimport { Popper } from '@/components/popper'\n\nimport { computed, nextTick, reactive, ref, toRef, watch } from 'vue'\n\nimport {\n  boundRange,\n  differenceDays,\n  doubleDigits,\n  format,\n  getTime,\n  isLeapYear,\n  isObject,\n  mergeObjects,\n  startOfMonth,\n  toAttrValue,\n  toDate,\n  toFalse\n} from '@pocui/utils'\n\nimport { placementWhileList, useClickOutside, useHover, usePopper, useSetTimeout } from '@pocui/hooks'\nimport {\n  createIconProp,\n  createSizeProp,\n  createStateProp,\n  emitEvent,\n  makeSentence,\n  useIcons,\n  useLocale,\n  useNameHelper,\n  useProps,\n  useWordSpace\n} from '@pocui/config'\n\nimport DateControl from './date-control.vue'\nimport DatePanel from './date-panel.vue'\nimport { useColumn, useTimeBound } from './helper'\nimport { datePickerProps } from './props'\n\nimport { datePickerTypes, invalidDate } from './symbol'\n\nimport type { Dateable } from '@pocui/utils'\n\nimport type { DatePickerChangeEvent, DatePickerFormatFn, DateTimeType, TimeType } from './symbol'\nimport type { PopperExposed } from '@/components/popper'\n\ndefineOptions({ name: 'DatePicker',\n  description: '用于选择或输入一个日期。',\n  categories: ['form'] })\n\nconst { idFor, labelId, state, disabled, loading, size, validateField, clearField, getFieldValue, setFieldValue } =\n  useFieldStore<Dateable | Dateable[]>(() => reference.value?.focus())\n\nconst nh = useNameHelper('date-picker')\n\nconst _props = defineProps(datePickerProps)\nconst props = useProps('datePicker', _props, {\n  size: createSizeProp(size),\n  state: createStateProp(state),\n  locale: null,\n  type: {\n    default: 'date',\n    validator: value => datePickerTypes.includes(value)\n  },\n  visible: false,\n  placement: {\n    default: 'bottom-start',\n    validator: value => placementWhileList.includes(value)\n  },\n  transfer: false,\n  value: {\n    default: () => getFieldValue(),\n    static: true\n  },\n  format: 'yyyy-MM-dd HH:mm:ss',\n  valueFormat: null,\n  filler: {\n    default: '-',\n    validator: value => value.length === 1\n  },\n  clearable: false,\n  noAction: false,\n  labels: () => ({}),\n  dateSeparator: '/',\n  timeSeparator: ':',\n  shortcuts: () => [],\n  disabledDate: {\n    default: toFalse,\n    isFunc: true\n  },\n  steps: () => [1, 1, 1],\n  ctrlSteps: () => [5, 5, 5],\n  prefix: createIconProp(),\n  prefixColor: '',\n  suffix: createIconProp(),\n  suffixColor: '',\n  noSuffix: false,\n  disabled: () => disabled.value,\n  transitionName: () => nh.ns('drop'),\n  confirmText: null,\n  cancelText: null,\n  today: {\n    default: () => new Date(),\n    validator: value => !Number.isNaN(new Date(value))\n  },\n  range: null,\n  loading: () => loading.value,\n  loadingIcon: createIconProp(),\n  loadingLock: false,\n  loadingEffect: null,\n  min: null,\n  max: null,\n  outsideClose: true,\n  outsideCancel: false,\n  placeholder: null,\n  unitReadonly: false,\n  weekStart: null,\n  popperAlive: null,\n  shortcutsPlacement: 'left'\n})\n\nconst emit = defineEmits(['update:value', 'update:formatted-value', 'update:visible'])\n\nconst slots = defineSlots<{\n  prefix(): any,\n  exchange(): any,\n  suffix(): any\n}>()\n\nconst calendarLocale = useLocale('calendar')\nconst datePickerLocale = useLocale('datePicker')\nconst icons = useIcons()\nconst wordSpace = useWordSpace()\n\nconst placement = toRef(props, 'placement')\nconst transfer = toRef(props, 'transfer')\nconst currentVisible = ref(props.visible)\nconst focused = ref(false)\nconst startState = createDateState()\nconst endState = createDateState()\nconst currentState = ref<'start' | 'end'>('start')\nconst lastValue = ref('')\nconst firstSelected = ref<number[] | undefined>()\nconst hoveredDate = ref(new Date())\nconst staticWheel = ref(false)\n\nconst { timer } = useSetTimeout()\n\nconst wrapper = useClickOutside(handleClickOutside)\nconst popper = ref<PopperExposed>()\nconst { reference, transferTo, updatePopper } = usePopper({\n  placement,\n  transfer,\n  wrapper,\n  popper: computed(() => popper.value?.wrapper),\n  isDrop: true\n})\nconst { isHover } = useHover(reference)\n\nconst startInput = ref<InstanceType<typeof DateControl>>()\nconst endInput = ref<InstanceType<typeof DateControl>>()\nconst datePanel = ref<InstanceType<typeof DatePanel>>()\n\nconst mergedLocale = computed(() => {\n  const locale = mergeObjects(calendarLocale.value, datePickerLocale.value, true)\n\n  return isObject(props.locale) ? mergeObjects(locale, props.locale) : locale\n})\nconst startPlaceholder = computed(() => {\n  if (props.placeholder) {\n    return Array.isArray(props.placeholder) ? props.placeholder[0] : props.placeholder\n  }\n\n  const { select, start, [props.type]: type } = mergedLocale.value.placeholder\n\n  return makeSentence(props.range ? `${start} ${type}` : `${select} ${type}`, wordSpace.value)\n})\nconst endPlaceholder = computed(() => {\n  if (props.placeholder) {\n    return Array.isArray(props.placeholder) ? props.placeholder[1] || props.placeholder[0] : props.placeholder\n  }\n\n  const { end, [props.type]: type } = mergedLocale.value.placeholder\n\n  return makeSentence(`${end} ${type}`, wordSpace.value)\n})\nconst className = computed(() => {\n  return [\n    nh.b(),\n    nh.ns('input-vars'),\n    nh.bs('vars'),\n    nh.bm(props.type),\n    {\n      [nh.in()]: props.inherit,\n      [nh.bm('disabled')]: props.disabled,\n      [nh.bm(props.size)]: props.size !== 'default',\n      [nh.bm('no-hour')]: !startState.enabled.hour,\n      [nh.bm('no-minute')]: !startState.enabled.minute,\n      [nh.bm('no-second')]: !startState.enabled.second,\n      [nh.bm('visible')]: currentVisible.value,\n      [nh.bm(props.state)]: props.state !== 'default',\n      [nh.bm('is-range')]: props.range\n    }\n  ]\n})\nconst readonly = computed(() => props.loading && props.loadingLock)\nconst selectorClass = computed(() => {\n  const baseCls = nh.be('selector')\n\n  return {\n    [baseCls]: true,\n    [`${baseCls}--disabled`]: props.disabled,\n    [`${baseCls}--readonly`]: readonly.value,\n    [`${baseCls}--loading`]: props.loading,\n    [`${baseCls}--${props.size}`]: props.size !== 'default',\n    [`${baseCls}--focused`]: focused.value,\n    [`${baseCls}--${props.state}`]: props.state !== 'default'\n  }\n})\nconst hasPrefix = computed(() => {\n  return !!(slots.prefix || props.prefix)\n})\nconst currentValue = computed(() => {\n  const values = [startState, endState].map(state => {\n    const values = Object.values(state.dateValue).map(doubleDigits)\n\n    return `${values.slice(0, 3).join('-')} ${values.slice(3).join(':')}`\n  })\n\n  return props.range ? values : values[0]\n})\nconst hoveredLarge = computed(() => {\n  if (!firstSelected.value) return false\n\n  const [year, month, date] = firstSelected.value\n  const firstTime = new Date(`${year}-${month}-${date}`).getTime()\n  const hoverTime = hoveredDate.value.getTime()\n\n  return firstTime < hoverTime\n})\nconst showClear = computed(() => {\n  return !props.disabled && !readonly.value && props.clearable && isHover.value && !!lastValue.value\n})\nconst min = computed(() => {\n  if (props.min) {\n    const date = rawValueToDate(props.min, invalidDate)\n\n    if (Number.isNaN(+date)) return -Infinity\n\n    date.setHours(0, 0, 0, 0)\n\n    return date.getTime()\n  }\n\n  return -Infinity\n})\nconst max = computed(() => {\n  if (props.max) {\n    let date = rawValueToDate(props.max, invalidDate)\n\n    if (Number.isNaN(+date)) return Infinity\n\n    if (props.type !== 'datetime') {\n      date.setHours(23, 59, 59, 999)\n\n      if (props.type === 'year') {\n        date.setMonth(11)\n        date.setDate(31)\n      } else if (props.type === 'month') {\n        date.setMonth(date.getMonth() + 1)\n        date = startOfMonth(date)\n        date.setDate(date.getDate() - 1)\n      }\n    }\n\n    return date.getTime()\n  }\n\n  return Infinity\n})\nconst reversed = computed(() => {\n  if (Number.isNaN(min.value) || Number.isNaN(max.value)) {\n    return false\n  }\n\n  return min.value > max.value\n})\nconst startMinTime = computed(() => {\n  if (props.type === 'datetime' && props.min && !differenceDays(props.min, startState.getDate())) {\n    return getTime(props.min)\n  }\n\n  return ''\n})\nconst startMaxTime = computed(() => {\n  if (props.type === 'datetime' && props.max && !differenceDays(props.max, startState.getDate())) {\n    return getTime(props.max)\n  }\n\n  return ''\n})\nconst endMinTime = computed(() => {\n  if (props.type === 'datetime' && props.range && props.min && !differenceDays(props.min, startState.getDate())) {\n    return getTime(props.min)\n  }\n\n  return ''\n})\nconst endMaxTime = computed(() => {\n  if (props.type === 'datetime' && props.range && props.max && !differenceDays(props.max, startState.getDate())) {\n    return getTime(props.max)\n  }\n\n  return ''\n})\nconst startReversed = computed(() => {\n  if (!props.range) return false\n\n  const startValue = startState.dateValue\n  const endValue = endState.dateValue\n\n  let types: DateTimeType[]\n\n  if (props.type === 'year') {\n    types = ['year']\n  } else if (props.type === 'month') {\n    types = ['year', 'month']\n  } else if (props.type === 'date') {\n    types = ['year', 'month', 'date']\n  } else {\n    types = ['year', 'month', 'date', 'hour', 'minute', 'second']\n  }\n\n  for (const type of types) {\n    if (startValue[type] < endValue[type]) return false\n    if (startValue[type] > endValue[type]) return true\n  }\n\n  return false\n})\n\nconst startTimeBound = useTimeBound(startMinTime, startMaxTime)\nconst endTimeBound = useTimeBound(endMinTime, endMaxTime)\n\nconst isTimeDisabled = computed(() => {\n  return currentState.value === 'start' ? startTimeBound.isTimeDisabled : endTimeBound.isTimeDisabled\n})\nconst startError = computed(() => {\n  const { hour, minute, second } = startState.dateValue\n  const { isTimeDisabled } = startTimeBound\n\n  return (\n    startReversed.value ||\n    isDateDisabled(startState.getDate()) ||\n    isTimeDisabled.hour(hour) ||\n    isTimeDisabled.minute(hour, minute) ||\n    isTimeDisabled.second(hour, minute, second)\n  )\n})\nconst endError = computed(() => {\n  if (!props.range) return false\n\n  const { hour, minute, second } = endState.dateValue\n  const { isTimeDisabled } = endTimeBound\n\n  return (\n    startReversed.value ||\n    isDateDisabled(endState.getDate()) ||\n    isTimeDisabled.hour(hour) ||\n    isTimeDisabled.minute(hour, minute) ||\n    isTimeDisabled.second(hour, minute, second)\n  )\n})\nconst noActionMode = computed(() => props.type !== 'datetime' && props.noAction)\n\nwatch(() => props.type, parseFormat)\nwatch(\n  () => props.value,\n  value => {\n    parseValue(value)\n\n    lastValue.value = (Array.isArray(value) ? value[0] || value[1] : value) ? getStringValue() : ''\n  },\n  { immediate: true }\n)\nwatch(\n  () => props.type,\n  value => {\n    const hasMonth = value !== 'year'\n    const hasDate = hasMonth && value !== 'month'\n\n    startState.enabled.year = true\n    endState.enabled.year = true\n    startState.enabled.month = hasMonth\n    endState.enabled.month = hasMonth\n    startState.enabled.date = hasDate\n    endState.enabled.date = hasDate\n  },\n  { immediate: true }\n)\nwatch(() => props.format, parseFormat, { immediate: true })\nwatch(\n  () => props.visible,\n  value => {\n    currentVisible.value = value\n  }\n)\nwatch(currentVisible, value => {\n  if (value) {\n    updatePopper()\n  }\n})\nwatch(focused, value => {\n  if (value) {\n    emitEvent(props.onFocus)\n  } else {\n    emitEvent(props.onBlur)\n  }\n})\nwatch(currentState, value => {\n  if (!props.unitReadonly && currentVisible.value) {\n    emitEvent(props.onChangeCol, getCurrentState().column, value)\n  }\n})\nwatch(\n  () => startState.column,\n  value => {\n    if (!props.unitReadonly && currentVisible.value && currentState.value === 'start') {\n      emitEvent(props.onChangeCol, value, 'start')\n    }\n  }\n)\nwatch(\n  () => endState.column,\n  value => {\n    if (!props.unitReadonly && currentVisible.value && currentState.value === 'end') {\n      emitEvent(props.onChangeCol, value, 'end')\n    }\n  }\n)\nwatch(\n  () => props.disabled,\n  value => {\n    if (value) {\n      setVisible(false)\n      handleBlur()\n    }\n  }\n)\nwatch(readonly, value => {\n  if (value) {\n    setVisible(false)\n  }\n})\n\ndefineExpose({\n  idFor,\n  currentVisible,\n  focused,\n  isHover,\n  startState,\n  endState,\n  currentState,\n  startError,\n  endError,\n  wrapper,\n  reference,\n  popper,\n  start: startInput,\n  end: endInput,\n  panel: datePanel,\n  updatePopper,\n  focus: (options?: FocusOptions) => reference.value?.focus(options),\n  blur: () => reference.value?.blur()\n})\n\nfunction createDateState() {\n  const { currentColumn, enabled, resetColumn, enterColumn } = useColumn([\n    'year',\n    'month',\n    'date',\n    'hour',\n    'minute',\n    'second'\n  ] as DateTimeType[])\n\n  const dateValue = reactive({\n    year: 1970,\n    month: 1, // 1 ~ 12\n    date: 1,\n    hour: 0,\n    minute: 0,\n    second: 0\n  })\n  const activated = reactive({\n    year: false,\n    month: false,\n    date: false,\n    hour: false,\n    minute: false,\n    second: false\n  })\n\n  let valueRecord = { ...dateValue }\n  let activatedRecord = { ...activated }\n\n  return reactive({\n    column: currentColumn,\n    enabled,\n    activated,\n    dateValue,\n    resetColumn,\n    enterColumn,\n    setDate: (date: Date, withTime = true) => {\n      dateValue.year = date.getFullYear()\n      dateValue.month = date.getMonth() + 1\n      dateValue.date = date.getDate()\n\n      if (withTime) {\n        dateValue.hour = date.getHours()\n        dateValue.minute = date.getMinutes()\n        dateValue.second = date.getSeconds()\n      }\n    },\n    getDate: () => {\n      return new Date(\n        dateValue.year,\n        dateValue.month - 1,\n        dateValue.date,\n        dateValue.hour,\n        dateValue.minute,\n        dateValue.second\n      )\n    },\n    record() {\n      valueRecord = { ...dateValue }\n      activatedRecord = { ...activated }\n    },\n    restore() {\n      Object.assign(dateValue, valueRecord)\n      Object.assign(activated, activatedRecord)\n    }\n  })\n}\n\nfunction getCurrentState() {\n  return currentState.value === 'start' ? startState : endState\n}\n\nfunction rawValueToDate(value: Dateable, defaultValue = new Date(props.today)) {\n  let date!: Date\n\n  if (typeof value === 'number') {\n    if (props.type === 'year') {\n      if (value < 3000) {\n        date = new Date(value, 1)\n      } else {\n        date = toDate(value)\n      }\n    } else if (props.type === 'month') {\n      if (value < 300000) {\n        const year = Math.floor(value / 100)\n        const month = value - year * 100\n\n        date = new Date(year, month - 1)\n      } else {\n        date = toDate(value)\n      }\n    } else {\n      date = toDate(value)\n    }\n  } else {\n    date = toDate(value)\n  }\n\n  if (Number.isNaN(date.getTime())) {\n    date = defaultValue\n  }\n\n  return date\n}\n\nfunction parseValue<T extends Dateable | null>(value: T | T[]) {\n  if (!Array.isArray(value)) {\n    value = [value, value]\n  }\n\n  for (let i = 0; i < 2; ++i) {\n    const date = rawValueToDate(value[i] ?? '')\n    const state = i === 0 ? startState : endState\n\n    state.setDate(date)\n    toggleActivated(!!value[i], i === 0 ? 'start' : 'end')\n\n    if (!props.range) break\n  }\n}\n\nfunction parseFormat() {\n  const isDatetime = props.type === 'datetime'\n\n  ;[startState, endState].forEach(state => {\n    state.enabled.hour = false\n    state.enabled.minute = false\n    state.enabled.second = false\n\n    if (isDatetime && props.format) {\n      // 忽略“H”、“m”和“s”\n      let inQuotation = false\n\n      for (let i = 0, len = props.format.length; i < len; ++i) {\n        const char = props.format.charAt(i)\n\n        if (char === \"'\") {\n          inQuotation = !inQuotation\n        } else if (!inQuotation) {\n          switch (char) {\n            case 'H':\n              state.enabled.hour = true\n              break\n            case 'm':\n              state.enabled.minute = true\n              break\n            case 's':\n              state.enabled.second = true\n              break\n          }\n        }\n      }\n    }\n  })\n}\n\nfunction toggleActivated(value: boolean, valueType?: 'start' | 'end') {\n  const states = valueType ? (valueType === 'start' ? [startState] : [endState]) : [startState, endState]\n\n  states.forEach(state => {\n    ;(Object.keys(state.activated) as DateTimeType[]).forEach(type => {\n      state.activated[type] = value\n    })\n  })\n}\n\nfunction getStringValue() {\n  return Array.isArray(currentValue.value) ? currentValue.value.join('|') : currentValue.value\n}\n\nfunction isDateDisabled(date: Date) {\n  if (typeof props.disabledDate === 'function') {\n    if (props.disabledDate(date)) {\n      return true\n    }\n  }\n\n  const time = date.getTime()\n\n  if (reversed.value) {\n    if (time > max.value && time < min.value) {\n      return true\n    }\n  } else {\n    if (time < min.value || time > max.value) {\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction verifyDate() {\n  if (startError.value || (props.range && endError.value)) {\n    parseValue(props.value)\n  }\n}\n\nfunction setVisible(visible: boolean) {\n  if (currentVisible.value === visible) return\n\n  currentVisible.value = visible\n\n  emit('update:visible', visible)\n  emitEvent(props.onToggle, visible)\n}\n\nfunction emitChange() {\n  verifyDate()\n\n  if (lastValue.value !== getStringValue()) {\n    lastValue.value = getStringValue()\n\n    const values = Array.isArray(currentValue.value) ? currentValue.value : [currentValue.value]\n    const emitValues: number[] = []\n    const formattedValues: unknown[] = []\n\n    const valueFormat = props.valueFormat\n    const formatValue: DatePickerFormatFn =\n      typeof valueFormat === 'function'\n        ? valueFormat\n        : valueFormat\n          ? (timestamp, type) =>\n              format(\n                timestamp,\n                !Array.isArray(valueFormat) ? valueFormat : type === 'start' ? valueFormat[0] : valueFormat[1]\n              )\n          : timestamp => timestamp\n\n    for (let i = 0; i < 2; ++i) {\n      if (props.type === 'year') {\n        emitValues[i] = new Date(i === 0 ? startState.dateValue.year : endState.dateValue.year, 0).getTime()\n      } else if (props.type !== 'datetime') {\n        emitValues[i] = new Date(values[i].split(' ')[0] + ' 00:00:00').getTime()\n      } else {\n        emitValues[i] = new Date(values[i]).getTime()\n      }\n\n      formattedValues[i] = formatValue(emitValues[i], i === 0 ? 'start' : 'end')\n\n      if (!props.range) break\n    }\n\n    const emitValue = props.range ? emitValues : emitValues[0]\n    const formattedValue = props.range ? formattedValues : formattedValues[0]\n\n    toggleActivated(true)\n    emit('update:value', emitValue)\n    emit('update:formatted-value', formattedValue)\n    setFieldValue(emitValue)\n    emitEvent(props.onChange as DatePickerChangeEvent, emitValue)\n    validateField()\n  }\n}\n\nfunction finishInput(shouldChange = true) {\n  setVisible(false)\n\n  shouldChange && emitChange()\n  startState.resetColumn()\n  endState.resetColumn()\n}\n\nfunction verifyValue(type: DateTimeType) {\n  const dateValue = getCurrentState().dateValue\n\n  switch (type) {\n    case 'year': {\n      dateValue.year = boundRange(dateValue.year, 1970, 9999)\n      break\n    }\n    case 'month': {\n      dateValue.month = boundRange(dateValue.month, 1, 12)\n      break\n    }\n    case 'date': {\n      const month = dateValue.month\n\n      let lastDay: number\n\n      if (month < 7) {\n        if (month !== 2) {\n          lastDay = 30 + (month % 2)\n        } else {\n          if (isLeapYear(dateValue.year)) {\n            lastDay = 29\n          } else {\n            lastDay = 28\n          }\n        }\n      } else {\n        lastDay = 31 - (month % 2)\n      }\n\n      dateValue.date = boundRange(dateValue.date, 1, lastDay)\n      break\n    }\n    case 'hour':\n    case 'minute':\n    case 'second': {\n      dateValue[type] = boundRange(dateValue[type], 0, type === 'hour' ? 23 : 59)\n      dateValue[type] = Math.round(dateValue[type] / getStep(type)) * getStep(type)\n    }\n  }\n}\n\nfunction handleFocused() {\n  if (props.disabled) return\n\n  focused.value = true\n\n  timer.focus = setTimeout(() => {\n    if (focused.value) {\n      if (currentState.value === 'start') {\n        startInput.value?.focus()\n      } else {\n        endInput.value?.focus()\n      }\n    }\n  }, 120)\n}\n\nfunction handleBlur() {\n  clearTimeout(timer.focus)\n\n  focused.value = false\n  startInput.value?.blur()\n  endInput.value?.blur()\n}\n\nfunction showPanel(event: Event) {\n  if (props.disabled || readonly.value) return\n\n  const target = event.target as Node\n\n  setVisible(true)\n\n  if (wrapper.value && target) {\n    const units = Array.from(wrapper.value.querySelectorAll(`.${nh.be('unit')}`))\n    const index = units.findIndex(unit => unit === target || unit.contains(target))\n\n    if (!~index) {\n      startState.column = null\n      endState.column = null\n    }\n\n    if (props.range && index >= units.length / 2) {\n      toggleCurrentState('end')\n    } else {\n      toggleCurrentState('start')\n    }\n  }\n\n  handleFocused()\n}\n\nfunction handleInput(value: number) {\n  const state = getCurrentState()\n  const type = state.column\n\n  if (!type) return\n\n  handleInputNumber(type, value)\n\n  if (type === 'year' ? state.dateValue.year >= 1000 : state.dateValue[type] >= 10) {\n    state.enterColumn('next', false)\n  }\n}\n\nfunction handleInputNumber(type: DateTimeType, number: number) {\n  const state = getCurrentState()\n  const prev = state.dateValue[type]\n\n  if (state.activated[type] && prev > 0 && prev < (type === 'year' ? 1000 : 10)) {\n    state.dateValue[type] = prev * 10 + number\n  } else {\n    state.dateValue[type] = number\n    setActivatedTrue(type)\n  }\n\n  type !== 'year' && verifyValue(type)\n  emitEvent(props.onInput, type, state.dateValue[type])\n}\n\nfunction setActivatedTrue(type: DateTimeType) {\n  const activated = getCurrentState().activated\n\n  if (type === 'date') {\n    activated.year = true\n    activated.month = true\n  } else if (type === 'month') {\n    activated.year = true\n  } else if (type === 'minute') {\n    activated.hour = true\n  } else if (type === 'second') {\n    activated.hour = true\n    activated.minute = true\n  }\n\n  activated[type] = true\n}\n\nfunction handleInputFocus(type: DateTimeType) {\n  getCurrentState().column = type\n}\n\nfunction isTimeType(type: DateTimeType): type is TimeType {\n  return ['hour', 'minute', 'second'].includes(type)\n}\n\nfunction handleAdjust(adjustType: 'plus' | 'minus', ctrlKey: boolean) {\n  const isPlus = adjustType === 'plus'\n  const sign = isPlus ? 1 : -1\n  const state = getCurrentState()\n  const type = state.column\n\n  if (!type) return\n\n  if (state.enabled[type]) {\n    if (isTimeType(type)) {\n      state.dateValue[type] += sign * (ctrlKey ? getCtrlStep(type) : getStep(type))\n    } else {\n      if (ctrlKey) {\n        if (type === 'year') {\n          state.dateValue.year += sign * 10\n        } else {\n          state.dateValue[type === 'date' ? 'month' : 'year'] += sign\n        }\n      } else {\n        state.dateValue[type] += sign\n      }\n\n      computeDate()\n      updateDateActivated(type)\n    }\n\n    verifyValue(type)\n    emitEvent(props[isPlus ? 'onPlus' : 'onMinus'], type, state.dateValue[type])\n    datePanel.value?.refreshCalendar(currentState.value)\n  }\n}\n\nfunction handlePlus(ctrlKey: boolean) {\n  handleAdjust('plus', ctrlKey)\n}\n\nfunction handleMinus(ctrlKey: boolean) {\n  handleAdjust('minus', ctrlKey)\n}\n\nfunction computeDate() {\n  const dateValue = getCurrentState().dateValue\n  const date = new Date(dateValue.year, dateValue.month - 1, dateValue.date)\n\n  dateValue.year = date.getFullYear()\n  dateValue.month = date.getMonth() + 1\n  dateValue.date = date.getDate()\n}\n\nfunction fallbackFocus() {\n  requestAnimationFrame(() => {\n    handleBlur()\n    reference.value?.focus()\n  })\n}\n\nfunction handleEnter() {\n  fallbackFocus()\n  finishInput()\n  emitEvent(props.onEnter)\n}\n\nfunction handleCancel() {\n  fallbackFocus()\n  parseValue(lastValue.value.split('|'))\n  finishInput(false)\n  emitEvent(props.onCancel)\n}\n\nfunction handleClear(finish = true) {\n  if (props.disabled || readonly.value) return\n\n  if (props.clearable) {\n    nextTick(() => {\n      const emitValue = props.range ? ([] as number[]) : null\n\n      parseValue(null)\n      finish && finishInput(false)\n      emit('update:value', emitValue)\n      emit('update:formatted-value', props.range ? [] : null)\n      emitEvent(props.onChange as DatePickerChangeEvent, emitValue)\n      emitEvent(props.onClear)\n      clearField(emitValue!)\n      finish && handleBlur()\n\n      lastValue.value = ''\n\n      nextTick(() => {\n        toggleActivated(false)\n      })\n    })\n  }\n}\n\nfunction handleShortcut(name: string, value: Dateable | Dateable[]) {\n  fallbackFocus()\n  parseValue(value)\n  emitEvent(props.onShortcut as (name: string, value: Dateable | Dateable[]) => void, name, value)\n  finishInput()\n}\n\n// 只有时分秒\nfunction getStep(type: TimeType) {\n  return props.steps[type === 'hour' ? 0 : type === 'minute' ? 1 : 2] || 1\n}\n\n// 只有时分秒\nfunction getCtrlStep(type: TimeType) {\n  return props.ctrlSteps[type === 'hour' ? 0 : type === 'minute' ? 1 : 2] || 1\n}\n\nfunction handleDateHover(hoverDate: Date | null) {\n  if (props.range && hoverDate) {\n    hoveredDate.value = hoverDate\n\n    if (firstSelected.value) {\n      const hoverValues = [hoverDate.getFullYear(), hoverDate.getMonth() + 1, hoverDate.getDate()]\n      const start = hoveredLarge.value ? firstSelected.value : hoverValues\n      const end = hoveredLarge.value ? hoverValues : firstSelected.value\n\n      let types: DateTimeType[]\n\n      if (props.type === 'year') {\n        types = ['year']\n      } else if (props.type === 'month') {\n        types = ['year', 'month']\n      } else {\n        types = ['year', 'month', 'date']\n      }\n\n      for (let i = 0, len = types.length; i < len; ++i) {\n        startState.dateValue[types[i]] = start[i]\n        endState.dateValue[types[i]] = end[i]\n      }\n    }\n  }\n}\n\nfunction handlePanelChange(values: number[]) {\n  let types: DateTimeType[]\n\n  if (props.type === 'year') {\n    types = ['year']\n  } else if (props.type === 'month') {\n    types = ['year', 'month']\n  } else {\n    types = ['year', 'month', 'date']\n  }\n\n  if (!props.range) {\n    for (let i = 0, len = types.length; i < len; ++i) {\n      startState.dateValue[types[i]] = values[i]\n      updateDateActivated(types[i], 'start')\n    }\n\n    if (noActionMode.value) handleEnter()\n\n    return\n  }\n\n  if (!firstSelected.value) {\n    firstSelected.value = values\n\n    for (let i = 0, len = types.length; i < len; ++i) {\n      startState.dateValue[types[i]] = values[i]\n      endState.dateValue[types[i]] = values[i]\n      updateDateActivated(types[i], 'start')\n      updateDateActivated(types[i], 'end')\n    }\n  } else {\n    const [year, month, date] = firstSelected.value\n    const firstTime = new Date(`${year}-${month}-${date}`).getTime()\n    const secondTime = new Date(`${values[0]}-${values[1]}-${values[2]}`).getTime()\n    const start = firstTime < secondTime ? firstSelected.value : values\n    const end = firstTime < secondTime ? values : firstSelected.value\n\n    for (let i = 0, len = types.length; i < len; ++i) {\n      startState.dateValue[types[i]] = start[i]\n      endState.dateValue[types[i]] = end[i]\n      updateDateActivated(types[i], 'start')\n      updateDateActivated(types[i], 'end')\n    }\n\n    verifyRangeValue()\n    firstSelected.value = undefined\n\n    if (noActionMode.value) handleEnter()\n  }\n}\n\nfunction handleTimeChange(valueType: 'start' | 'end', type: TimeType, time: number) {\n  const state = valueType === 'start' ? startState : endState\n\n  state.dateValue[type] = time\n  updateDateActivated('hour', valueType)\n  updateDateActivated('minute', valueType)\n  updateDateActivated('second', valueType)\n}\n\nfunction updateDateActivated(type: DateTimeType, valueType?: 'start' | 'end') {\n  const state = valueType ? (valueType === 'start' ? startState : endState) : getCurrentState()\n\n  if (type === 'month') {\n    state.activated.year = true\n  } else if (type === 'date') {\n    state.activated.year = true\n    state.activated.month = true\n  }\n\n  state.activated[type] = true\n}\n\nfunction verifyRangeValue() {\n  if (!props.range) return\n\n  const startDate = startState.getDate()\n  const endDate = endState.getDate()\n\n  if (startDate.getTime() > endDate.getTime()) {\n    startState.setDate(endDate)\n    endState.setDate(startDate)\n  }\n}\n\nfunction toggleCurrentState(type: 'start' | 'end') {\n  currentState.value = type\n}\n\nfunction enterColumn(type: 'prev' | 'next') {\n  if (props.range) {\n    if (type === 'prev' && currentState.value === 'start' && !startState.column) {\n      toggleCurrentState('end')\n    }\n\n    const state = getCurrentState()\n    const currentColumn = state.column\n\n    state.enterColumn(type, !currentColumn)\n\n    if (currentColumn === state.column) {\n      const isStart = currentState.value === 'start'\n      const otherState = isStart ? endState : startState\n\n      otherState.resetColumn(type === 'prev' ? 'second' : 'year', type === 'prev')\n      toggleCurrentState(isStart ? 'end' : 'start')\n    }\n  } else {\n    startState.enterColumn(type)\n  }\n}\n\nfunction handleStartInput(type: DateTimeType) {\n  toggleCurrentState('start')\n  handleInputFocus(type)\n\n  nextTick(() => {\n    datePanel.value?.refreshCalendar('start')\n  })\n}\n\nfunction handleEndInput(type: DateTimeType) {\n  toggleCurrentState('end')\n  handleInputFocus(type)\n\n  nextTick(() => {\n    datePanel.value?.refreshCalendar('end')\n  })\n}\n\nfunction handleClickOutside() {\n  emitEvent(props.onClickOutside)\n\n  if (props.outsideClose && currentVisible.value) {\n    finishInput(!noActionMode.value && !props.outsideCancel)\n    handleBlur()\n    emitEvent(props.onOutsideClose)\n  }\n}\n</script>\n\n<template>\n  <div\n    :id=\"idFor\"\n    ref=\"wrapper\"\n    :class=\"className\"\n    role=\"group\"\n    :aria-disabled=\"toAttrValue(props.disabled)\"\n    :aria-expanded=\"toAttrValue(currentVisible)\"\n    aria-haspopup=\"dialog\"\n    :aria-labelledby=\"labelId\"\n    @click=\"showPanel\"\n  >\n    <div\n      ref=\"reference\"\n      :class=\"selectorClass\"\n      tabindex=\"0\"\n      @keydown.space.prevent=\"showPanel\"\n      @keydown.backspace.prevent=\"handleClear(false)\"\n    >\n      <div v-if=\"hasPrefix\" :class=\"[nh.be('icon'), nh.be('prefix')]\" :style=\"{ color: props.prefixColor }\">\n        <slot name=\"prefix\">\n          <Icon :icon=\"props.prefix\"></Icon>\n        </slot>\n      </div>\n      <div :class=\"nh.be('control')\">\n        <DateControl\n          ref=\"start\"\n          :unit-type=\"currentState === 'start' ? startState.column! : ''\"\n          :enabled=\"startState.enabled\"\n          :activated=\"startState.activated\"\n          :date-value=\"startState.dateValue\"\n          :steps=\"props.steps\"\n          :ctrl-steps=\"props.ctrlSteps\"\n          :focused=\"focused\"\n          :visible=\"currentVisible\"\n          :date-separator=\"props.dateSeparator\"\n          :time-separator=\"props.timeSeparator\"\n          :filler=\"props.filler\"\n          :labels=\"props.labels\"\n          :has-error=\"startError\"\n          :placeholder=\"startPlaceholder\"\n          :readonly=\"props.unitReadonly\"\n          :labeled-by=\"labelId\"\n          @input=\"handleInput\"\n          @plus=\"handlePlus\"\n          @minus=\"handleMinus\"\n          @enter=\"handleEnter\"\n          @cancel=\"handleCancel\"\n          @unit-focus=\"handleStartInput\"\n          @prev-unit=\"enterColumn('prev')\"\n          @next-unit=\"enterColumn('next')\"\n          @blur=\"startState.column = null\"\n        ></DateControl>\n        <template v-if=\"props.range\">\n          <div :class=\"nh.be('exchange')\">\n            <slot name=\"exchange\">\n              <Icon v-bind=\"icons.exchange\" style=\"padding-top: 1px\"></Icon>\n            </slot>\n          </div>\n          <DateControl\n            ref=\"end\"\n            :unit-type=\"currentState === 'end' ? endState.column! : ''\"\n            :enabled=\"endState.enabled\"\n            :activated=\"endState.activated\"\n            :date-value=\"endState.dateValue\"\n            :steps=\"props.steps\"\n            :ctrl-steps=\"props.ctrlSteps\"\n            :focused=\"focused\"\n            :visible=\"currentVisible\"\n            :date-separator=\"props.dateSeparator\"\n            :time-separator=\"props.timeSeparator\"\n            :filler=\"props.filler\"\n            :labels=\"props.labels\"\n            :has-error=\"endError\"\n            :placeholder=\"endPlaceholder\"\n            :readonly=\"props.unitReadonly\"\n            :labeled-by=\"labelId\"\n            @input=\"handleInput\"\n            @plus=\"handlePlus\"\n            @minus=\"handleMinus\"\n            @enter=\"handleEnter\"\n            @cancel=\"handleCancel\"\n            @unit-focus=\"handleEndInput\"\n            @prev-unit=\"enterColumn('prev')\"\n            @next-unit=\"enterColumn('next')\"\n            @blur=\"endState.column = null\"\n          ></DateControl>\n        </template>\n      </div>\n      <div\n        v-if=\"!props.noSuffix\"\n        :class=\"[nh.be('icon'), nh.be('suffix')]\"\n        :style=\"{\n          color: props.suffixColor,\n          opacity: showClear || props.loading ? '0%' : ''\n        }\"\n      >\n        <slot name=\"suffix\">\n          <Icon v-bind=\"icons.calendar\" :icon=\"props.suffix || icons.calendar.icon\"></Icon>\n        </slot>\n      </div>\n      <div\n        v-else-if=\"props.clearable || props.loading\"\n        :class=\"[nh.be('icon'), nh.bem('icon', 'placeholder'), nh.be('suffix')]\"\n      ></div>\n      <Transition :name=\"nh.ns('fade')\" appear>\n        <button\n          v-if=\"showClear\"\n          :class=\"[nh.be('icon'), nh.be('clear')]\"\n          type=\"button\"\n          tabindex=\"-1\"\n          :aria-label=\"mergedLocale.ariaLabel.clear\"\n          @click.stop=\"handleClear()\"\n        >\n          <Icon v-bind=\"icons.clear\" label=\"clear\"></Icon>\n        </button>\n        <div v-else-if=\"props.loading\" :class=\"[nh.be('icon'), nh.be('loading')]\">\n          <Icon\n            v-bind=\"icons.loading\"\n            :effect=\"props.loadingEffect || icons.loading.effect\"\n            :icon=\"props.loadingIcon || icons.loading.icon\"\n            label=\"loading\"\n          ></Icon>\n        </div>\n      </Transition>\n    </div>\n    <Popper\n      ref=\"popper\"\n      :class=\"[nh.be('popper'), nh.ns('calendar-vars'), nh.ns('time-picker-vars'), nh.bs('vars')]\"\n      :visible=\"currentVisible\"\n      :to=\"transferTo\"\n      :transition=\"props.transitionName\"\n      :alive=\"props.popperAlive ?? !transferTo\"\n      @click.stop=\"handleFocused\"\n      @before-enter=\"staticWheel = true\"\n      @before-leave=\"staticWheel = true\"\n      @after-enter=\"staticWheel = false\"\n      @after-leave=\"staticWheel = false\"\n    >\n      <DatePanel\n        ref=\"panel\"\n        :type=\"props.type\"\n        :start-value=\"startState.dateValue\"\n        :end-value=\"endState.dateValue\"\n        :start-activated=\"startState.activated\"\n        :end-activated=\"endState.activated\"\n        :value-type=\"currentState\"\n        :shortcuts=\"props.shortcuts\"\n        :confirm-text=\"props.confirmText\"\n        :cancel-text=\"props.cancelText\"\n        :today=\"props.today\"\n        :no-action=\"props.noAction\"\n        :steps=\"props.steps\"\n        :range=\"props.range\"\n        :min=\"props.min\"\n        :max=\"props.max\"\n        :disabled-date=\"isDateDisabled\"\n        :disabled-time=\"isTimeDisabled\"\n        :has-error=\"startError || endError\"\n        :selecting-type=\"hoveredLarge ? 'end' : 'start'\"\n        :locale=\"mergedLocale\"\n        :week-start=\"props.weekStart\"\n        :static-wheel=\"staticWheel\"\n        :shortcuts-placement=\"props.shortcutsPlacement\"\n        :labeled-by=\"labelId\"\n        @shortcut=\"handleShortcut\"\n        @change=\"handlePanelChange\"\n        @confirm=\"handleEnter\"\n        @cancel=\"handleCancel\"\n        @hover=\"handleDateHover\"\n        @time-change=\"handleTimeChange\"\n      ></DatePanel>\n    </Popper>\n  </div>\n</template>\n"
    },
    {
      "target": "components/date-picker/helper.ts",
      "content": "import { computed, reactive, ref } from 'vue'\n\nimport { getLast, toNumber } from '@pocui/utils'\n\nimport { DisabledType } from './symbol'\n\nimport type { Ref } from 'vue'\nimport type { DisabledTime } from './symbol'\n\ntype Digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n\nconst numberKeys = Array.from({ length: 10 }, (_, i) => i) as Digit[]\n\nfunction isNumberKey(key: string, num: Digit) {\n  return key === `Digit${num}` || key === `Numpad${num}` || key === `${num}`\n}\n\nexport function handleKeyEnter(event: KeyboardEvent) {\n  const key = event.code || event.key\n\n  let type: null | number | 'next' | 'prev' | 'up' | 'down' | 'ok' | 'esc' = null\n  let isMatch = false\n\n  switch (key) {\n    case 'Tab': {\n      isMatch = true\n      type = event.shiftKey ? 'prev' : 'next'\n      break\n    }\n    case 'ArrowRight': {\n      // 下一列\n      isMatch = true\n      type = 'next'\n      break\n    }\n    case 'Delete':\n    case 'ArrowLeft': {\n      // 上一列\n      isMatch = true\n      type = 'prev'\n      break\n    }\n    case 'ArrowUp': {\n      // 加一\n      isMatch = true\n      type = 'up'\n      break\n    }\n    case 'ArrowDown': {\n      // 减一\n      isMatch = true\n      type = 'down'\n      break\n    }\n    case 'Space':\n    case ' ':\n    case 'Enter':\n    case 'NumpadEnter': {\n      // 确认\n      isMatch = true\n      type = 'ok'\n      break\n    }\n    case 'Escape': {\n      // 取消\n      isMatch = true\n      type = 'esc'\n      break\n    }\n  }\n\n  if (isMatch) {\n    event.preventDefault()\n    event.stopPropagation()\n  } else {\n    // 键入数字\n    const inputtedNumber = numberKeys.findIndex(num => isNumberKey(key, num))\n\n    if (~inputtedNumber) {\n      type = inputtedNumber\n\n      event.preventDefault()\n      event.stopPropagation()\n    }\n  }\n\n  return type\n}\n\nexport function useColumn<T extends string>(colTypes: T[], currentColumn = ref(colTypes[0]) as Ref<T | null>) {\n  const columnTypes = Array.from(colTypes)\n  const columnCount = columnTypes.length\n  const enabled = reactive(\n    columnTypes.reduce((prev, current) => {\n      prev[current] = false\n      return prev\n    }, {} as any)\n  ) as Record<T, boolean>\n\n  function findEnabledColumn(types: T[]) {\n    currentColumn.value = types.find(type => enabled[type]) ?? currentColumn.value\n  }\n\n  function resetColumn(type?: T | null, reverse = false) {\n    if (!type) {\n      currentColumn.value = null\n    }\n\n    const types = reverse ? Array.from(columnTypes).reverse() : columnTypes\n    const index = types.findIndex(column => column === type)\n\n    if (~index) {\n      findEnabledColumn(types.slice(index, columnCount).concat(types.slice(0, index)))\n    } else {\n      findEnabledColumn(types)\n    }\n  }\n\n  function enterColumn(type: 'prev' | 'next', canLoop = true) {\n    if (!currentColumn.value) {\n      currentColumn.value = (type === 'next' ? getLast(columnTypes) : columnTypes[0]) ?? null\n    }\n\n    for (let i = 0; i < columnCount; ++i) {\n      if (currentColumn.value === columnTypes[i]) {\n        const rawTypes = type === 'prev' ? Array.from(columnTypes).reverse() : columnTypes\n        const nextIndex = (type === 'prev' ? columnCount - i : i + 1) % columnCount\n        const types = canLoop\n          ? rawTypes.slice(nextIndex, columnCount).concat(rawTypes.slice(0, nextIndex))\n          : nextIndex\n            ? rawTypes.slice(nextIndex, columnCount)\n            : []\n\n        findEnabledColumn(types)\n\n        break\n      }\n    }\n  }\n\n  return {\n    currentColumn,\n    enabled,\n    resetColumn,\n    enterColumn\n  }\n}\n\nconst defaultMin = [0, 0, 0]\nconst defaultMax = [23, 59, 59]\n\nexport function useTimeBound(originMin: Ref<string>, originMax: Ref<string>) {\n  const minUnits = computed(() => {\n    return originMin.value ? originMin.value.split(':').map(toNumber) : defaultMin\n  })\n  const maxUnits = computed(() => {\n    return originMax.value ? originMax.value.split(':').map(toNumber) : defaultMax\n  })\n  const reversed = computed(() => {\n    const min = minUnits.value\n    const max = maxUnits.value\n\n    for (let i = 0; i < 3; ++i) {\n      if (min[i] < max[i]) return false\n      if (min[i] > max[i]) return true\n    }\n\n    return false\n  })\n\n  const isTimeDisabled: Required<DisabledTime> = {\n    hour: isHourDisabled,\n    minute: (hour, minute) => isMinuteDisabled(hour, minute) !== DisabledType.FALSE,\n    second: (hour, minute, second) => isSecondDisabled(hour, minute, second) !== DisabledType.FALSE\n  }\n\n  function isHourDisabled(hour: number) {\n    const min = minUnits.value[0] || defaultMin[0]\n    const max = maxUnits.value[0] || defaultMax[0]\n\n    return reversed.value ? hour > max && hour < min : hour < min || hour > max\n  }\n\n  function isMinuteDisabled(hour: number, minute: number) {\n    if (isHourDisabled(hour)) return DisabledType.UPSTREAM\n\n    if (minUnits.value[0] === maxUnits.value[0] && hour === minUnits.value[0]) {\n      const min = minUnits.value[1] || defaultMin[1]\n      const max = maxUnits.value[1] || defaultMax[1]\n\n      if (reversed.value ? minute > max && minute < min : minute < min || minute > max) {\n        return DisabledType.TRUE\n      }\n    }\n\n    if (hour === minUnits.value[0]) {\n      const min = minUnits.value[1] || defaultMin[1]\n\n      if (minute < min) return DisabledType.AT_MIN_TRUE\n    }\n\n    if (hour === maxUnits.value[0]) {\n      const max = maxUnits.value[1] || defaultMax[1]\n\n      if (minute > max) return DisabledType.AT_MAX_TRUE\n    }\n\n    return DisabledType.FALSE\n  }\n\n  function isSecondDisabled(hour: number, minute: number, second: number) {\n    if (isMinuteDisabled(hour, minute) !== DisabledType.FALSE) return DisabledType.UPSTREAM\n\n    if (\n      minUnits.value[0] === maxUnits.value[0] &&\n      hour === minUnits.value[0] &&\n      minUnits.value[1] === maxUnits.value[1] &&\n      minute === minUnits.value[1]\n    ) {\n      const min = minUnits.value[2] || defaultMin[2]\n      const max = maxUnits.value[2] || defaultMax[2]\n\n      if (reversed.value ? second > max && second < min : second < min || second > max) {\n        return DisabledType.TRUE\n      }\n    }\n\n    if (hour === minUnits.value[0] && minute === minUnits.value[1]) {\n      const min = minUnits.value[2] || defaultMin[2]\n\n      if (second < min) return DisabledType.AT_MIN_TRUE\n    }\n\n    if (hour === maxUnits.value[0] && minute === maxUnits.value[1]) {\n      const max = maxUnits.value[2] || defaultMax[2]\n\n      if (second > max) return DisabledType.AT_MAX_TRUE\n    }\n\n    return DisabledType.FALSE\n  }\n\n  return {\n    minUnits,\n    maxUnits,\n    reversed,\n    isTimeDisabled\n  }\n}\n"
    },
    {
      "target": "components/date-picker/index.ts",
      "content": "import DatePicker from './date-picker.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { DatePicker }\nexport { datePickerProps } from './props'\n\nexport type DatePickerExposed = ComponentPublicInstance & InstanceType<typeof DatePicker>\n\nexport type { DatePickerProps, DatePickerCProps } from './props'\nexport type {\n  DateType,\n  TimeType,\n  DateTimeType,\n  DatePickerType,\n  DatePickerFormatFn,\n  DateShortcut,\n  TimeShortcut,\n  DateShortcutsPlacement\n} from './symbol'\n"
    },
    {
      "target": "components/date-picker/props.ts",
      "content": "import {\n  booleanProp,\n  booleanStringProp,\n  buildProps,\n  eventProp,\n  iconProp,\n  localeProp,\n  sizeProp,\n  stateProp\n} from '@pocui/config'\n\nimport type { IconEffect } from '@/components/icon'\nimport type { ConfigurableProps, EventListener, LocaleConfig } from '@pocui/config'\nimport type { Placement } from '@pocui/hooks'\nimport type { Dateable } from '@pocui/utils'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type {\n  DatePickerChangeEvent,\n  DatePickerFormatFn,\n  DatePickerType,\n  DateShortcut,\n  DateShortcutsPlacement,\n  DateTimeType,\n  TimePickerChangeEvent,\n  TimeShortcut,\n  TimeShortcutsPlacement,\n  TimeType\n} from './symbol'\n\nexport interface DatePickerShortcutEvent {\n  (name: string, value: Dateable | Dateable[]): void,\n\n  (name: string, value: Dateable): void,\n\n  (name: string, value: Dateable[]): void\n}\n\nexport const datePickerProps = buildProps({\n  size: sizeProp,\n  state: stateProp,\n  locale: Object as PropType<Partial<LocaleConfig['calendar'] & LocaleConfig['datePicker']>>,\n  type: String as PropType<DatePickerType>,\n  visible: booleanProp,\n  placement: String as PropType<Placement>,\n  transfer: booleanStringProp,\n  value: [Number, String, Date, Array] as PropType<Dateable | Dateable[]>,\n  format: String,\n  valueFormat: [String, Array, Function] as PropType<string | string[] | DatePickerFormatFn>,\n  filler: String,\n  clearable: booleanProp,\n  noAction: booleanProp,\n  labels: Object as PropType<Partial<Record<DateTimeType, string>>>,\n  dateSeparator: String,\n  timeSeparator: String,\n  shortcuts: Array as PropType<DateShortcut[]>,\n  disabledDate: Function as PropType<(date: Date) => boolean>,\n  steps: Array as PropType<number[]>,\n  ctrlSteps: Array as PropType<number[]>,\n  prefix: iconProp,\n  prefixColor: String,\n  suffix: iconProp,\n  suffixColor: String,\n  noSuffix: booleanProp,\n  disabled: booleanProp,\n  transitionName: String,\n  confirmText: String,\n  cancelText: String,\n  today: [Number, String, Date] as PropType<Dateable>,\n  range: booleanProp,\n  loading: booleanProp,\n  loadingIcon: iconProp,\n  loadingLock: booleanProp,\n  loadingEffect: String as PropType<IconEffect>,\n  min: [Number, String, Date] as PropType<Dateable>,\n  max: [Number, String, Date] as PropType<Dateable>,\n  outsideClose: booleanProp,\n  outsideCancel: booleanProp,\n  placeholder: [String, Array] as PropType<string | string[]>,\n  unitReadonly: booleanProp,\n  weekStart: Number,\n  popperAlive: booleanProp,\n  shortcutsPlacement: String as PropType<DateShortcutsPlacement>,\n  onInput: eventProp<(type: DateTimeType, value: number) => void>(),\n  onPlus: eventProp<(type: DateTimeType, value: number) => void>(),\n  onMinus: eventProp<(type: DateTimeType, value: number) => void>(),\n  onEnter: eventProp(),\n  onCancel: eventProp(),\n  onChange: eventProp<EventListener<DatePickerChangeEvent>>(),\n  onClear: eventProp(),\n  onShortcut: eventProp<DatePickerShortcutEvent>(),\n  onToggle: eventProp<(visible: boolean) => void>(),\n  onFocus: eventProp(),\n  onBlur: eventProp(),\n  onChangeCol: eventProp<(type: DateTimeType | null, inputType: 'start' | 'end') => void>(),\n  onClickOutside: eventProp(),\n  onOutsideClose: eventProp()\n})\n\nexport type DatePickerProps = ExtractPropTypes<typeof datePickerProps>\nexport type DatePickerCProps = ConfigurableProps<DatePickerProps>\n\nexport interface TimePickerShortcutEvent {\n  (name: string, value: string | string[]): void,\n\n  (name: string, value: string): void,\n\n  (name: string, value: string[]): void\n}\n\nexport const timePickerProps = buildProps({\n  size: sizeProp,\n  state: stateProp,\n  locale: localeProp('timePicker'),\n  visible: booleanProp,\n  placement: String as PropType<Placement>,\n  transfer: booleanStringProp,\n  format: String,\n  separator: String,\n  value: [String, Array] as PropType<string | string[]>,\n  filler: String,\n  clearable: booleanProp,\n  noAction: booleanProp,\n  noArrow: booleanProp,\n  pointer: booleanProp,\n  candidate: Number as PropType<0 | 1 | 2 | 3>,\n  steps: Array as PropType<number[]>,\n  labels: Object as PropType<Partial<Record<TimeType, string>>>,\n  shortcuts: Array as PropType<TimeShortcut[]>,\n  range: booleanProp,\n  disabled: booleanProp,\n  transitionName: String,\n  confirmText: String,\n  cancelText: String,\n  ctrlSteps: Array as PropType<number[]>,\n  prefix: iconProp,\n  prefixColor: String,\n  suffix: iconProp,\n  suffixColor: String,\n  noSuffix: booleanProp,\n  exchange: booleanProp,\n  loading: booleanProp,\n  loadingIcon: iconProp,\n  loadingLock: booleanProp,\n  loadingEffect: String as PropType<IconEffect>,\n  min: String,\n  max: String,\n  outsideClose: booleanProp,\n  outsideCancel: booleanProp,\n  unitReadonly: booleanProp,\n  popperAlive: booleanProp,\n  shortcutsPlacement: String as PropType<TimeShortcutsPlacement>,\n  onInput: eventProp<(type: TimeType, value: number) => void>(),\n  onPlus: eventProp<(type: TimeType, value: number) => void>(),\n  onMinus: eventProp<(type: TimeType, value: number) => void>(),\n  onEnter: eventProp(),\n  onCancel: eventProp(),\n  onChange: eventProp<EventListener<TimePickerChangeEvent>>(),\n  onClear: eventProp(),\n  onShortcut: eventProp<TimePickerShortcutEvent>(),\n  onToggle: eventProp<(visible: boolean) => void>(),\n  onFocus: eventProp(),\n  onBlur: eventProp(),\n  onChangeCol: eventProp<(type: TimeType | null, inputType: 'start' | 'end') => void>(),\n  onClickOutside: eventProp(),\n  onOutsideClose: eventProp(),\n  placeholder: [String, Array] as PropType<string | string[]>\n})\n\nexport type TimePickerProps = ExtractPropTypes<typeof timePickerProps>\nexport type TimePickerCProps = ConfigurableProps<TimePickerProps>\n"
    },
    {
      "target": "components/date-picker/symbol.ts",
      "content": "import type { Dateable } from '@pocui/utils'\n\nexport type DateType = 'year' | 'month' | 'date'\nexport type TimeType = 'hour' | 'minute' | 'second'\nexport type DateTimeType = DateType | TimeType\n\nexport type DatePickerType = 'date' | 'datetime' | 'year' | 'month'\nexport type DateShortcutsPlacement = 'top' | 'right' | 'bottom' | 'left'\nexport type TimeShortcutsPlacement = DateShortcutsPlacement\n\nexport type DatePickerFormatFn = (timestamp: number, type: 'start' | 'end') => unknown\n\nexport interface DateShortcut {\n  name: string,\n\n  value: Dateable | Dateable[] | (() => Dateable | Dateable[])\n}\n\nexport interface TimeShortcut {\n  name: string,\n\n  value: string | string[] | (() => string | string[])\n}\n\nexport interface DatePickerState {\n  type: DatePickerType,\n\n  currentColumn: DateTimeType,\n\n  enabled: Record<DateTimeType, boolean>,\n\n  activated: Record<DateTimeType, boolean>,\n\n  dateValue: Record<DateTimeType, number>,\n\n  enterColumn(type: 'prev' | 'next'): void\n}\n\nexport interface DisabledTime {\n  hour?(hour: number): boolean,\n\n  minute?(hour: number, minute: number): boolean,\n\n  second?(hour: number, minute: number, second: number): boolean\n}\n\nexport const enum DisabledType {\n  UPSTREAM,\n  TRUE,\n  AT_MIN_TRUE,\n  AT_MAX_TRUE,\n  FALSE\n}\n\nexport type DatePickerChangeEvent = (value: number | number[] | null) => void\nexport type TimePickerChangeEvent = (value: string | string[]) => void\n\nexport const datePickerTypes = Object.freeze<DatePickerType[]>(['date', 'datetime', 'year', 'month'])\n\nexport const invalidDate = new Date('')\n\n// export const TIME_REG = /^((?:[01]?[0-9])|(?:2[0-3]))((?::[0-5]?[0-9]))?((?::[0-5]?[0-9]))?$/\nexport const TIME_REG = /^((?:\\d{1,2}))((?::\\d{1,2}))?((?::\\d{1,2}))?$/\n"
    },
    {
      "target": "components/date-picker/time-control.vue",
      "content": "<script setup lang=\"ts\">\nimport { computed, ref } from 'vue'\n\nimport { useNameHelper } from '@pocui/config'\n\nimport { doubleDigits } from '@pocui/utils'\n\nimport { handleKeyEnter } from './helper'\n\nimport type { LocaleConfig } from '@pocui/config'\n\nimport type { PropType } from 'vue'\n\nimport type { TimeType } from './symbol'\n\ndefineOptions({ name: 'TimeControl',\n  description:'底部快捷操作栏，缩短用户选择当前时间或提交选择的操作路径。',\n  categories: ['form'] })\n\nconst props = defineProps({\n  unitType: {\n    type: String as PropType<TimeType | ''>,\n    default: ''\n  },\n  enabled: {\n    type: Object as PropType<Record<TimeType, boolean>>,\n    default: () => ({})\n  },\n  activated: {\n    type: Object as PropType<Record<TimeType, boolean>>,\n    default: () => ({})\n  },\n  timeValue: {\n    type: Object as PropType<Record<TimeType, number>>,\n    default: () => ({})\n  },\n  separator: {\n    type: String,\n    default: ':'\n  },\n  visible: {\n    type: Boolean,\n    default: false\n  },\n  focused: {\n    type: Boolean,\n    default: false\n  },\n  filler: {\n    type: String,\n    default: '-',\n    validator: (value: string) => value.length === 1\n  },\n  steps: {\n    type: Array as PropType<number[]>,\n    default: () => [1, 1, 1]\n  },\n  ctrlSteps: {\n    type: Array as PropType<number[]>,\n    default: () => [5, 5, 5]\n  },\n  labels: {\n    type: Object as PropType<Partial<Record<TimeType, string>>>,\n    default: () => ({})\n  },\n  hasError: {\n    type: Boolean,\n    default: false\n  },\n  placeholder: {\n    type: String,\n    default: ''\n  },\n  readonly: {\n    type: Boolean,\n    default: false\n  },\n  labeledBy: {\n    type: String,\n    default: undefined\n  },\n  locale: {\n    type: Object as PropType<LocaleConfig['timePicker']>,\n    default: () => ({})\n  }\n})\n\nconst emit = defineEmits([\n  'input',\n  'plus',\n  'minus',\n  'enter',\n  'cancel',\n  'unit-focus',\n  'unit-blur',\n  'prev-unit',\n  'next-unit',\n  'blur'\n])\n\nconst nh = useNameHelper('time-picker')\n\nconst wrapper = ref<HTMLElement>()\n\nconst label = computed(() => props.locale.ariaLabel ?? {})\nconst isActivated = computed(() => {\n  return (Object.keys(props.enabled) as TimeType[]).every(type => {\n    return !props.enabled[type] || props.activated[type]\n  })\n})\nconst formattedHour = computed(() => {\n  return formatValue('hour')\n})\nconst formattedMinute = computed(() => {\n  return formatValue('minute')\n})\nconst formattedSecond = computed(() => {\n  return formatValue('second')\n})\n\ndefineExpose({\n  isActivated,\n  wrapper,\n  focus: () => {\n    wrapper.value?.focus()\n  },\n  blur: () => {\n    wrapper.value?.blur()\n  }\n})\n\nfunction formatValue(type: TimeType) {\n  return props.activated[type] ? doubleDigits(props.timeValue[type]) : `${props.filler}${props.filler}`\n}\n\nfunction getUnitFocusClass(type: TimeType) {\n  return props.visible && props.unitType === type ? nh.bem('unit', 'focused') : null\n}\n\nfunction handleInputFocus(type: TimeType) {\n  if (props.readonly) return\n\n  emit('unit-focus', type)\n}\n\nfunction handleInput(event: KeyboardEvent) {\n  if (!props.visible) return\n\n  const type = handleKeyEnter(event)\n\n  if (props.readonly) {\n    switch (type) {\n      case 'ok': {\n        emit('enter')\n        break\n      }\n      case 'esc': {\n        emit('cancel')\n        break\n      }\n    }\n\n    return\n  }\n\n  switch (type) {\n    case 'next': {\n      emit('next-unit')\n      break\n    }\n    case 'prev': {\n      emit('prev-unit')\n      break\n    }\n    case 'up': {\n      emit('minus', event.ctrlKey)\n      break\n    }\n    case 'down': {\n      emit('plus', event.ctrlKey)\n      break\n    }\n    case 'ok': {\n      handleEnter()\n      break\n    }\n    case 'esc': {\n      handleCancel()\n      break\n    }\n    default: {\n      if (typeof type === 'number') {\n        emit('input', type)\n      }\n    }\n  }\n}\n\nfunction handleEnter() {\n  emit('enter')\n}\n\nfunction handleCancel() {\n  emit('cancel')\n}\n\nfunction handleBlur() {\n  emit('blur')\n}\n</script>\n\n<template>\n  <div\n    ref=\"wrapper\"\n    :class=\"[nh.be('input'), hasError && nh.bem('input', 'error')]\"\n    role=\"none\"\n    tabindex=\"-1\"\n    @keydown=\"handleInput\"\n    @blur=\"handleBlur\"\n  >\n    <div v-if=\"!focused && !isActivated\" :class=\"nh.be('placeholder')\">\n      {{ placeholder }}\n    </div>\n    <template v-else>\n      <div\n        v-if=\"enabled.hour\"\n        :class=\"[nh.be('unit'), getUnitFocusClass('hour')]\"\n        role=\"spinbutton\"\n        :aria-label=\"label.hour\"\n        :aria-valuenow=\"props.timeValue.hour\"\n        :aria-valuetext=\"formattedHour\"\n        :aria-valuemin=\"0\"\n        :aria-valuemax=\"23\"\n        :aria-labelledby=\"labeledBy\"\n        @click=\"handleInputFocus('hour')\"\n      >\n        {{ formattedHour }}\n      </div>\n      <div\n        v-if=\"labels.hour\"\n        :class=\"nh.be('label')\"\n        aria-hidden=\"true\"\n        @click=\"handleInputFocus('hour')\"\n      >\n        {{ labels.hour }}\n      </div>\n      <template v-if=\"enabled.minute\">\n        <div v-if=\"enabled.hour\" :class=\"nh.be('separator')\" aria-hidden=\"true\">\n          {{ separator }}\n        </div>\n        <div\n          :class=\"[nh.be('unit'), getUnitFocusClass('minute')]\"\n          role=\"spinbutton\"\n          :aria-label=\"label.minute\"\n          :aria-valuenow=\"props.timeValue.minute\"\n          :aria-valuetext=\"formattedMinute\"\n          :aria-valuemin=\"0\"\n          :aria-valuemax=\"59\"\n          :aria-labelledby=\"labeledBy\"\n          @click=\"handleInputFocus('minute')\"\n        >\n          {{ formattedMinute }}\n        </div>\n        <div\n          v-if=\"labels.minute\"\n          :class=\"nh.be('label')\"\n          aria-hidden=\"true\"\n          @click=\"handleInputFocus('minute')\"\n        >\n          {{ labels.minute }}\n        </div>\n      </template>\n      <template v-if=\"enabled.second\">\n        <div v-if=\"enabled.minute || enabled.hour\" :class=\"nh.be('separator')\" aria-hidden=\"true\">\n          {{ separator }}\n        </div>\n        <div\n          :class=\"[nh.be('unit'), getUnitFocusClass('second')]\"\n          role=\"spinbutton\"\n          :aria-label=\"label.second\"\n          :aria-valuenow=\"props.timeValue.second\"\n          :aria-valuetext=\"formattedSecond\"\n          :aria-valuemin=\"0\"\n          :aria-valuemax=\"59\"\n          :aria-labelledby=\"labeledBy\"\n          @click=\"handleInputFocus('second')\"\n        >\n          {{ formattedSecond }}\n        </div>\n        <div\n          v-if=\"labels.second\"\n          :class=\"nh.be('label')\"\n          aria-hidden=\"true\"\n          @click=\"handleInputFocus('second')\"\n        >\n          {{ labels.second }}\n        </div>\n      </template>\n    </template>\n  </div>\n</template>\n"
    },
    {
      "target": "components/date-picker/time-picker.vue",
      "content": "<script setup lang=\"ts\">\nimport { Button } from '@/components/button'\nimport { useFieldStore } from '@/components/form'\nimport { Icon } from '@/components/icon'\n\nimport { Popper } from '@/components/popper'\n\nimport { computed, nextTick, reactive, ref, toRef, watch } from 'vue'\n\nimport {\n  createIconProp,\n  createSizeProp,\n  createStateProp,\n  emitEvent,\n  makeSentence,\n  useIcons,\n  useLocale,\n  useNameHelper,\n  useProps,\n  useWordSpace\n} from '@pocui/config'\nimport { placementWhileList, useClickOutside, useHover, usePopper, useSetTimeout } from '@pocui/hooks'\nimport { USE_TOUCH, boundRange, callIfFunc, doubleDigits, toAttrValue } from '@pocui/utils'\n\nimport { useColumn, useTimeBound } from './helper'\nimport { timePickerProps } from './props'\n\nimport { TIME_REG } from './symbol'\n\nimport TimeControl from './time-control.vue'\n\nimport TimeWheel from './time-wheel.vue'\n\nimport type { TimePickerChangeEvent, TimeType } from './symbol'\n\nimport type { PopperExposed } from '@/components/popper'\n\ndefineOptions({ name: 'TimePicker',\n  description: '当你需要选择时间或时间范围时会用到它。',\n  categories: ['form'] })\n\nconst { idFor, labelId, state, disabled, loading, size, validateField, clearField, getFieldValue, setFieldValue } =\n  useFieldStore<string | string[]>(() => reference.value?.focus())\n\nconst nh = useNameHelper('time-picker')\n\nconst _props = defineProps(timePickerProps)\nconst props = useProps('timePicker', _props, {\n  size: createSizeProp(size),\n  state: createStateProp(state),\n  locale: null,\n  visible: false,\n  placement: {\n    default: 'bottom-start',\n    validator: value => placementWhileList.includes(value)\n  },\n  transfer: false,\n  format: 'HH:mm:ss',\n  separator: ':',\n  value: {\n    default: () => getFieldValue(),\n    static: true\n  },\n  filler: {\n    default: '-',\n    validator: value => value.length === 1\n  },\n  clearable: false,\n  noAction: false,\n  noArrow: false,\n  pointer: USE_TOUCH,\n  candidate: {\n    default: 3,\n    validator: value => [0, 1, 2, 3].includes(value)\n  },\n  steps: () => [1, 1, 1],\n  labels: () => ({}),\n  shortcuts: () => [],\n  range: null,\n  disabled: () => disabled.value,\n  transitionName: () => nh.ns('drop'),\n  confirmText: null,\n  cancelText: null,\n  ctrlSteps: () => [5, 5, 5],\n  prefix: createIconProp(),\n  prefixColor: '',\n  suffix: createIconProp(),\n  suffixColor: '',\n  noSuffix: false,\n  exchange: false,\n  loading: () => loading.value,\n  loadingIcon: createIconProp(),\n  loadingLock: false,\n  loadingEffect: null,\n  min: null,\n  max: null,\n  outsideClose: true,\n  outsideCancel: false,\n  placeholder: null,\n  unitReadonly: false,\n  popperAlive: null,\n  shortcutsPlacement: 'left'\n})\n\nconst emit = defineEmits(['update:value', 'update:visible'])\n\nconst slots = defineSlots<{\n  prefix(): any,\n  exchange(): any,\n  suffix(): any\n}>()\n\nconst locale = useLocale('timePicker', toRef(props, 'locale'))\nconst icons = useIcons()\nconst wordSpace = useWordSpace()\n\nconst placement = toRef(props, 'placement')\nconst transfer = toRef(props, 'transfer')\nconst currentVisible = ref(props.visible)\nconst focused = ref(false)\nconst lastValue = ref('')\nconst startState = createTimeState()\nconst endState = createTimeState()\nconst currentState = ref<'start' | 'end'>('start')\nconst staticWheel = ref(false)\n\nconst { timer } = useSetTimeout()\n\nconst wrapper = useClickOutside(handleClickOutside)\nconst popper = ref<PopperExposed>()\nconst { reference, transferTo, updatePopper } = usePopper({\n  placement,\n  transfer,\n  wrapper,\n  popper: computed(() => popper.value?.wrapper),\n  isDrop: true\n})\nconst { isHover } = useHover(reference)\nconst { isTimeDisabled } = useTimeBound(toRef(props, 'min'), toRef(props, 'max'))\n\nconst startInput = ref<InstanceType<typeof TimeControl>>()\nconst endInput = ref<InstanceType<typeof TimeControl>>()\n\nconst startPlaceholder = computed(() => {\n  if (props.placeholder) {\n    return Array.isArray(props.placeholder) ? props.placeholder[0] : props.placeholder\n  }\n\n  const { select, start, time } = locale.value.placeholder\n\n  return makeSentence(props.range ? `${start} ${time}` : `${select} ${time}`, wordSpace.value)\n})\nconst endPlaceholder = computed(() => {\n  if (props.placeholder) {\n    return Array.isArray(props.placeholder) ? props.placeholder[1] || props.placeholder[0] : props.placeholder\n  }\n\n  const { end, time } = locale.value.placeholder\n\n  return makeSentence(`${end} ${time}`, wordSpace.value)\n})\nconst className = computed(() => {\n  return [\n    nh.b(),\n    nh.ns('input-vars'),\n    nh.bs('vars'),\n    {\n      [nh.in()]: props.inherit,\n      [nh.bm('disabled')]: props.disabled,\n      [nh.bm(props.size)]: props.size !== 'default',\n      [nh.bm('no-hour')]: !startState.enabled.hour,\n      [nh.bm('no-minute')]: !startState.enabled.minute,\n      [nh.bm('no-second')]: !startState.enabled.second,\n      [nh.bm('visible')]: currentVisible.value,\n      [nh.bm(props.state)]: props.state !== 'default',\n      [nh.bm('is-range')]: props.range\n    }\n  ]\n})\nconst readonly = computed(() => props.loading && props.loadingLock)\nconst selectorClass = computed(() => {\n  const baseCls = nh.be('selector')\n\n  return {\n    [baseCls]: true,\n    [`${baseCls}--disabled`]: props.disabled,\n    [`${baseCls}--readonly`]: readonly.value,\n    [`${baseCls}--loading`]: props.loading,\n    [`${baseCls}--${props.size}`]: props.size !== 'default',\n    [`${baseCls}--focused`]: focused.value,\n    [`${baseCls}--${props.state}`]: props.state !== 'default'\n  }\n})\nconst hasPrefix = computed(() => {\n  return !!(slots.prefix || props.prefix)\n})\nconst currentValue = computed(() => {\n  const values = [startState, endState].map(state => {\n    return Object.values(state.timeValue).map(doubleDigits).join(':')\n  })\n\n  return props.range ? values : values[0]\n})\nconst showClear = computed(() => {\n  return !props.disabled && !readonly.value && props.clearable && isHover.value && !!lastValue.value\n})\nconst startError = computed(() => {\n  const { hour, minute, second } = startState.timeValue\n\n  return isTimeDisabled.hour(hour) || isTimeDisabled.minute(hour, minute) || isTimeDisabled.second(hour, minute, second)\n})\nconst endError = computed(() => {\n  if (!props.range) return false\n\n  const { hour, minute, second } = endState.timeValue\n\n  return isTimeDisabled.hour(hour) || isTimeDisabled.minute(hour, minute) || isTimeDisabled.second(hour, minute, second)\n})\n\nwatch(\n  () => props.value,\n  value => {\n    parseValue(value)\n    lastValue.value = (Array.isArray(value) ? value[0] || value[1] : value) ? getStringValue() : ''\n  },\n  { immediate: true }\n)\nwatch(() => props.format, parseFormat, { immediate: true })\nwatch(\n  () => props.visible,\n  value => {\n    currentVisible.value = value\n  }\n)\nwatch(currentVisible, value => {\n  if (value) {\n    updatePopper()\n  }\n})\nwatch(focused, value => {\n  if (value) {\n    emitEvent(props.onFocus)\n  } else {\n    emitEvent(props.onBlur)\n  }\n})\nwatch(currentState, value => {\n  if (!props.unitReadonly && currentVisible.value) {\n    emitEvent(props.onChangeCol, getCurrentState().column, value)\n  }\n})\nwatch(\n  () => startState.column,\n  value => {\n    if (!props.unitReadonly && currentVisible.value && currentState.value === 'start') {\n      emitEvent(props.onChangeCol, value, 'start')\n    }\n  }\n)\nwatch(\n  () => endState.column,\n  value => {\n    if (!props.unitReadonly && currentVisible.value && currentState.value === 'end') {\n      emitEvent(props.onChangeCol, value, 'end')\n    }\n  }\n)\nwatch(\n  () => props.disabled,\n  value => {\n    if (value) {\n      setVisible(false)\n      handleBlur()\n    }\n  }\n)\nwatch(readonly, value => {\n  if (value) {\n    setVisible(false)\n  }\n})\n\ndefineExpose({\n  idFor,\n  isHover,\n  currentVisible,\n  focused,\n  startState,\n  endState,\n  currentState,\n  currentValue,\n  startError,\n  endError,\n  wrapper,\n  reference,\n  popper,\n  start: startInput,\n  end: endInput,\n  updatePopper,\n  focus: (options?: FocusOptions) => reference.value?.focus(options),\n  blur: () => reference.value?.blur()\n})\n\nfunction createTimeState() {\n  const { currentColumn, enabled, resetColumn, enterColumn } = useColumn(['hour', 'minute', 'second'] as TimeType[])\n\n  const timeValue = reactive({\n    hour: 0,\n    minute: 0,\n    second: 0\n  })\n  const activated = reactive({\n    hour: false,\n    minute: false,\n    second: false\n  })\n\n  return reactive({\n    column: currentColumn,\n    enabled,\n    activated,\n    timeValue,\n    resetColumn,\n    enterColumn\n  })\n}\n\nfunction getCurrentState() {\n  return currentState.value === 'start' ? startState : endState\n}\n\nfunction parseValue<T extends string | null>(value: T | T[]) {\n  if (!Array.isArray(value)) {\n    value = [value, value]\n  }\n\n  const defaultDate = new Date()\n\n  for (let i = 0; i < 2; ++i) {\n    const match = TIME_REG.exec(value[i] || '')\n    const state = i === 0 ? startState : endState\n    const { timeValue } = state\n\n    if (match) {\n      toggleActivated(true, i === 0 ? 'start' : 'end')\n\n      const hour = parseInt(match[1])\n      const minute = match[2] ? parseInt(match[2].slice(1)) : 0\n      const second = match[3] ? parseInt(match[3].slice(1)) : 0\n\n      const date = new Date(2000, 1, 1, hour, minute, second)\n\n      timeValue.hour = date.getHours()\n      timeValue.minute = date.getMinutes()\n      timeValue.second = date.getSeconds()\n    } else {\n      timeValue.hour = defaultDate.getHours()\n      timeValue.minute = defaultDate.getMinutes()\n      timeValue.second = defaultDate.getSeconds()\n\n      toggleActivated(false, i === 0 ? 'start' : 'end')\n    }\n\n    if (!props.range) break\n  }\n}\n\nfunction parseFormat() {\n  ;[startState, endState].forEach(state => {\n    state.enabled.hour = props.format.includes('H')\n    state.enabled.minute = props.format.includes('m')\n    state.enabled.second = props.format.includes('s')\n  })\n}\n\nfunction toggleActivated(value: boolean, valueType?: 'start' | 'end') {\n  const states = valueType ? (valueType === 'start' ? [startState] : [endState]) : [startState, endState]\n\n  states.forEach(state => {\n    ;(Object.keys(state.activated) as TimeType[]).forEach(type => {\n      state.activated[type] = value\n    })\n  })\n}\n\nfunction getStringValue() {\n  return Array.isArray(currentValue.value) ? currentValue.value.join('|') : currentValue.value\n}\n\nfunction verifyTime() {\n  if (startError.value || (props.range && endError.value)) {\n    parseValue(props.value)\n  }\n}\n\nfunction setVisible(visible: boolean) {\n  if (currentVisible.value === visible) return\n\n  currentVisible.value = visible\n\n  emit('update:visible', visible)\n  emitEvent(props.onToggle, visible)\n}\n\nfunction emitChange() {\n  verifyTime()\n\n  if (lastValue.value !== getStringValue()) {\n    lastValue.value = getStringValue()\n\n    toggleActivated(true)\n    emit('update:value', currentValue.value)\n    setFieldValue(currentValue.value)\n    emitEvent(props.onChange as TimePickerChangeEvent, currentValue.value)\n    validateField()\n  }\n}\n\nfunction handleFocused() {\n  if (props.disabled) return\n\n  focused.value = true\n\n  timer.focus = setTimeout(() => {\n    if (focused.value) {\n      if (currentState.value === 'start') {\n        startInput.value?.focus()\n      } else {\n        endInput.value?.focus()\n      }\n    }\n  }, 120)\n}\n\nfunction handleBlur() {\n  clearTimeout(timer.focus)\n\n  focused.value = false\n  startInput.value?.blur()\n  endInput.value?.blur()\n}\n\nfunction showPanel(event: Event) {\n  if (props.disabled || readonly.value) return\n\n  const target = event.target as Node\n\n  setVisible(true)\n  handleFocused()\n\n  if (wrapper.value && target) {\n    const units = Array.from(wrapper.value.querySelectorAll(`.${nh.be('unit')}`))\n\n    if (!units.some(unit => unit === target || unit.contains(target))) {\n      startState.column = null\n      endState.column = null\n    }\n  }\n}\n\nfunction finishInput(shouldChange = true) {\n  setVisible(false)\n\n  shouldChange && emitChange()\n  startState.resetColumn()\n  endState.resetColumn()\n}\n\nfunction handleClear(finish = true) {\n  if (props.disabled || readonly.value) return\n\n  if (props.clearable) {\n    nextTick(() => {\n      const emitValue = props.range ? ([] as string[]) : ''\n\n      parseValue(null)\n      finish && finishInput(false)\n      emit('update:value', emitValue)\n      emitEvent(props.onChange as TimePickerChangeEvent, emitValue)\n      emitEvent(props.onClear)\n      clearField(emitValue)\n      finish && handleBlur()\n\n      lastValue.value = ''\n\n      nextTick(() => {\n        toggleActivated(false)\n      })\n    })\n  }\n}\n\nfunction handleWheelChange(type: TimeType) {\n  if (currentVisible.value) {\n    getCurrentState().activated[type] = true\n  }\n}\n\nfunction handleInputFocus(type: TimeType) {\n  getCurrentState().column = type\n}\n\nfunction handleInput(value: number) {\n  const state = getCurrentState()\n  const type = state.column\n\n  if (!type) return\n\n  handleInputNumber(type, value)\n\n  if (state.column !== 'second' && state.timeValue[type] >= 10) {\n    state.enterColumn('next', false)\n  }\n}\n\nfunction handleInputNumber(type: TimeType, number: number) {\n  const state = getCurrentState()\n  const prev = state.timeValue[type]\n\n  if (state.activated[type] && prev > 0 && prev < 10) {\n    state.timeValue[type] = prev * 10 + number\n  } else {\n    state.timeValue[type] = number\n  }\n\n  verifyValue(type)\n\n  state.activated[type] = true\n  emitEvent(props.onInput, type, state.timeValue[type])\n}\n\nfunction verifyValue(type: TimeType) {\n  const timeValue = getCurrentState().timeValue\n\n  timeValue[type] = boundRange(timeValue[type], 0, type === 'hour' ? 23 : 59)\n  timeValue[type] = Math.round(timeValue[type] / getStep(type)) * getStep(type)\n}\n\nfunction handlePlus(ctrlKey: boolean) {\n  const state = getCurrentState()\n  const type = state.column\n\n  if (!type) return\n\n  if (state.enabled[type]) {\n    state.timeValue[type] += ctrlKey ? getCtrlStep(type) : getStep(type)\n\n    verifyValue(type)\n    emitEvent(props.onPlus, type, state.timeValue[type])\n  }\n}\n\nfunction handleMinus(ctrlKey: boolean) {\n  const state = getCurrentState()\n  const type = state.column\n\n  if (!type) return\n\n  if (state.enabled[type]) {\n    state.timeValue[type] -= ctrlKey ? getCtrlStep(type) : getStep(type)\n\n    verifyValue(type)\n    emitEvent(props.onMinus, type, state.timeValue[type])\n  }\n}\n\nfunction getStep(type: TimeType) {\n  return props.steps[type === 'hour' ? 0 : type === 'minute' ? 1 : 2] || 1\n}\n\nfunction getCtrlStep(type: TimeType) {\n  return props.ctrlSteps[type === 'hour' ? 0 : type === 'minute' ? 1 : 2] || 1\n}\n\nfunction fallbackFocus() {\n  requestAnimationFrame(() => {\n    handleBlur()\n    reference.value?.focus()\n  })\n}\n\nfunction handleEnter() {\n  fallbackFocus()\n  finishInput()\n  emitEvent(props.onEnter)\n}\n\nfunction handleCancel() {\n  fallbackFocus()\n  parseValue(props.value)\n  finishInput(false)\n  emitEvent(props.onCancel)\n}\n\nfunction handleShortcut(index: number) {\n  const { value, name } = props.shortcuts[index]\n  const parsedValue = callIfFunc(value)\n\n  fallbackFocus()\n  parseValue(parsedValue)\n  emitEvent(props.onShortcut as (name: string, value: string | string[]) => void, name, parsedValue)\n  finishInput()\n}\n\nfunction toggleCurrentState(type: 'start' | 'end') {\n  currentState.value = type\n}\n\nfunction enterColumn(type: 'prev' | 'next') {\n  if (props.range) {\n    if (type === 'prev' && currentState.value === 'start' && !startState.column) {\n      toggleCurrentState('end')\n    }\n\n    const state = getCurrentState()\n    const currentColumn = state.column\n\n    state.enterColumn(type, !currentColumn)\n\n    if (currentColumn === state.column) {\n      const isStart = currentState.value === 'start'\n      const otherState = isStart ? endState : startState\n\n      otherState.resetColumn(type === 'prev' ? 'second' : 'hour', type === 'prev')\n      toggleCurrentState(isStart ? 'end' : 'start')\n    }\n  } else {\n    startState.enterColumn(type)\n  }\n}\n\nfunction handleStartInput(type: TimeType) {\n  toggleCurrentState('start')\n  handleInputFocus(type)\n}\n\nfunction handleEndInput(type: TimeType) {\n  toggleCurrentState('end')\n  handleInputFocus(type)\n}\n\nfunction exchangeValue() {\n  ;(Object.keys(startState.timeValue) as TimeType[]).forEach(type => {\n    const temp = endState.timeValue[type]\n    endState.timeValue[type] = startState.timeValue[type]\n    startState.timeValue[type] = temp\n  })\n}\n\nfunction handleExchangeClick(event: MouseEvent) {\n  if (props.exchange) {\n    !currentVisible.value && event.stopPropagation()\n    exchangeValue()\n  }\n}\n\nfunction handleClickOutside() {\n  emitEvent(props.onClickOutside)\n\n  if (props.outsideClose && currentVisible.value) {\n    finishInput(!props.outsideCancel)\n    handleBlur()\n    emitEvent(props.onOutsideClose)\n  }\n}\n</script>\n\n<template>\n  <div\n    :id=\"idFor\"\n    ref=\"wrapper\"\n    :class=\"className\"\n    role=\"group\"\n    :aria-disabled=\"toAttrValue(props.disabled)\"\n    :aria-expanded=\"toAttrValue(currentVisible)\"\n    aria-haspopup=\"dialog\"\n    :aria-labelledby=\"labelId\"\n    @click=\"showPanel\"\n  >\n    <div\n      ref=\"reference\"\n      :class=\"selectorClass\"\n      tabindex=\"0\"\n      @keydown.space.prevent=\"showPanel\"\n      @keydown.backspace.prevent=\"handleClear(false)\"\n    >\n      <div v-if=\"hasPrefix\" :class=\"[nh.be('icon'), nh.be('prefix')]\" :style=\"{ color: props.prefixColor }\">\n        <slot name=\"prefix\">\n          <Icon :icon=\"props.prefix\"></Icon>\n        </slot>\n      </div>\n      <div :class=\"nh.be('control')\">\n        <TimeControl\n          ref=\"startInput\"\n          :unit-type=\"currentState === 'start' ? startState.column! : ''\"\n          :enabled=\"startState.enabled\"\n          :activated=\"startState.activated\"\n          :time-value=\"startState.timeValue\"\n          :steps=\"props.steps\"\n          :ctrl-steps=\"props.ctrlSteps\"\n          :focused=\"focused\"\n          :visible=\"currentVisible\"\n          :separator=\"props.separator\"\n          :filler=\"props.filler\"\n          :labels=\"props.labels\"\n          :has-error=\"startError\"\n          :placeholder=\"startPlaceholder\"\n          :readonly=\"props.unitReadonly\"\n          :labeled-by=\"labelId\"\n          :locale=\"locale\"\n          @input=\"handleInput\"\n          @plus=\"handlePlus\"\n          @minus=\"handleMinus\"\n          @enter=\"handleEnter\"\n          @cancel=\"handleCancel\"\n          @unit-focus=\"handleStartInput\"\n          @prev-unit=\"enterColumn('prev')\"\n          @next-unit=\"enterColumn('next')\"\n          @blur=\"startState.column = null\"\n        ></TimeControl>\n        <template v-if=\"props.range\">\n          <div\n            :class=\"[nh.be('exchange'), props.exchange ? nh.bem('exchange', 'enabled') : '']\"\n            @click=\"handleExchangeClick\"\n          >\n            <slot name=\"exchange\">\n              <Icon v-bind=\"icons.exchange\" style=\"padding-top: 1px\"></Icon>\n            </slot>\n          </div>\n          <TimeControl\n            ref=\"endInput\"\n            :unit-type=\"currentState === 'end' ? endState.column! : ''\"\n            :enabled=\"endState.enabled\"\n            :activated=\"endState.activated\"\n            :time-value=\"endState.timeValue\"\n            :steps=\"props.steps\"\n            :ctrl-steps=\"props.ctrlSteps\"\n            :focused=\"focused\"\n            :visible=\"currentVisible\"\n            :separator=\"props.separator\"\n            :filler=\"props.filler\"\n            :labels=\"props.labels\"\n            :has-error=\"endError\"\n            :placeholder=\"endPlaceholder\"\n            :readonly=\"props.unitReadonly\"\n            :labeled-by=\"labelId\"\n            :locale=\"locale\"\n            @input=\"handleInput\"\n            @plus=\"handlePlus\"\n            @minus=\"handleMinus\"\n            @enter=\"handleEnter\"\n            @cancel=\"handleCancel\"\n            @unit-focus=\"handleEndInput\"\n            @prev-unit=\"enterColumn('prev')\"\n            @next-unit=\"enterColumn('next')\"\n            @blur=\"endState.column = null\"\n          ></TimeControl>\n        </template>\n      </div>\n      <div\n        v-if=\"!props.noSuffix\"\n        :class=\"[nh.be('icon'), nh.be('suffix')]\"\n        :style=\"{\n          color: props.suffixColor,\n          opacity: showClear || props.loading ? '0%' : ''\n        }\"\n      >\n        <slot name=\"suffix\">\n          <Icon v-bind=\"icons.clock\" :icon=\"props.suffix || icons.clock.icon\"></Icon>\n        </slot>\n      </div>\n      <div\n        v-else-if=\"props.clearable || props.loading\"\n        :class=\"[nh.be('icon'), nh.bem('icon', 'placeholder'), nh.be('suffix')]\"\n      ></div>\n      <Transition :name=\"nh.ns('fade')\" appear>\n        <button\n          v-if=\"showClear\"\n          :class=\"[nh.be('icon'), nh.be('clear')]\"\n          type=\"button\"\n          tabindex=\"-1\"\n          :aria-label=\"locale.ariaLabel.clear\"\n          @click.stop=\"handleClear()\"\n        >\n          <Icon v-bind=\"icons.clear\"></Icon>\n        </button>\n        <div v-else-if=\"props.loading\" :class=\"[nh.be('icon'), nh.be('loading')]\">\n          <Icon\n            v-bind=\"icons.loading\"\n            :effect=\"props.loadingEffect || icons.loading.effect\"\n            :icon=\"props.loadingIcon || icons.loading.icon\"\n          ></Icon>\n        </div>\n      </Transition>\n    </div>\n    <Popper\n      ref=\"popper\"\n      :class=\"[nh.be('popper'), nh.bs('vars')]\"\n      :visible=\"currentVisible\"\n      :to=\"transferTo\"\n      :transition=\"props.transitionName\"\n      :alive=\"props.popperAlive ?? !transferTo\"\n      @click.stop=\"handleFocused\"\n      @before-enter=\"staticWheel = true\"\n      @before-leave=\"staticWheel = true\"\n      @after-enter=\"staticWheel = false\"\n      @after-leave=\"staticWheel = false\"\n    >\n      <div\n        :class=\"{\n          [nh.be('panel')]: true,\n          [nh.bem('panel', 'vertical')]:\n            props.shortcuts.length && (props.shortcutsPlacement === 'top' || props.shortcutsPlacement === 'bottom')\n        }\"\n        :aria-labelledby=\"labelId\"\n      >\n        <div\n          v-if=\"props.shortcuts.length\"\n          :class=\"[\n            nh.be('list'),\n            nh.bem('list', 'sub'),\n            nh.be('shortcuts'),\n            nh.bem('shortcuts', props.shortcutsPlacement)\n          ]\"\n        >\n          <div\n            v-for=\"(item, index) in props.shortcuts\"\n            :key=\"index\"\n            :class=\"nh.be('shortcut')\"\n            :title=\"item.name\"\n            @click=\"handleShortcut(index)\"\n          >\n            {{ item.name }}\n          </div>\n        </div>\n        <div :class=\"nh.be('list')\">\n          <div :class=\"nh.be('wheels')\">\n            <TimeWheel\n              v-model:hour=\"startState.timeValue.hour\"\n              v-model:minute=\"startState.timeValue.minute\"\n              v-model:second=\"startState.timeValue.second\"\n              :no-arrow=\"props.noArrow\"\n              :candidate=\"props.candidate\"\n              :steps=\"props.steps\"\n              :pointer=\"props.pointer\"\n              :disabled-time=\"isTimeDisabled\"\n              :no-transition=\"staticWheel\"\n              @change=\"handleWheelChange\"\n              @toggle-col=\"toggleCurrentState('start')\"\n            ></TimeWheel>\n            <TimeWheel\n              v-if=\"props.range\"\n              v-model:hour=\"endState.timeValue.hour\"\n              v-model:minute=\"endState.timeValue.minute\"\n              v-model:second=\"endState.timeValue.second\"\n              :no-arrow=\"props.noArrow\"\n              :candidate=\"props.candidate\"\n              :steps=\"props.steps\"\n              :pointer=\"props.pointer\"\n              :disabled-time=\"isTimeDisabled\"\n              :no-transition=\"staticWheel\"\n              @change=\"handleWheelChange\"\n              @toggle-col=\"toggleCurrentState('end')\"\n            ></TimeWheel>\n          </div>\n          <div v-if=\"!props.noAction\" :class=\"nh.be('action')\">\n            <Button\n              inherit\n              text\n              size=\"small\"\n              @click.stop=\"handleCancel\"\n            >\n              {{ props.cancelText || locale.cancel }}\n            </Button>\n            <Button\n              inherit\n              type=\"primary\"\n              size=\"small\"\n              :disabled=\"startError || endError\"\n              @click.stop=\"handleEnter\"\n            >\n              {{ props.confirmText || locale.confirm }}\n            </Button>\n          </div>\n        </div>\n      </div>\n    </Popper>\n  </div>\n</template>\n"
    },
    {
      "target": "components/date-picker/time-wheel.vue",
      "content": "<script setup lang=\"ts\">\nimport { Wheel } from '@/components/wheel'\n\nimport { ref, watch } from 'vue'\n\nimport { useNameHelper } from '@pocui/config'\n\nimport { USE_TOUCH, doubleDigits, range } from '@pocui/utils'\n\nimport type { WheelExposed } from '@/components/wheel'\n\nimport type { PropType } from 'vue'\n\nimport type { DisabledTime, TimeType } from './symbol'\n\ndefineOptions({ name: 'TimeWheel',\n  description:'虚拟滚轮面板，提供时/分/秒三列无限滚动与缓动动画，精确到秒级选择。',\n  categories: ['form'] })\n\nconst props = defineProps({\n  noArrow: {\n    type: Boolean,\n    default: false\n  },\n  hour: {\n    type: Number,\n    default: 0,\n    validator: (value: number) => value >= 0 && value <= 23\n  },\n  minute: {\n    type: Number,\n    default: 0,\n    validator: (value: number) => value >= 0 && value <= 59\n  },\n  second: {\n    type: Number,\n    default: 0,\n    validator: (value: number) => value >= 0 && value <= 59\n  },\n  candidate: {\n    default: 2 as 0 | 1 | 2 | 3,\n    validator: (value: number) => [0, 1, 2, 3].includes(value)\n  },\n  steps: {\n    type: Array as PropType<number[]>,\n    default: () => [1, 1, 1],\n    validator: (value: [number, number, number]) => {\n      if (value[0] && 24 % value[0] !== 0) {\n        return false\n      }\n\n      for (let i = 1; i < 3; ++i) {\n        if (value[i] && 60 % value[i] !== 0) {\n          return false\n        }\n      }\n\n      return true\n    }\n  },\n  pointer: {\n    type: Boolean,\n    default: USE_TOUCH\n  },\n  disabledTime: {\n    type: Object as PropType<DisabledTime>,\n    default: () => ({})\n  },\n  noTransition: {\n    type: Boolean,\n    default: false\n  }\n})\n\nconst emit = defineEmits(['change', 'toggle-col', 'update:hour', 'update:minute', 'update:second'])\n\nconst nh = useNameHelper('time-picker')\n\nconst currentHour = ref(props.hour)\nconst currentMinute = ref(props.minute)\nconst currentSecond = ref(props.second)\nconst hourRange = ref<number[]>([])\nconst minuteRange = ref<number[]>([])\nconst secondRange = ref<number[]>([])\n\nconst hourWheel = ref<WheelExposed>()\nconst minuteWheel = ref<WheelExposed>()\nconst secondWheel = ref<WheelExposed>()\n\nwatch(() => props.steps, updateTimeRange, { immediate: true })\nwatch(\n  () => props.hour,\n  value => {\n    currentHour.value = value\n  }\n)\nwatch(\n  () => props.minute,\n  value => {\n    currentMinute.value = value\n  }\n)\nwatch(\n  () => props.second,\n  value => {\n    currentSecond.value = value\n  }\n)\nwatch(currentHour, value => {\n  emit('update:hour', value)\n  emit('change', 'hour', value)\n})\nwatch(currentMinute, value => {\n  emit('update:minute', value)\n  emit('change', 'minute', value)\n})\nwatch(currentSecond, value => {\n  emit('update:second', value)\n  emit('change', 'second', value)\n})\n\ndefineExpose({ refreshWheel })\n\nfunction isHourDisabled(hour: number) {\n  return typeof props.disabledTime.hour === 'function' && props.disabledTime.hour(hour)\n}\n\nfunction isMinuteDisabled(minute: number) {\n  return typeof props.disabledTime.minute === 'function' && props.disabledTime.minute(currentHour.value, minute)\n}\n\nfunction isSecondDisabled(second: number) {\n  return (\n    typeof props.disabledTime.second === 'function' &&\n    props.disabledTime.second(currentHour.value, currentMinute.value, second)\n  )\n}\n\nfunction updateTimeRange() {\n  const [hourStep = 1, minuteStep = 1, secondStep = 1] = props.steps\n\n  hourRange.value = range(24 / hourStep, 0, hourStep)\n  minuteRange.value = range(60 / minuteStep, 0, minuteStep)\n  secondRange.value = range(60 / secondStep, 0, secondStep)\n}\n\nfunction handleToggleColumn(type: TimeType) {\n  emit('toggle-col', type)\n}\n\nfunction refreshWheel() {\n  ;[hourWheel.value, minuteWheel.value, secondWheel.value].forEach(wheel => {\n    wheel?.refreshScroll()\n  })\n}\n</script>\n\n<template>\n  <div :class=\"nh.be('wheel')\">\n    <Wheel\n      ref=\"hourWheel\"\n      v-model:value=\"currentHour\"\n      inherit\n      :pointer=\"pointer\"\n      :arrow=\"!noArrow\"\n      :candidate=\"candidate\"\n      :options=\"hourRange\"\n      tabindex=\"-1\"\n      :no-transition=\"noTransition\"\n      @mouseenter=\"handleToggleColumn('hour')\"\n      @touchstart=\"handleToggleColumn('hour')\"\n      @keydown.stop\n      @item-click=\"currentHour = $event\"\n    >\n      <template #default=\"{ option }\">\n        <span :class=\"[nh.be('option'), isHourDisabled(option.value as number) && nh.bem('option', 'disabled')]\">\n          {{ doubleDigits(option.value as number) }}\n        </span>\n      </template>\n    </Wheel>\n    <Wheel\n      ref=\"minuteWheel\"\n      v-model:value=\"currentMinute\"\n      inherit\n      :pointer=\"pointer\"\n      :arrow=\"!noArrow\"\n      :candidate=\"candidate\"\n      :options=\"minuteRange\"\n      tabindex=\"-1\"\n      :no-transition=\"noTransition\"\n      @mouseenter=\"handleToggleColumn('minute')\"\n      @touchstart=\"handleToggleColumn('minute')\"\n      @keydown.stop\n      @item-click=\"currentMinute = $event\"\n    >\n      <template #default=\"{ option }\">\n        <span :class=\"[nh.be('option'), isMinuteDisabled(option.value as number) && nh.bem('option', 'disabled')]\">\n          {{ doubleDigits(option.value as number) }}\n        </span>\n      </template>\n    </Wheel>\n    <Wheel\n      ref=\"secondWheel\"\n      v-model:value=\"currentSecond\"\n      inherit\n      :pointer=\"pointer\"\n      :arrow=\"!noArrow\"\n      :candidate=\"candidate\"\n      :options=\"secondRange\"\n      tabindex=\"-1\"\n      :no-transition=\"noTransition\"\n      @mouseenter=\"handleToggleColumn('second')\"\n      @touchstart=\"handleToggleColumn('second')\"\n      @keydown.stop\n      @item-click=\"currentSecond = $event\"\n    >\n      <template #default=\"{ option }\">\n        <span :class=\"[nh.be('option'), isSecondDisabled(option.value as number) && nh.bem('option', 'disabled')]\">\n          {{ doubleDigits(option.value as number) }}\n        </span>\n      </template>\n    </Wheel>\n  </div>\n</template>\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/utils", "@pocui/hooks"],
  "registryDependencies": [
    "date-picker.scss",
    "button",
    "calendar-panel",
    "icon",
    "calendar",
    "form",
    "popper",
    "wheel"
  ],
  "categories": ["form"],
  "meta": { "isReferenceOnly": false }
}
