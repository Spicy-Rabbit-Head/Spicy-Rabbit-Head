{
  "name": "collapse",
  "type": "registry:component",
  "description": "用于将内容进行折叠和展开，节省页面空间。",
  "files": [
    {
      "target": "components/collapse/collapse-panel.vue",
      "content": "<script lang=\"ts\">\nimport { CollapseTransition } from '@/components/collapse-transition'\nimport { Icon } from '@/components/icon'\n\nimport { computed, defineComponent, inject, onBeforeUnmount, reactive, ref, watch } from 'vue'\n\nimport { createIconProp, emitEvent, useIcons, useNameHelper, useProps } from '@pocui/config'\n\nimport { collapsePanelProps } from './props'\n\nimport { COLLAPSE_STATE } from './symbol'\n\nimport type { SlotsType } from 'vue'\n\nimport type { CollapseArrowType, PanelState } from './symbol'\n\nlet idCount = 0\n\nexport default defineComponent({\n  name: 'CollapsePanel',\n  description: 'Collapse 子面板组件，提供可点击的标题栏与内容区域。',\n  categories: ['display'],\n  components: {\n    CollapseTransition,\n    Icon\n  },\n  props: collapsePanelProps,\n  slots: Object as SlotsType<{\n    default(): any,\n    title(): any\n  }>,\n  emits: ['update:expanded'],\n  setup(_props, { emit }) {\n    const props = useProps('collapsePanel', _props, {\n      label: {\n        default: null,\n        static: true\n      },\n      title: '',\n      disabled: false,\n      contentStyle: null,\n      expanded: false,\n      card: false,\n      arrowType: {\n        default: 'right' as CollapseArrowType,\n        validator: (value: CollapseArrowType) => ['right', 'left', 'none'].includes(value)\n      },\n      icon: createIconProp(),\n      ghost: false\n    })\n\n    const collapseState = inject(COLLAPSE_STATE, null)\n\n    const nh = useNameHelper('collapse')\n    const icons = useIcons()\n    const currentExpanded = ref(props.expanded)\n    const currentLabel = ref(props.label)\n    const tab = ref<HTMLElement>()\n\n    const id = idCount++\n\n    const tabId = computed(() => `${nh.be('tab')}-${id}`)\n    const bodyId = computed(() => `${nh.be('body')}-${id}`)\n    const useCard = computed(() => {\n      if (!collapseState) {\n        return props.card\n      }\n\n      return false\n    })\n    const useGhost = computed(() => {\n      if (!collapseState) {\n        return props.ghost\n      }\n\n      return false\n    })\n    const useArrowType = computed(() => {\n      if (collapseState) {\n        return collapseState.arrowType\n      }\n\n      return props.arrowType\n    })\n    const className = computed(() => {\n      return [\n        nh.be('panel'),\n        nh.bs('vars'),\n        nh.bem('panel', `arrow-${useArrowType.value}`),\n        {\n          [nh.inc()]: collapseState || props.inherit,\n          [nh.bem('panel', 'card')]: useCard.value,\n          [nh.bem('panel', 'ghost')]: !useCard.value && useGhost.value,\n          [nh.bem('panel', 'expanded')]: currentExpanded.value,\n          [nh.bem('panel', 'disabled')]: props.disabled\n        }\n      ]\n    })\n\n    if (collapseState) {\n      const state: PanelState = reactive({\n        tab,\n        label: currentLabel,\n        expanded: currentExpanded,\n        setExpanded\n      })\n\n      watch(\n        () => props.label,\n        value => {\n          const prevValue = currentLabel.value\n          currentLabel.value = value || value === 0 ? value : prevValue\n        }\n      )\n\n      collapseState.registerPanel(state)\n\n      onBeforeUnmount(() => {\n        collapseState.unregisterPanel(state)\n      })\n    } else {\n      watch(\n        () => props.expanded,\n        value => {\n          currentExpanded.value = value\n        }\n      )\n    }\n\n    function setExpanded(expanded: boolean) {\n      currentExpanded.value = expanded\n\n      emit('update:expanded', expanded)\n      emitEvent(props.onToggle, expanded)\n    }\n\n    function handleToggle(expanded = !currentExpanded.value) {\n      if (props.disabled) return\n\n      if (collapseState) {\n        // 由父级进行管理\n        collapseState.expandPanel(currentLabel.value, expanded)\n      } else {\n        setExpanded(expanded)\n      }\n    }\n\n    return {\n      props,\n      nh,\n      currentExpanded,\n      icons,\n      tab,\n      tabId,\n      bodyId,\n      className,\n      handleToggle\n    }\n  }\n})\n</script>\n\n<template>\n  <section :class=\"className\">\n    <button\n      :id=\"tabId\"\n      ref=\"tab\"\n      :class=\"nh.be('header')\"\n      type=\"button\"\n      role=\"tab\"\n      :aria-expanded=\"currentExpanded\"\n      :aria-controls=\"bodyId\"\n      :aria-describedby=\"bodyId\"\n      @click=\"handleToggle()\"\n    >\n      <span :class=\"nh.be('arrow')\">\n        <Icon v-bind=\"icons.angleRight\"></Icon>\n      </span>\n      <slot name=\"title\">\n        <div v-if=\"props.icon\" :class=\"nh.be('icon')\">\n          <Icon :icon=\"props.icon\"></Icon>\n        </div>\n        {{ props.title }}\n      </slot>\n    </button>\n    <CollapseTransition>\n      <div\n        v-if=\"currentExpanded\"\n        :id=\"bodyId\"\n        :class=\"nh.be('body')\"\n        role=\"tabpanel\"\n        tabindex=\"0\"\n        :aria-labelledby=\"tabId\"\n      >\n        <div :class=\"nh.be('content')\" :style=\"props.contentStyle\">\n          <slot></slot>\n        </div>\n      </div>\n    </CollapseTransition>\n  </section>\n</template>\n"
    },
    {
      "target": "components/collapse/collapse-transition.ts",
      "content": "import { Transition, defineComponent, h, renderSlot } from 'vue'\n\nimport { emitEvent, useProps } from '@pocui/config'\nimport { collapseTransitionProps } from './props'\n\nexport default defineComponent({\n  name: 'CollapseTransition',\n  description: '无渲染过渡组件，通过动态测量高度与 max-height 动画，为面板展开/收起提供平滑、可打断、性能友好的折叠动效。',\n  categories: ['other'],\n  props: collapseTransitionProps,\n  emits: [],\n  setup(_props, { slots }) {\n    const props = useProps('collapseTransition', _props, {\n      appear: false,\n      mode: {\n        default: 'default',\n        validator: value => ['in-out', 'out-in', 'default'].includes(value)\n      },\n      horizontal: false,\n      duration: {\n        default: 250,\n        validator: (value: number) => value >= 200\n      },\n      timing: null,\n      fadeEffect: false,\n      reverse: false\n    })\n\n    let enterStage: 'before' | 'in' | null = null\n    let leaveStage: 'before' | 'in' | null = null\n\n    return () => {\n      if (props.disabled) {\n        return renderSlot(slots, 'default')\n      }\n\n      const duration = props.duration\n      const timing = props.timing || 'ease-in-out'\n\n      let height: 'maxWidth' | 'maxHeight' = 'maxHeight'\n      let paddingTop: 'paddingTop' | 'paddingLeft' = 'paddingTop'\n      let paddingBottom: 'paddingRight' | 'paddingBottom' = 'paddingBottom'\n      let marginTop: 'marginTop' | 'marginLeft' = 'marginTop'\n      let marginBottom: 'marginRight' | 'marginBottom' = 'marginBottom'\n      let scrollHeight: 'scrollHeight' | 'scrollWidth' = 'scrollHeight'\n      let transition = `\n        max-height ${duration}ms ${timing},\n        padding-top ${duration}ms ${timing},\n        padding-bottom ${duration}ms ${timing},\n        margin-top ${duration}ms ${timing},\n        margin-bottom ${duration}ms ${timing}\n      `\n\n      if (props.horizontal) {\n        height = 'maxWidth'\n        paddingTop = 'paddingLeft'\n        paddingBottom = 'paddingRight'\n        marginTop = 'marginLeft'\n        marginBottom = 'marginRight'\n        scrollHeight = 'scrollWidth'\n        transition = `\n          max-width ${duration}ms ${timing},\n          padding-inline-start ${duration}ms ${timing},\n          padding-inline-end ${duration}ms ${timing},\n          margin-inline-start ${duration}ms ${timing},\n          margin-inline-end ${duration}ms ${timing}\n        `\n      }\n\n      if (props.fadeEffect) {\n        transition = `\n          ${transition},\n          opacity ${duration}ms ease\n        `\n      }\n\n      const enterRecord: Partial<CSSStyleDeclaration> = {}\n      const leaveRecord: Partial<CSSStyleDeclaration> = {}\n\n      return h(\n        Transition,\n        {\n          appear: props.appear,\n          mode: props.mode,\n          onBeforeEnter($el) {\n            if (enterStage) return\n\n            enterStage = 'before'\n            const el = $el as HTMLElement\n\n            enterRecord.paddingTop = el.style[paddingTop]\n            enterRecord.paddingBottom = el.style[paddingBottom]\n            enterRecord.marginTop = el.style[marginTop]\n            enterRecord.marginBottom = el.style[marginBottom]\n            enterRecord.transition = el.style.transition\n            enterRecord.boxSizing = el.style.boxSizing\n            enterRecord.opacity = el.style.opacity\n\n            el.style.transition = transition\n\n            if (!props.reverse) {\n              el.style[height] = '0'\n              el.style[paddingTop] = '0'\n              el.style[paddingBottom] = '0'\n              el.style[marginTop] = '0'\n              el.style[marginBottom] = '0'\n              el.style.boxSizing = 'content-box'\n\n              if (props.fadeEffect) {\n                el.style.opacity = '0'\n              }\n            }\n\n            emitEvent(props.onBeforeEnter, $el)\n          },\n          onEnter($el) {\n            if (enterStage === 'in') return\n\n            enterStage = 'in'\n            const el = $el as HTMLElement\n\n            enterRecord.overflow = el.style.overflow\n            el.style.overflow = 'hidden'\n\n            if (el[scrollHeight] !== 0) {\n              el.style[height] = `${el[scrollHeight]}px`\n            } else {\n              el.style[height] = ''\n            }\n\n            el.style[paddingTop] = enterRecord.paddingTop!\n            el.style[paddingBottom] = enterRecord.paddingBottom!\n            el.style[marginTop] = enterRecord.marginTop!\n            el.style[marginBottom] = enterRecord.marginBottom!\n\n            if (!props.reverse) {\n              if (props.fadeEffect) {\n                el.style.opacity = enterRecord.opacity!\n              }\n            } else {\n              // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n              el[scrollHeight]\n\n              el.style[height] = '0'\n              el.style[paddingTop] = '0'\n              el.style[paddingBottom] = '0'\n              el.style[marginTop] = '0'\n              el.style[marginBottom] = '0'\n              el.style.boxSizing = 'content-box'\n\n              if (props.fadeEffect) {\n                el.style.opacity = '0'\n              }\n            }\n\n            emitEvent(props.onEnter, $el)\n          },\n          onAfterEnter($el) {\n            const el = $el as HTMLElement\n\n            el.style.transition = enterRecord.transition || ''\n\n            if (!props.reverse) {\n              el.style[height] = ''\n              el.style.overflow = enterRecord.overflow!\n              el.style.boxSizing = enterRecord.boxSizing!\n            }\n\n            enterStage = null\n            emitEvent(props.onAfterEnter, $el)\n          },\n          onEnterCancelled($el) {\n            const el = $el as HTMLElement\n\n            el.style.transition = enterRecord.transition || ''\n            el.style[height] = ''\n            el.style.overflow = enterRecord.overflow!\n            el.style.boxSizing = enterRecord.boxSizing!\n\n            enterStage = null\n            emitEvent(props.onEnterCancelled, $el)\n          },\n          onBeforeLeave($el) {\n            if (leaveStage) return\n\n            leaveStage = 'before'\n            const el = $el as HTMLElement\n\n            leaveRecord.paddingTop = el.style[paddingTop]\n            leaveRecord.paddingBottom = el.style[paddingBottom]\n            leaveRecord.marginTop = el.style[marginTop]\n            leaveRecord.marginBottom = el.style[marginBottom]\n            leaveRecord.overflow = el.style.overflow\n            leaveRecord.boxSizing = el.style.boxSizing\n            leaveRecord.opacity = el.style.opacity\n\n            el.style[height] = `${el[scrollHeight]}px`\n            el.style.overflow = 'hidden'\n\n            emitEvent(props.onBeforeLeave, $el)\n          },\n          onLeave($el) {\n            if (leaveStage === 'in') return\n\n            leaveStage = 'in'\n            const el = $el as HTMLElement\n\n            if (el[scrollHeight] !== 0) {\n              leaveRecord.transition = el.style.transition\n\n              el.style.transition = transition\n\n              el.style[height] = '0'\n              el.style[paddingTop] = '0'\n              el.style[paddingBottom] = '0'\n              el.style[marginTop] = '0'\n              el.style[marginBottom] = '0'\n\n              if (props.fadeEffect) {\n                el.style.opacity = '0'\n              }\n            }\n\n            emitEvent(props.onLeave, $el)\n          },\n          onAfterLeave($el) {\n            const el = $el as HTMLElement\n\n            el.style[height] = ''\n            el.style[paddingTop] = leaveRecord.paddingTop!\n            el.style[paddingBottom] = leaveRecord.paddingBottom!\n            el.style[marginTop] = leaveRecord.marginTop!\n            el.style[marginBottom] = leaveRecord.marginBottom!\n            el.style.overflow = leaveRecord.overflow!\n            el.style.transition = leaveRecord.transition || ''\n            el.style.boxSizing = leaveRecord.boxSizing!\n            el.style.opacity = leaveRecord.opacity!\n\n            leaveStage = null\n            emitEvent(props.onAfterLeave, $el)\n          },\n          onLeaveCancelled($el) {\n            const el = $el as HTMLElement\n\n            el.style[height] = ''\n            el.style[paddingTop] = leaveRecord.paddingTop!\n            el.style[paddingBottom] = leaveRecord.paddingBottom!\n            el.style[marginTop] = leaveRecord.marginTop!\n            el.style[marginBottom] = leaveRecord.marginBottom!\n            el.style.overflow = leaveRecord.overflow!\n            el.style.transition = leaveRecord.transition || ''\n            el.style.boxSizing = leaveRecord.boxSizing!\n            el.style.opacity = leaveRecord.opacity!\n\n            leaveStage = null\n            emitEvent(props.onLeaveCancelled, $el)\n          }\n        },\n        slots\n      )\n    }\n  }\n})\n"
    },
    {
      "target": "components/collapse/collapse.vue",
      "content": "<script setup lang=\"ts\">\nimport { computed, nextTick, onMounted, provide, reactive, ref, toRef, watchEffect } from 'vue'\n\nimport { emitEvent, useNameHelper, useProps } from '@pocui/config'\nimport { useModifier } from '@pocui/hooks'\nimport { debounceMinor, isNullish, removeArrayItem } from '@pocui/utils'\nimport { collapseProps } from './props'\n\nimport { COLLAPSE_STATE } from './symbol'\n\nimport type { CollapseArrowType, PanelState } from './symbol'\n\ndefineOptions({ name: 'Collapse',\n  description: '用于将内容进行折叠和展开，节省页面空间。',\n  categories: ['display'] })\n\nconst emits = defineEmits(['update:expanded'])\n\nconst _props = defineProps(collapseProps)\nconst props = useProps('collapse', _props, {\n  expanded: {\n    default: null,\n    static: true\n  },\n  card: false,\n  accordion: false,\n  arrowType: {\n    default: 'right' as CollapseArrowType,\n    validator: (value: CollapseArrowType) => ['right', 'left', 'none'].includes(value)\n  },\n  ghost: false\n})\n\nconst nh = useNameHelper('collapse')\nconst panelStates = reactive(new Set<PanelState>())\nconst currentExpanded = ref<(string | number)[]>([])\n\nconst { target: wrapper } = useModifier({\n  passive: false,\n  onKeyDown: (event, modifier) => {\n    if (modifier.left || modifier.right) {\n      if (!wrapper.value) return\n\n      const tabs = Array.from(wrapper.value.querySelectorAll('[poc-role=\"collapse-header\"]')) as HTMLElement[]\n\n      if (tabs.length < 1) return\n\n      event.preventDefault()\n      event.stopPropagation()\n\n      const index = document.activeElement ? tabs.findIndex(panel => panel === document.activeElement) : -1\n\n      if (~index) {\n        const target = tabs[(index + (modifier.left ? -1 : 1) + tabs.length) % tabs.length]\n\n        target?.focus()\n      }\n    } else if (modifier.escape) {\n      event.preventDefault()\n      event.stopPropagation()\n\n      clearExpanded()\n    }\n  }\n})\n\nconst className = computed(() => {\n  return [\n    nh.b(),\n    nh.bs('vars'),\n    nh.bm(`arrow-${props.arrowType}`),\n    {\n      [nh.inc()]: props.inherit,\n      [nh.bm('card')]: props.card,\n      [nh.bm('ghost')]: !props.card && props.ghost\n    }\n  ]\n})\n\nconst refreshLabels = debounceMinor(() => {\n  Array.from(panelStates.values()).forEach((item, index) => {\n    if (isNullish(item.label)) {\n      item.label = index + 1\n    }\n  })\n\n  if (panelStates.size) {\n    for (const panel of panelStates) {\n      if (currentExpanded.value.includes(panel.label)) {\n        panel.expanded = true\n      } else if (panel.expanded) {\n        expandPanel(panel.label, true)\n      }\n    }\n  }\n})\n\nprovide(\n  COLLAPSE_STATE,\n  reactive({\n    arrowType: toRef(props, 'arrowType'),\n    registerPanel,\n    unregisterPanel,\n    expandPanel,\n    refreshLabels\n  })\n)\n\nwatchEffect(() => {\n  const rawExpanded = props.expanded\n  const expanded =\n    props.accordion && Array.isArray(rawExpanded) ? rawExpanded[0] : rawExpanded || rawExpanded === 0 ? rawExpanded : []\n\n  currentExpanded.value = Array.isArray(expanded) ? Array.from(expanded) : [expanded]\n})\n\nonMounted(() => {\n  nextTick(updateItemExpanded)\n})\n\nfunction registerPanel(panel: PanelState) {\n  panelStates.add(panel)\n\n  refreshLabels()\n}\n\nfunction unregisterPanel(panel: PanelState) {\n  panelStates.delete(panel)\n  expandPanel(panel.label, false)\n  refreshLabels()\n}\n\nfunction expandPanel(label: string | number, expanded: boolean) {\n  if (!label && label !== 0) return\n\n  if (props.accordion) {\n    currentExpanded.value = expanded ? [label] : []\n  } else {\n    if (expanded) {\n      currentExpanded.value.push(label)\n    } else {\n      removeArrayItem(currentExpanded.value, label)\n    }\n  }\n\n  emitChangeEvent()\n  updateItemExpanded()\n}\n\nfunction clearExpanded() {\n  if (!currentExpanded.value.length) return\n\n  currentExpanded.value = []\n\n  emitChangeEvent()\n  updateItemExpanded()\n}\n\nfunction emitChangeEvent() {\n  emits('update:expanded', currentExpanded.value)\n  emitEvent(props.onChange, currentExpanded.value)\n}\n\nfunction updateItemExpanded() {\n  panelStates.forEach(panel => {\n    panel.setExpanded(currentExpanded.value.includes(panel.label))\n  })\n}\n</script>\n\n<template>\n  <div\n    ref=\"wrapper\"\n    :class=\"className\"\n    role=\"tablist\"\n    tabindex=\"-1\"\n  >\n    <slot></slot>\n  </div>\n</template>\n"
    },
    {
      "target": "components/collapse/index.ts",
      "content": "import Collapse from './collapse.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Collapse }\nexport { collapseProps } from './props'\n\nexport type CollapseExposed = ComponentPublicInstance & InstanceType<typeof Collapse>\n\nexport type { CollapseProps, CollapseCProps } from './props'\nexport type { CollapseArrowType } from './symbol'\n"
    },
    {
      "target": "components/collapse/props.ts",
      "content": "import { booleanProp, buildProps, eventProp, iconProp, styleProp } from '@pocui/config'\n\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { CollapseArrowType } from './symbol'\n\nexport const collapseProps = buildProps({\n  expanded: [String, Number, Array] as PropType<string | number | (string | number)[]>,\n  card: booleanProp,\n  accordion: booleanProp,\n  arrowType: String as PropType<CollapseArrowType>,\n  ghost: booleanProp,\n  onChange: eventProp<(expanded: (string | number)[]) => void>()\n})\n\nexport type CollapseProps = ExtractPropTypes<typeof collapseProps>\nexport type CollapseCProps = ConfigurableProps<CollapseProps, 'expanded'>\n\nexport const collapsePanelProps = buildProps({\n  label: [String, Number],\n  title: String,\n  disabled: booleanProp,\n  contentStyle: styleProp,\n  expanded: booleanProp,\n  card: booleanProp,\n  arrowType: String as PropType<CollapseArrowType>,\n  icon: iconProp,\n  ghost: booleanProp,\n  onToggle: eventProp<(expanded: boolean) => void>()\n})\n\nexport type CollapsePanelProps = ExtractPropTypes<typeof collapsePanelProps>\nexport type CollapsePanelCProps = ConfigurableProps<CollapsePanelProps>\n\ntype TransitionMode = 'in-out' | 'out-in' | 'default'\n\nexport const collapseTransitionProps = buildProps({\n  appear: booleanProp,\n  mode: String as PropType<TransitionMode>,\n  horizontal: booleanProp,\n  duration: Number,\n  timing: String,\n  fadeEffect: booleanProp,\n  /**\n   * 树的内部属性，用于反转 enter 动画\n   *\n   * @internal\n   */\n  reverse: booleanProp,\n  disabled: booleanProp,\n  onBeforeEnter: eventProp<(el: Element) => void>(),\n  onEnter: eventProp<(el: Element) => void>(),\n  onAfterEnter: eventProp<(el: Element) => void>(),\n  onEnterCancelled: eventProp<(el: Element) => void>(),\n  onBeforeLeave: eventProp<(el: Element) => void>(),\n  onLeave: eventProp<(el: Element) => void>(),\n  onAfterLeave: eventProp<(el: Element) => void>(),\n  onLeaveCancelled: eventProp<(el: Element) => void>()\n})\n\nexport type CollapseTransitionProps = ExtractPropTypes<typeof collapseTransitionProps>\nexport type CollapseTransitionCProps = ConfigurableProps<CollapseTransitionProps>\n"
    },
    {
      "target": "components/collapse/symbol.ts",
      "content": "import type { InjectionKey } from 'vue'\n\nexport type CollapseArrowType = 'right' | 'left' | 'none'\n\nexport interface PanelState {\n  tab?: HTMLElement | null,\n\n  label: string | number,\n\n  expanded: boolean,\n\n  setExpanded: (expanded: boolean) => void\n}\n\nexport interface CollapseState {\n  arrowType: CollapseArrowType,\n\n  registerPanel(panel: PanelState): void,\n\n  unregisterPanel(panel: PanelState): void,\n\n  expandPanel(label: string | number, expanded: boolean): void,\n\n  refreshLabels: () => void\n}\n\nexport const COLLAPSE_STATE: InjectionKey<CollapseState> = Symbol('COLLAPSE_STATE')\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/hooks", "@pocui/utils"],
  "registryDependencies": ["collapse-transition", "icon", "collapse.scss"],
  "categories": ["display"],
  "meta": { "isReferenceOnly": false }
}
