{
  "name": "slider",
  "type": "registry:component",
  "description": "通过滑动来选定值。",
  "files": [
    {
      "target": "components/slider/index.ts",
      "content": "import Slider from './slider.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Slider }\nexport { sliderProps } from './props'\n\nexport type SliderExposed = ComponentPublicInstance & InstanceType<typeof Slider>\n\nexport type { SliderProps, SliderCProps } from './props'\nexport type {\n  SliderMarker,\n  SliderRawMarkers,\n  SliderTipProps,\n  SliderSlotParams,\n  SliderTriggerParams,\n  SliderMarkerSlotParams\n} from './symbol'\n"
    },
    {
      "target": "components/slider/props.ts",
      "content": "import { booleanProp, booleanStringProp, buildProps, eventProp, stateProp } from '@pocui/config'\n\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { SliderRawMarkers, SliderTipProps } from './symbol'\n\nexport const sliderProps = buildProps({\n  state: stateProp,\n  value: [Number, Array] as PropType<number | number[]>,\n  min: Number,\n  max: Number,\n  step: Number,\n  vertical: booleanProp,\n  hideTip: booleanProp,\n  tipTransfer: booleanStringProp,\n  disabled: booleanProp,\n  loading: booleanProp,\n  loadingLock: booleanProp,\n  reverse: booleanProp,\n  range: booleanProp,\n  markers: [Object, Array] as PropType<SliderRawMarkers>,\n  markerOnly: booleanProp,\n  tipHover: booleanProp,\n  flipMarker: booleanProp,\n  triggerFade: booleanProp,\n  tipProps: Object as PropType<SliderTipProps>,\n  sync: booleanProp,\n  onChange: eventProp<(value: number | number[]) => void>(),\n  onInput: eventProp<(value: number | number[]) => void>()\n})\n\nexport type SliderProps = ExtractPropTypes<typeof sliderProps>\nexport type SliderCProps = ConfigurableProps<SliderProps>\n"
    },
    {
      "target": "components/slider/slider-trigger.vue",
      "content": "<script setup lang=\"ts\">\nimport { Tooltip } from '@/components/tooltip'\n\nimport { computed, ref } from 'vue'\n\nimport { useHoverDelay, useNameHelper } from '@pocui/config'\n\nimport { useModifier, useSetTimeout } from '@pocui/hooks'\n\nimport type { TooltipExposed } from '@/components/tooltip'\n\nimport type { PropType } from 'vue'\n\nimport type { SliderTipProps } from './symbol'\n\ndefineOptions({\n  name: 'SliderTrigger',\n  description:'滑块触发器组件，作为滑块的可拖动控制点',\n  categories: ['form']\n})\n\nconst props = defineProps({\n  value: {\n    type: Number,\n    default: 0\n  },\n  tipTransfer: {\n    type: [Boolean, String],\n    default: false\n  },\n  hideTip: {\n    type: Boolean,\n    default: false\n  },\n  vertical: {\n    type: Boolean,\n    default: false\n  },\n  min: {\n    type: Number,\n    default: 0\n  },\n  max: {\n    type: Number,\n    default: 100\n  },\n  disabled: {\n    type: Boolean,\n    default: false\n  },\n  loading: {\n    type: Boolean,\n    default: false\n  },\n  reverse: {\n    type: Boolean,\n    default: false\n  },\n  sliding: {\n    type: Boolean,\n    default: false\n  },\n  tipHover: {\n    type: Boolean,\n    default: false\n  },\n  tipProps: {\n    type: Object as PropType<SliderTipProps>,\n    default: () => ({})\n  }\n})\n\nconst emit = defineEmits(['key-minus', 'key-plus'])\n\ndefineSlots<{ default(): any, tip(): any }>()\n\nconst nh = useNameHelper('slider')\nconst hoverDelay = useHoverDelay()\n\nconst isTipShow = ref(false)\n\nconst tooltip = ref<(InstanceType<typeof Tooltip> & TooltipExposed) | null>(null)\nconst handler = ref<HTMLElement>()\n\nconst { timer } = useSetTimeout()\nconst { target: wrapper } = useModifier({\n  passive: false,\n  onKeyDown: (event, modifier) => {\n    if (modifier.up || modifier.down || modifier.left || modifier.right) {\n      disableEvent(event)\n\n      const extraType = event.ctrlKey ? 'ctrl' : event.shiftKey ? 'shift' : event.altKey ? 'alt' : undefined\n\n      if (modifier.up || modifier.left) {\n        emit('key-minus', extraType)\n      } else {\n        emit('key-plus', extraType)\n      }\n    }\n  }\n})\n\nconst tipClass = computed(() => [nh.be('tip'), props.tipProps?.tipClass])\n\ndefineExpose({\n  updateTooltip,\n  focus,\n  blur\n})\n\nfunction showTooltip() {\n  clearTimeout(timer.hover)\n\n  if (!props.disabled) {\n    timer.hover = setTimeout(() => {\n      isTipShow.value = true\n    }, hoverDelay.value)\n  }\n}\n\nfunction hideTooltip() {\n  clearTimeout(timer.hover)\n\n  timer.hover = setTimeout(() => {\n    isTipShow.value = false\n  }, hoverDelay.value)\n}\n\nfunction disableEvent<E extends Event>(event: E) {\n  if (event.cancelable) {\n    event.stopPropagation()\n    event.preventDefault()\n  }\n}\n\nfunction updateTooltip() {\n  if (tooltip.value) {\n    tooltip.value.updatePopper()\n  }\n}\n\nfunction focus(options?: FocusOptions) {\n  handler.value?.focus(options)\n}\n\nfunction blur() {\n  handler.value?.blur()\n}\n</script>\n\n<template>\n  <div\n    ref=\"wrapper\"\n    :class=\"nh.be('trigger')\"\n    tabindex=\"-1\"\n    @touchstart=\"disableEvent\"\n  >\n    <Tooltip\n      ref=\"tooltip\"\n      :placement=\"vertical ? 'right' : 'top'\"\n      v-bind=\"tipProps\"\n      trigger=\"custom\"\n      :transfer=\"tipTransfer\"\n      :visible=\"isTipShow || sliding\"\n      :tip-class=\"tipClass\"\n      :disabled=\"hideTip\"\n      :no-hover=\"!tipHover\"\n      @tip-enter=\"showTooltip\"\n      @tip-leave=\"hideTooltip\"\n    >\n      <template #trigger>\n        <div\n          ref=\"handler\"\n          :class=\"{\n            [nh.be('button')]: true,\n            [nh.bem('button', 'loading')]: loading,\n            [nh.bem('button', 'sliding')]: sliding\n          }\"\n          role=\"slider\"\n          tabindex=\"0\"\n          :aria-valuenow=\"value\"\n          :aria-valuemin=\"min\"\n          :aria-valuemax=\"max\"\n          :aria-disabled=\"disabled\"\n          @mouseenter=\"showTooltip\"\n          @mouseleave=\"hideTooltip\"\n        >\n          <slot>\n            <div :class=\"nh.be('handler')\"></div>\n          </slot>\n        </div>\n      </template>\n      <slot name=\"tip\">\n        {{ value }}\n      </slot>\n    </Tooltip>\n  </div>\n</template>\n"
    },
    {
      "target": "components/slider/slider.vue",
      "content": "<script setup lang=\"ts\">\nimport { useFieldStore } from '@/components/form'\n\nimport { computed, ref, watch } from 'vue'\n\nimport { createStateProp, emitEvent, useHoverDelay, useNameHelper, useProps } from '@pocui/config'\nimport { useSetTimeout } from '@pocui/hooks'\nimport { decimalLength, isNumber, throttle, toFixed } from '@pocui/utils'\n\nimport { sliderProps } from './props'\n\nimport SliderTrigger from './slider-trigger.vue'\n\nimport type { SliderCommonSlot, SliderMarker, SliderMarkerSlot, SliderTriggerSlot } from './symbol'\n\nconst enum TriggerType {\n  START = 0,\n  END = 1\n}\n\ndefineOptions({\n  name: 'Slider',\n  description:'通过滑动来选定值。',\n  categories: ['form']\n})\n\nconst { idFor, state, disabled, loading, validateField, getFieldValue, setFieldValue } = useFieldStore<\n  number | number[]\n>(focus)\n\nconst _props = defineProps(sliderProps)\nconst props = useProps('slider', _props, {\n  state: createStateProp(state),\n  value: {\n    default: () => getFieldValue() ?? 0,\n    static: true\n  },\n  min: 0,\n  max: 100,\n  step: {\n    default: 1,\n    validator: value => value > 0\n  },\n  vertical: false,\n  hideTip: false,\n  tipTransfer: null,\n  disabled: () => disabled.value,\n  loading: () => loading.value,\n  loadingLock: false,\n  reverse: false,\n  range: false,\n  markers: null,\n  markerOnly: false,\n  tipHover: false,\n  flipMarker: false,\n  triggerFade: false,\n  tipProps: () => ({}),\n  sync: false\n})\n\nconst emit = defineEmits(['update:value'])\n\ndefineSlots<{\n  filler: SliderCommonSlot,\n  trigger: SliderTriggerSlot,\n  tip: SliderTriggerSlot,\n  point: SliderMarkerSlot,\n  marker: SliderMarkerSlot\n}>()\n\nconst nh = useNameHelper('slider')\nconst hoverDelay = useHoverDelay()\n\nconst { timer } = useSetTimeout()\n// 按每 step 为 1 的 value\nconst stepOneValue = ref([0, 0])\nconst sliding = ref([false, false])\nconst triggerType = ref(TriggerType.END)\nconst hovered = ref(false)\nconst triggerShow = ref(false)\n\nconst track = ref<HTMLElement>()\nconst startTrigger = ref<InstanceType<typeof SliderTrigger>>()\nconst endTrigger = ref<InstanceType<typeof SliderTrigger>>()\n\nconst markerList = computed(() => {\n  const markers = props.markers\n  const list: { value: number, marker: SliderMarker }[] = []\n\n  if (!markers) return list\n\n  if (Array.isArray(markers)) {\n    for (const raw of markers) {\n      const { value, ...marker } = isNumber(raw) ? { value: raw } : raw\n\n      if (!Number.isNaN(value)) {\n        list.push({\n          value,\n          marker\n        })\n      }\n    }\n  } else {\n    for (const value of Object.keys(markers)) {\n      const number = parseFloat(value)\n      const marker = markers[value]\n\n      if (!Number.isNaN(number)) {\n        list.push({\n          value: number,\n          marker: typeof marker === 'string' ? { label: marker } : marker\n        })\n      }\n    }\n  }\n\n  return list.sort((prev, next) => prev.value - next.value)\n})\nconst hasMarkerLabel = computed(() => !!markerList.value.find(({ marker }) => marker.label))\nconst readonly = computed(() => props.loading && props.loadingLock)\nconst className = computed(() => {\n  return {\n    [nh.b()]: true,\n    [nh.bs('vars')]: true,\n    [nh.in()]: props.inherit,\n    [nh.bm(props.state)]: props.state !== 'default',\n    [nh.bm('vertical')]: props.vertical,\n    [nh.bm('sliding')]: sliding.value[1] || sliding.value[0],\n    [nh.bm('disabled')]: props.disabled,\n    [nh.bm('readonly')]: readonly.value,\n    [nh.bm('loading')]: props.loading,\n    [nh.bm('reverse')]: props.reverse,\n    [nh.bm('with-marker')]: hasMarkerLabel.value,\n    [nh.bm('flip-marker')]: props.flipMarker,\n    [nh.bm('hide-trigger')]: props.triggerFade && !triggerShow.value\n  }\n})\nconst stepDigit = computed(() => decimalLength(props.step))\n// 按每 step 为 1 算的最小值\nconst stepOneMin = computed(() => Math.ceil(Math.min(props.min, props.max) / props.step))\n// 按每 step 为 1 算的最大值\nconst stepOneMax = computed(() => Math.floor(Math.max(props.min, props.max) / props.step))\nconst truthValue = computed(() => {\n  return [\n    toFixed(stepOneValue.value[0] * props.step, stepDigit.value),\n    toFixed(stepOneValue.value[1] * props.step, stepDigit.value)\n  ]\n})\nconst stepOneTotal = computed(() => stepOneMax.value - stepOneMin.value || 1)\nconst triggerPercent = computed(() => {\n  return [toPercent(stepOneValue.value[0]), toPercent(stepOneValue.value[1])]\n})\nconst fillerStyle = computed(() => {\n  const { vertical, reverse } = props\n  const offset = Math.max(triggerPercent.value[0], triggerPercent.value[1]) - 100\n  const afterOffset = Math.min(triggerPercent.value[0], triggerPercent.value[1]) - offset\n\n  return {\n    [nh.cv('filler-after-transform')]: `translate${vertical ? 'Y' : 'X'}(${\n      reverse ? -afterOffset : afterOffset\n    }%) translateZ(0)`,\n    transform: `\n      translate${vertical ? 'Y' : 'X'}(${reverse ? -offset : offset}%)\n      translateZ(0)\n    `\n  }\n})\nconst startTriggerStyle = computed(() => {\n  const { vertical, reverse } = props\n\n  return {\n    [reverse ? 'bottom' : 'top']: vertical ? `${triggerPercent.value[0]}%` : '50%',\n    [reverse ? 'right' : 'left']: vertical ? '50%' : `${triggerPercent.value[0]}%`,\n    zIndex: triggerType.value === TriggerType.START ? 1 : undefined,\n    transform: `translate(${reverse ? '' : '-'}50%, ${reverse ? '' : '-'}50%)`\n  }\n})\nconst endTriggerStyle = computed(() => {\n  const { vertical, reverse } = props\n\n  return {\n    [reverse ? 'bottom' : 'top']: vertical ? `${triggerPercent.value[1]}%` : '50%',\n    [reverse ? 'right' : 'left']: vertical ? '50%' : `${triggerPercent.value[1]}%`,\n    zIndex: triggerType.value === TriggerType.END ? 1 : undefined,\n    transform: `translate(${reverse ? '' : '-'}50%, ${reverse ? '' : '-'}50%)`\n  }\n})\nconst isDisabled = computed(() => props.disabled || readonly.value)\n\nlet lastValue: number | number[]\nlet lastInputValue: number | number[]\n\nparseValue(props.value)\nverifyValue()\n\nwatch(\n  () => props.value,\n  value => {\n    if (isEqualValue(lastValue, value)) {\n      return\n    }\n\n    parseValue(value)\n    verifyValue()\n  }\n)\nwatch(\n  () => props.step,\n  () => {\n    parseValue(props.value)\n    verifyValue()\n  }\n)\n\ndefineExpose({\n  idFor,\n  sliding,\n  track,\n  startTrigger,\n  endTrigger,\n  isValueInRange,\n  focus,\n  blur\n})\n\nfunction toPercent(value: string | number) {\n  return ((parseFloat(value as string) - stepOneMin.value) / stepOneTotal.value) * 100\n}\n\nfunction parseValue(value: number | number[]) {\n  if (props.range) {\n    const values = Array.isArray(value) ? value : [value, 100]\n\n    stepOneValue.value = [values[0] / props.step, values[1] / props.step]\n  } else {\n    stepOneValue.value = [stepOneMin.value, (Array.isArray(value) ? value[0] : value) / props.step]\n  }\n}\n\nfunction verifyValue() {\n  stepOneValue.value = stepOneValue.value.map(value => {\n    let computedValue = Math.max(stepOneMin.value, Math.min(stepOneMax.value, Math.round(value)))\n\n    if (props.markerOnly && markerList.value.length) {\n      let nearest = Infinity\n      let nearestMarker = 0\n\n      for (const { value } of markerList.value) {\n        const delta = Math.abs(computedValue * props.step - value)\n\n        if (nearest > delta) {\n          nearest = delta\n          nearestMarker = value\n        }\n      }\n\n      computedValue = nearestMarker / props.step\n    }\n\n    return computedValue\n  })\n}\n\nfunction setTriggerFade() {\n  if (hovered.value || sliding.value[0] || sliding.value[1]) return\n\n  triggerShow.value = false\n}\n\nfunction handlePointerEnter() {\n  clearTimeout(timer.hover)\n\n  timer.hover = setTimeout(() => {\n    hovered.value = true\n    triggerShow.value = true\n  }, hoverDelay.value)\n}\n\nfunction handlePointerLeave() {\n  clearTimeout(timer.hover)\n\n  timer.hover = setTimeout(() => {\n    hovered.value = false\n    setTriggerFade()\n  }, hoverDelay.value)\n}\n\nfunction emitChange(type: 'change' | 'input' = 'change', sync = props.sync) {\n  const [start, end] = truthValue.value\n  const value = props.range ? (start > end ? [end, start] : [start, end]) : end\n\n  if (type === 'change') {\n    if (isEqualValue(lastValue, value)) return\n\n    lastValue = value\n\n    if (!sync) {\n      lastInputValue = value\n\n      emit('update:value', value)\n      setFieldValue(value)\n    }\n\n    emitEvent(props.onChange, value)\n\n    if (!sync) {\n      validateField()\n    }\n  } else {\n    if (isEqualValue(lastInputValue, value)) return\n\n    lastInputValue = value\n\n    if (sync) {\n      emit('update:value', value)\n      setFieldValue(value)\n    }\n\n    emitEvent(props.onInput, value)\n\n    if (sync) {\n      validateField()\n    }\n  }\n}\n\nlet trackRect: DOMRect | null = null\n\nfunction computePointedValue(event: PointerEvent) {\n  if (!trackRect) return\n\n  const vertical = props.vertical\n  const reverse = props.reverse\n  const client = vertical ? event.clientY : event.clientX\n\n  stepOneValue.value[triggerType.value] =\n    (reverse ? -1 : 1) *\n      ((client - trackRect[vertical ? (reverse ? 'bottom' : 'top') : reverse ? 'right' : 'left']) /\n        trackRect[vertical ? 'height' : 'width']) *\n      stepOneTotal.value +\n    stepOneMin.value\n}\n\nfunction isEqualValue(prev: number | number[], current: number | number[]) {\n  if (Array.isArray(prev) && Array.isArray(current)) {\n    return prev[0] === current[0] && prev[1] === current[1]\n  }\n\n  return prev === current\n}\n\nconst throttleMove = throttle((event: PointerEvent) => {\n  if (!trackRect || props.disabled) return\n\n  event.preventDefault()\n\n  computePointedValue(event)\n  verifyValue()\n\n  if (startTrigger.value) {\n    startTrigger.value.updateTooltip()\n  }\n\n  if (endTrigger.value) {\n    endTrigger.value.updateTooltip()\n  }\n  emitChange('input')\n})\n\nfunction handleTrackDown(event: PointerEvent) {\n  if (!track.value || isDisabled.value) return\n\n  clearTimeout(timer.sliding)\n  event.stopPropagation()\n  event.preventDefault()\n\n  trackRect = track.value.getBoundingClientRect()\n\n  if (props.range) {\n    const { vertical, reverse } = props\n    const client = vertical ? event.clientY : event.clientX\n    const downPercent =\n      ((reverse ? trackRect[vertical ? 'bottom' : 'right'] - client : client - trackRect[vertical ? 'top' : 'left']) /\n        trackRect[vertical ? 'height' : 'width']) *\n      100\n\n    triggerType.value =\n      Math.abs(downPercent - triggerPercent.value[0]) < Math.abs(downPercent - triggerPercent.value[1])\n        ? TriggerType.START\n        : TriggerType.END\n  } else {\n    triggerType.value = TriggerType.END\n  }\n\n  sliding.value[triggerType.value] = true\n  triggerShow.value = true\n\n  computePointedValue(event)\n  verifyValue()\n\n  document.addEventListener('pointermove', handleMove)\n  document.addEventListener('pointerup', handleMoveEnd)\n}\n\nfunction handleMove(event: PointerEvent) {\n  throttleMove(event)\n}\n\nfunction handleMoveEnd() {\n  trackRect = null\n\n  document.removeEventListener('pointermove', handleMove)\n  document.removeEventListener('pointerup', handleMoveEnd)\n\n  emitChange()\n\n  timer.sliding = setTimeout(() => {\n    sliding.value[triggerType.value] = false\n    setTriggerFade()\n  }, 250)\n}\n\nfunction disableEvent<E extends Event>(event: E) {\n  if (event.cancelable) {\n    event.stopPropagation()\n    event.preventDefault()\n  }\n}\n\nfunction getPointStyle(value: number | string) {\n  const { vertical, reverse } = props\n  value = toPercent(value)\n\n  return {\n    [reverse ? 'bottom' : 'top']: vertical ? `${value}%` : '50%',\n    [reverse ? 'right' : 'left']: vertical ? '50%' : `${value}%`,\n    transform: `translate(${reverse ? '' : '-'}50%, ${reverse ? '' : '-'}50%)`\n  }\n}\n\nfunction getMarkerStyle(value: number | string) {\n  const { vertical, reverse } = props\n  value = toPercent(value)\n\n  return {\n    [reverse ? 'bottom' : 'top']: vertical ? `${value}%` : undefined,\n    [reverse ? 'right' : 'left']: vertical ? undefined : `${value}%`,\n    transform: `translate${vertical ? 'Y' : 'X'}(${reverse ? '' : '-'}50%)`\n  }\n}\n\nfunction isValueInRange(value: number | string) {\n  const number = parseFloat(value as string)\n\n  if (Number.isNaN(number)) return false\n\n  if (props.range) {\n    const min = Math.min(truthValue.value[0], truthValue.value[1])\n    const max = Math.max(truthValue.value[0], truthValue.value[1])\n\n    return number >= min && number <= max\n  } else {\n    return number <= truthValue.value[1]\n  }\n}\n\nfunction adjustValue(type: TriggerType, delta: number, emitEvent = false) {\n  stepOneValue.value[type] += delta\n\n  verifyValue()\n  emitEvent && emitChange()\n}\n\nfunction handlePlus(type: TriggerType, extra: 'ctrl' | 'shift' | 'alt') {\n  if (isDisabled.value) return\n\n  if (props.markerOnly || extra === 'alt') {\n    if (!markerList.value.length) return\n\n    const value = truthValue.value[type]\n\n    for (const { value: markerValue } of markerList.value) {\n      if (markerValue > value) {\n        stepOneValue.value[type] = markerValue\n        break\n      }\n    }\n\n    emitChange()\n  } else {\n    adjustValue(type, extra === 'shift' ? 5 : extra === 'ctrl' ? 20 : 1, true)\n  }\n}\n\nfunction handleMinus(type: TriggerType, extra: 'ctrl' | 'shift' | 'alt') {\n  if (isDisabled.value) return\n\n  if (props.markerOnly || extra === 'alt') {\n    if (!markerList.value.length) return\n\n    const value = truthValue.value[type]\n\n    for (let i = markerList.value.length - 1; i >= 0; --i) {\n      const { value: markerValue } = markerList.value[i]\n\n      if (markerValue < value) {\n        stepOneValue.value[type] = markerValue\n        break\n      }\n    }\n\n    emitChange()\n  } else {\n    adjustValue(type, extra === 'shift' ? -5 : extra === 'ctrl' ? -20 : -1)\n  }\n}\n\nfunction focus(options?: FocusOptions) {\n  ;(startTrigger.value || endTrigger.value)?.focus(options)\n}\n\nfunction blur() {\n  ;(startTrigger.value || endTrigger.value)?.blur()\n}\n</script>\n\n<template>\n  <div\n    :id=\"idFor\"\n    :class=\"className\"\n    tabindex=\"-1\"\n    @pointerdown=\"handleTrackDown\"\n    @pointerenter=\"handlePointerEnter\"\n    @pointerleave=\"handlePointerLeave\"\n    @touchstart=\"disableEvent\"\n  >\n    <div :class=\"nh.be('container')\">\n      <div ref=\"track\" :class=\"nh.be('track')\">\n        <slot\n          name=\"filler\"\n          :values=\"truthValue\"\n          :sliding=\"sliding\"\n          :percent=\"triggerPercent\"\n          :disabled=\"props.disabled\"\n          :loading=\"props.loading\"\n        >\n          <div :class=\"nh.be('filler')\" :style=\"fillerStyle\"></div>\n        </slot>\n      </div>\n      <template v-if=\"markerList.length\">\n        <div :class=\"nh.be('points')\">\n          <div\n            v-for=\"{ value, marker } in markerList\"\n            :key=\"value\"\n            :class=\"[nh.be('point'), isValueInRange(value) && nh.bem('point', 'in-range')]\"\n            :style=\"getPointStyle(value)\"\n          >\n            <slot\n              name=\"point\"\n              :values=\"truthValue\"\n              :sliding=\"sliding\"\n              :percent=\"triggerPercent\"\n              :marker=\"marker\"\n              :marker-value=\"value\"\n              :in-range=\"isValueInRange(value)\"\n              :disabled=\"props.disabled\"\n              :loading=\"props.loading\"\n            >\n              <span :class=\"nh.be('dot')\"></span>\n            </slot>\n          </div>\n        </div>\n        <div :class=\"nh.be('markers')\">\n          <template v-for=\"{ value, marker } in markerList\" :key=\"value\">\n            <div\n              v-bind=\"marker.attrs\"\n              :class=\"[nh.be('marker'), marker.class]\"\n              :style=\"[getMarkerStyle(value), marker.style as any]\"\n            >\n              <slot\n                name=\"marker\"\n                :values=\"truthValue\"\n                :sliding=\"sliding\"\n                :percent=\"triggerPercent\"\n                :marker=\"marker\"\n                :marker-value=\"value\"\n                :in-range=\"isValueInRange(value)\"\n                :disabled=\"props.disabled\"\n                :loading=\"props.loading\"\n              >\n                {{ marker.label }}\n              </slot>\n            </div>\n          </template>\n        </div>\n      </template>\n      <SliderTrigger\n        v-if=\"props.range\"\n        ref=\"startTrigger\"\n        :value=\"truthValue[0]\"\n        :tip-transfer=\"props.tipTransfer\"\n        :hide-tip=\"props.hideTip\"\n        :vertical=\"props.vertical\"\n        :min=\"props.min\"\n        :max=\"props.max\"\n        :disabled=\"props.disabled\"\n        :loading=\"props.loading\"\n        :reverse=\"props.reverse\"\n        :sliding=\"sliding[0]\"\n        :tip-hover=\"props.tipHover\"\n        :style=\"startTriggerStyle\"\n        :tip-props=\"props.tipProps\"\n        @key-plus=\"handlePlus(0, $event)\"\n        @key-minus=\"handleMinus(0, $event)\"\n      >\n        <slot\n          v-if=\"$slots.trigger\"\n          name=\"trigger\"\n          type=\"start\"\n          :value=\"truthValue[0]\"\n          :sliding=\"sliding[0]\"\n          :percent=\"triggerPercent[0]\"\n          :disabled=\"props.disabled\"\n          :loading=\"props.loading\"\n        ></slot>\n        <template #tip>\n          <slot\n            name=\"tip\"\n            type=\"start\"\n            :value=\"truthValue[0]\"\n            :sliding=\"sliding[0]\"\n            :percent=\"triggerPercent[0]\"\n            :disabled=\"props.disabled\"\n            :loading=\"props.loading\"\n          >\n            {{ truthValue[0] }}\n          </slot>\n        </template>\n      </SliderTrigger>\n      <SliderTrigger\n        ref=\"endTrigger\"\n        :value=\"truthValue[1]\"\n        :tip-transfer=\"props.tipTransfer\"\n        :hide-tip=\"props.hideTip\"\n        :vertical=\"props.vertical\"\n        :min=\"props.min\"\n        :max=\"props.max\"\n        :disabled=\"props.disabled\"\n        :loading=\"props.loading\"\n        :reverse=\"props.reverse\"\n        :sliding=\"sliding[1]\"\n        :tip-hover=\"props.tipHover\"\n        :style=\"endTriggerStyle\"\n        :tip-props=\"props.tipProps\"\n        @key-plus=\"handlePlus(1, $event)\"\n        @key-minus=\"handleMinus(1, $event)\"\n      >\n        <slot\n          v-if=\"$slots.trigger\"\n          name=\"trigger\"\n          type=\"end\"\n          :value=\"truthValue[1]\"\n          :sliding=\"sliding[1]\"\n          :percent=\"triggerPercent[1]\"\n          :disabled=\"props.disabled\"\n          :loading=\"props.loading\"\n        ></slot>\n        <template #tip>\n          <slot\n            name=\"tip\"\n            type=\"end\"\n            :value=\"truthValue[1]\"\n            :sliding=\"sliding[1]\"\n            :percent=\"triggerPercent[1]\"\n            :disabled=\"props.disabled\"\n            :loading=\"props.loading\"\n          >\n            {{ truthValue[1] }}\n          </slot>\n        </template>\n      </SliderTrigger>\n    </div>\n  </div>\n</template>\n"
    },
    {
      "target": "components/slider/symbol.ts",
      "content": "import type { TooltipProps } from '@/components/tooltip'\nimport type { ClassType, StyleType } from '@pocui/config'\n\nexport interface SliderMarker {\n  label?: string,\n\n  class?: ClassType,\n\n  style?: StyleType,\n\n  attrs?: Record<string, any>\n}\n\nexport type SliderRawMarkers =\n  | Record<string | number, string | SliderMarker>\n  | Array<number | (SliderMarker & { value: number })>\n\nexport type SliderTipProps = Omit<TooltipProps, 'trigger' | 'transfer' | 'visible' | 'disabled' | 'noHover'>\n\nexport interface SliderSlotParams {\n  values: number[],\n\n  sliding: boolean[],\n\n  percent: number[],\n\n  disabled: boolean,\n\n  loading: boolean\n}\n\nexport interface SliderMarkerSlotParams extends SliderSlotParams {\n  markerValue: number,\n\n  marker: SliderMarker,\n\n  inRange: boolean\n}\n\nexport interface SliderTriggerParams {\n  type: 'start' | 'end',\n\n  value: number,\n\n  sliding: boolean,\n\n  percent: number,\n\n  disabled: boolean,\n\n  loading: boolean\n}\n\nexport type SliderCommonSlot = (props: SliderSlotParams) => any\nexport type SliderTriggerSlot = (props: SliderTriggerParams) => any\nexport type SliderMarkerSlot = (props: SliderMarkerSlotParams) => any\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/hooks", "@pocui/utils"],
  "registryDependencies": ["slider.scss", "tooltip", "form"],
  "categories": ["form"],
  "meta": { "isReferenceOnly": false }
}
