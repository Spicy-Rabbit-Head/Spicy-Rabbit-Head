{
  "name": "table",
  "type": "registry:components",
  "description": "用于展示结构化二维数据，可以快速实对数据进行排序、搜索、分组、编辑、分页、汇总等操作。",
  "files": [
    {
      "target": "components/table/helper.ts",
      "content": "import type { Data, TableColumnOptions, TableFilterOptions, TableSorterOptions, TableSummaryOptions } from './symbol'\n\nexport function defineTableFilter<D = Data, Val extends string | number = string | number>(\n  filter: TableFilterOptions<D, Val>\n) {\n  return filter as TableFilterOptions<any, any>\n}\n\nexport function defineTableSorter<D = Data>(sorter: TableSorterOptions<D>) {\n  return sorter as TableSorterOptions<any>\n}\n\nexport function defineTableColumn<D = Data, Val extends string | number = string | number>(\n  column: TableColumnOptions<D, Val>\n) {\n  return column\n}\n\nexport function defineTableColumns<D = Data, Val extends string | number = string | number>(\n  columns: TableColumnOptions<D, Val>[]\n) {\n  return columns\n}\n\nexport function defineTableSummary<D = Data, Val extends string | number = string | number>(\n  summary: TableSummaryOptions<D, Val>\n) {\n  return summary\n}\n\nexport function defineTableSummaries<D = Data, Val extends string | number = string | number>(\n  summaries: TableSummaryOptions<D, Val>[]\n) {\n  return summaries\n}\n"
    },
    {
      "target": "components/table/index.ts",
      "content": "import Table from './table.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Table }\nexport { tableProps } from './props'\nexport {\n  defineTableFilter,\n  defineTableSorter,\n  defineTableColumn,\n  defineTableColumns,\n  defineTableSummary,\n  defineTableSummaries\n} from './helper'\n\nexport type TableExposed = ComponentPublicInstance & InstanceType<typeof Table>\n\nexport type { TableProps, TableCProps } from './props'\nexport type {\n  TableKeyConfig,\n  TableIconName,\n  TableIcons,\n  TableRowPropFn,\n  TableRowDropType,\n  TableColumnType,\n  TableFilterOptions,\n  TableSorterOptions,\n  TableFilterProfile,\n  TableSorterProfile,\n  TableBaseColumn,\n  TableOrderColumn,\n  TableSelectionColumn,\n  TableExpandColumn,\n  TableTypeColumn,\n  TableColumnOptions,\n  TableColumnGroupOptions,\n  TableColumnRawOptions,\n  TableCellPropFn,\n  TableHeadPropFn,\n  TableRowPayload,\n  TableCellPayload,\n  TableHeadPayload,\n  TableColResizePayload,\n  TableCellSpanFn,\n  TableSummaryOptions,\n  TableSummaryData,\n  Key\n} from './symbol'\n"
    },
    {
      "target": "components/table/props.ts",
      "content": "import {\n  booleanProp,\n  buildProps,\n  classProp,\n  eventProp,\n  localeProp,\n  sizeProp,\n  styleProp\n} from '@pocui/config'\n\nimport {\n  Accessor,\n  ColumnCellSpanFn,\n  ColumnRenderFn,\n  ColumnSummaryRenderFn,\n  Data,\n  DropType,\n  ExhibitPropsFields,\n  ExhibitType,\n  ExpandRenderFn,\n  FilterRenderFn,\n  HeadRenderFn,\n  Key,\n  SummaryCellSpanFn,\n  SummaryRenderFn,\n  TableCellPayload,\n  TableCellPropFn,\n  TableCellSpanFn,\n  TableColResizeType,\n  TableColumnRawOptions,\n  TableColumnType,\n  TableFilterOptions,\n  TableFilterProfile,\n  TableFootPayload,\n  TableFootPropFn,\n  TableHeadPayload,\n  TableHeadPropFn,\n  TableIcons,\n  TableKeyConfig,\n  TableRowPayload,\n  TableRowPropFn,\n  TableSorterOptions,\n  TableSorterProfile,\n  TableSummaryOptions,\n  TableTextAlign\n} from './symbol'\n\nimport type { ClassType, ConfigurableProps, StyleType } from '@pocui/config'\n\nimport type { TooltipTheme } from '@/components/tooltip'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\n\nexport const tableProps = buildProps({\n  locale: localeProp('table'),\n  columns: Array as PropType<TableColumnRawOptions[]>,\n  defaultHidden: Array as PropType<Key[]>,\n  summaries: Array as PropType<TableSummaryOptions<any, any>[]>,\n  toolbar: booleanProp,\n  toolbarSize: sizeProp,\n  data: Array as PropType<Data[]>,\n  width: [Number, String],\n  height: Number,\n  minHeight: Number,\n  rowClass: [String, Object, Array, Function] as PropType<ClassType | TableRowPropFn<ClassType>>,\n  rowStyle: [String, Object, Array, Function] as PropType<StyleType | TableRowPropFn<StyleType>>,\n  rowAttrs: [Object, Function] as PropType<Record<string, any> | TableRowPropFn<Record<string, any>>>,\n  customSearch: booleanProp,\n  stripe: booleanProp,\n  border: booleanProp,\n  highlight: booleanProp,\n  useXBar: booleanProp,\n  useYBar: booleanProp,\n  barFade: Number,\n  rowDraggable: booleanProp,\n  rowHeight: Number,\n  rowMinHeight: Number,\n  virtual: booleanProp,\n  bufferCount: Number,\n  scrollClass: Object as PropType<{\n    horizontal?: ClassType,\n    major?: ClassType,\n    left?: ClassType,\n    right?: ClassType\n  }>,\n  expandRenderer: Function as PropType<ExpandRenderFn>,\n  currentPage: Number,\n  pageSize: Number,\n  transparent: booleanProp,\n  tooltipTheme: String as PropType<TooltipTheme>,\n  tooltipWidth: [Number, String],\n  singleSorter: booleanProp,\n  singleFilter: booleanProp,\n  cellClass: [String, Object, Array, Function] as PropType<ClassType | TableCellPropFn<any, ClassType>>,\n  cellStyle: [String, Object, Array, Function] as PropType<StyleType | TableCellPropFn<any, StyleType>>,\n  cellAttrs: [Object, Function] as PropType<Record<string, any> | TableCellPropFn<any, Record<string, any>>>,\n  headClass: [String, Object, Array, Function] as PropType<ClassType | TableHeadPropFn<ClassType>>,\n  headStyle: [String, Object, Array, Function] as PropType<StyleType | TableHeadPropFn<StyleType>>,\n  headAttrs: [Object, Function] as PropType<Record<string, any> | TableHeadPropFn<Record<string, any>>>,\n  footClass: [String, Object, Array, Function] as PropType<ClassType | TableFootPropFn<ClassType>>,\n  footStyle: [String, Object, Array, Function] as PropType<StyleType | TableFootPropFn<StyleType>>,\n  footAttrs: [Object, Function] as PropType<Record<string, any> | TableFootPropFn<Record<string, any>>>,\n  customSorter: booleanProp,\n  customFilter: booleanProp,\n  keyConfig: Object as PropType<TableKeyConfig>,\n  disabledTree: booleanProp,\n  rowIndent: [String, Number],\n  noCascaded: booleanProp,\n  colResizable: {\n    type: [Boolean, String] as PropType<boolean | TableColResizeType>,\n    default: null\n  },\n  cellSpan: Function as PropType<TableCellSpanFn>,\n  sidePadding: [Number, Array] as PropType<number | number[]>,\n  icons: Object as PropType<TableIcons>,\n  borderWidth: Number,\n  dataFilter: Function as PropType<(data: Data) => boolean>,\n  noTransition: booleanProp,\n  ellipsis: booleanProp,\n  onScroll: eventProp<(payload: { type: 'horizontal' | 'vertical', client: number, percent: number }) => void>(),\n  onRowEnter: eventProp<(payload: TableRowPayload) => void>(),\n  onRowLeave: eventProp<(payload: TableRowPayload) => void>(),\n  onRowClick: eventProp<(payload: TableRowPayload) => void>(),\n  onRowDblclick: eventProp<(payload: TableRowPayload) => void>(),\n  onRowContextmenu: eventProp<(payload: TableRowPayload) => void>(),\n  onRowCheck: eventProp<(payload: TableRowPayload) => void>(),\n  onRowCheckAll: eventProp<(checked: boolean, partial: boolean) => void>(),\n  onRowExpand: eventProp<(payload: TableRowPayload) => void>(),\n  onRowTreeExpand: eventProp<(payload: TableRowPayload) => void>(),\n  onRowDragStart: eventProp<(row: Data, event: DragEvent) => void>(),\n  onRowDragOver: eventProp<(row: Data, event: DragEvent) => void>(),\n  onRowDrop: eventProp<(row: Data, type: DropType, event: DragEvent) => void>(),\n  onRowDragEnd: eventProp<(row: Data, allRows: Data[], event: DragEvent) => void>(),\n  onRowFilter: eventProp<(profiles: TableFilterProfile[], filteredRow: Data[]) => void>(),\n  onRowSort: eventProp<(profiles: TableSorterProfile[], sortedRow: Data[]) => void>(),\n  onCellEnter: eventProp<(payload: TableCellPayload) => void>(),\n  onCellLeave: eventProp<(payload: TableCellPayload) => void>(),\n  onCellClick: eventProp<(payload: TableCellPayload) => void>(),\n  onCellDblclick: eventProp<(payload: TableCellPayload) => void>(),\n  onCellContextmenu: eventProp<(payload: TableCellPayload) => void>(),\n  onHeadEnter: eventProp<(payload: TableHeadPayload) => void>(),\n  onHeadLeave: eventProp<(payload: TableHeadPayload) => void>(),\n  onHeadClick: eventProp<(payload: TableHeadPayload) => void>(),\n  onHeadDblclick: eventProp<(payload: TableHeadPayload) => void>(),\n  onHeadContextmenu: eventProp<(payload: TableHeadPayload) => void>(),\n  onColResizeStart: eventProp<(payload: TableHeadPayload) => void>(),\n  onColResizeMove: eventProp<(payload: TableHeadPayload) => void>(),\n  onColResizeEnd: eventProp<(payload: TableHeadPayload) => void>(),\n  onFootEnter: eventProp<(payload: TableFootPayload) => void>(),\n  onFootLeave: eventProp<(payload: TableFootPayload) => void>(),\n  onFootClick: eventProp<(payload: TableFootPayload) => void>(),\n  onFootDblclick: eventProp<(payload: TableFootPayload) => void>(),\n  onFootContextmenu: eventProp<(payload: TableFootPayload) => void>()\n})\n\nexport type TableProps = ExtractPropTypes<typeof tableProps>\nexport type TableCProps = ConfigurableProps<TableProps, 'columns' | 'data' | 'currentPage' | 'summaries'>\n\nexport const tableColumnProps = buildProps({\n  idKey: [Number, String],\n  name: String,\n  accessor: Function as PropType<Accessor>,\n  fixed: {\n    type: [Boolean, String] as PropType<boolean | 'left' | 'right'>,\n    default: null\n  },\n  class: classProp,\n  style: styleProp,\n  attrs: Object,\n  type: String as PropType<TableColumnType | ExhibitType>,\n  propsFields: String as PropType<ExhibitPropsFields>,\n  width: Number,\n  filter: Object as PropType<TableFilterOptions<any, any>>,\n  sorter: {\n    type: [Boolean, Object] as PropType<boolean | TableSorterOptions<any>>,\n    default: null\n  },\n  renderer: Function as PropType<ColumnRenderFn>,\n  headRenderer: Function as PropType<HeadRenderFn>,\n  filterRenderer: Function as PropType<FilterRenderFn>,\n  order: Number,\n  ellipsis: booleanProp,\n  checkboxSize: sizeProp,\n  disableRow: Function as PropType<(data: Data) => boolean>,\n  truthIndex: booleanProp,\n  orderLabel: Function as PropType<(index: number) => string | number>,\n  meta: Object as PropType<any>,\n  textAlign: String as PropType<TableTextAlign>,\n  headSpan: Number,\n  cellSpan: Function as PropType<ColumnCellSpanFn>,\n  noSummary: booleanProp,\n  summaryRenderer: Function as PropType<ColumnSummaryRenderFn>,\n  indented: booleanProp,\n  formatter: Function as PropType<(value: any) => unknown>\n})\n\nexport type TableColumnProps = ExtractPropTypes<typeof tableColumnProps>\nexport type TableColumnCProps = ConfigurableProps<\n  TableColumnProps,\n  | 'idKey'\n  | 'name'\n  | 'accessor'\n  | 'fixed'\n  | 'type'\n  | 'renderer'\n  | 'headRenderer'\n  | 'order'\n  | 'headSpan'\n  | 'summaryRenderer'\n>\n\nexport const tableColumnGroupProps = buildProps({\n  name: String,\n  fixed: {\n    type: [Boolean, String] as PropType<boolean | 'left' | 'right'>,\n    default: null\n  },\n  order: Number,\n  ellipsis: booleanProp,\n  textAlign: String as PropType<TableTextAlign>,\n  renderer: Function as PropType<() => any>,\n  children: Array as PropType<TableColumnRawOptions[]>\n})\n\nexport type TableColumnGroupProps = ExtractPropTypes<typeof tableColumnGroupProps>\nexport type TableColumnGroupCProps = ConfigurableProps<TableColumnProps, 'name' | 'fixed' | 'order'>\n\nexport const tableSummaryProps = buildProps({\n  idKey: [Number, String],\n  name: String,\n  class: classProp,\n  style: styleProp,\n  attrs: Object,\n  cellSpan: Function as PropType<SummaryCellSpanFn>,\n  order: Number,\n  above: booleanProp,\n  meta: Object as PropType<any>,\n  renderer: Function as PropType<SummaryRenderFn>\n})\n\nexport type TableSummaryProps = ExtractPropTypes<typeof tableSummaryProps>\nexport type TableSummaryCProps = ConfigurableProps<\n  TableSummaryProps,\n  'idKey' | 'name' | 'renderer' | 'colSpan' | 'order' | 'above'\n>\n"
    },
    {
      "target": "components/table/store.ts",
      "content": "import { useCascadedChecked } from '@/components/tree/hooks'\n\nimport { computed, reactive, watchEffect } from 'vue'\n\nimport {\n  boundRange,\n  createBITree,\n  debounceMinor,\n  deepClone,\n  getLast,\n  isNullish,\n  isSymbol,\n  mapTree,\n  sortByProps,\n  toFalse,\n  toFixed,\n  toNumber,\n  walkTree\n} from '@pocui/utils'\n\nimport {\n  DEFAULT_KEY_FIELD,\n  ExhibitType,\n  TABLE_FOOT_PREFIX,\n  TABLE_HEAD_PREFIX,\n  columnTypes,\n  exhibitTypes\n} from './symbol'\n\nimport type { TooltipTheme } from '@/components/tooltip'\n\nimport type { ClassType, LocaleConfig, StyleType } from '@pocui/config'\n\nimport type {\n  CellSpanResult,\n  ColumnCellSpanFn,\n  ColumnGroupWithKey,\n  ColumnRawWithKey,\n  ColumnWithKey,\n  Data,\n  ExpandRenderFn,\n  Key,\n  ParsedFilterOptions,\n  ParsedTableSorterOptions,\n  StoreOptions,\n  StoreState,\n  SummaryCellSpanFn,\n  SummaryWithKey,\n  TableCellPropFn,\n  TableCellSpanFn,\n  TableColResizeType,\n  TableColumnOptions,\n  TableColumnRawOptions,\n  TableColumnType,\n  TableDragColumn,\n  TableExpandColumn,\n  TableFilterOptions,\n  TableFootPropFn,\n  TableHeadPropFn,\n  TableKeyConfig,\n  TableRowPropFn,\n  TableRowState,\n  TableSelectionColumn,\n  TableSorterOptions,\n  TableSummaryData,\n  TableSummaryOptions\n} from './symbol'\n\nconst defaultSummaryData = Object.freeze<TableSummaryData>({\n  sum: NaN,\n  min: NaN,\n  max: NaN\n})\n\nlet indexId = 1\n\nfunction getIndexId() {\n  return `__poc-table-key-${indexId++}`\n}\n\nfunction defaultIndexLabel(index: number) {\n  return index + 1\n}\n\nexport function useStore(options: StoreOptions) {\n  const state = reactive({\n    ...options,\n    columns: [],\n    normalColumns: [],\n    allColumns: [],\n    summaries: [],\n    data: [],\n    dataKey: options.dataKey ?? DEFAULT_KEY_FIELD,\n    rowData: [],\n    treeRowData: [],\n    width: 0,\n    rightFixedColumns: [],\n    leftFixedColumns: [],\n    aboveSummaries: [],\n    belowSummaries: [],\n    rowMinHeight: options.rowMinHeight || 36,\n    rowDraggable: !!options.rowDraggable,\n    columnMap: new Map(),\n    rowMap: new Map(),\n    summaryMap: new Map(),\n    idMaps: new WeakMap(),\n    checkedAll: false,\n    partial: false,\n    widths: new Map(),\n    sorters: new Map(),\n    filters: new Map(),\n    resized: new Set(),\n    bodyYScroll: 0,\n    bodyXScroll: 0,\n    padTop: 0,\n    startRow: 0,\n    endRow: 0,\n    dragging: false,\n    heightBITree: null!,\n    virtualData: [],\n    totalHeight: options.rowMinHeight * options.data.length,\n    colResizing: false,\n    resizeLeft: 0,\n    cellSpanMap: new Map(),\n    collapseMap: new Map(),\n    sidePadding: options.sidePadding || [0, 0],\n    locked: false,\n    barScrolling: false,\n    heightTrigger: 0\n  }) as StoreState\n  setColumns(options.columns)\n  setSummaries(options.summaries)\n  setData(options.data)\n\n  const userData = computed(() => {\n    return typeof state.dataFilter === 'function'\n      ? state.rowData.filter(row => state.dataFilter(row.data))\n      : state.rowData\n  })\n  const filteredData = computed(() => {\n    return state.customFilter ? userData.value : filterData(state.filters, userData.value, state.singleFilter)\n  })\n  const sortedData = computed(() => {\n    const data = state.customSorter\n      ? filteredData.value\n      : sortData(state.sorters, filteredData.value, state.columns, state.singleSorter)\n\n    return data\n  })\n  const processedData = computed(() => {\n    const data = pageData(state.currentPage, state.pageSize, sortedData.value)\n\n    for (let i = 0, len = data.length; i < len; ++i) {\n      data[i].listIndex = i\n      data[i].last = i === len - 1\n    }\n\n    return data\n  })\n  const visibleKeys = computed(() => new Set(processedData.value.map(row => row.key)))\n  const disableCheckRows = computed(() => {\n    const rowData = processedData.value\n    const selectionColumn = state.columns.find(item => (item as TableSelectionColumn).type === 'selection') as\n      | TableSelectionColumn\n      | undefined\n    const disableCheckRows = new Set<Key>()\n\n    if (selectionColumn && typeof selectionColumn.disableRow === 'function') {\n      const isDisabled = selectionColumn.disableRow\n\n      for (let i = 0, len = rowData.length; i < len; ++i) {\n        const row = rowData[i]\n\n        if (isDisabled(row.data)) {\n          disableCheckRows.add(row.key)\n        }\n      }\n    }\n\n    return disableCheckRows\n  })\n  const disableExpandRows = computed(() => {\n    const rowData = processedData.value\n    const expandColumn = state.columns.find(item => (item as TableExpandColumn).type === 'expand') as\n      | TableExpandColumn\n      | undefined\n    const disableExpandRows = new Set<Key>()\n\n    if (expandColumn && typeof expandColumn.disableRow === 'function') {\n      const isDisabled = expandColumn.disableRow\n\n      for (let i = 0, len = rowData.length; i < len; ++i) {\n        const row = rowData[i]\n\n        if (isDisabled(row.data)) {\n          disableExpandRows.add(row.key)\n        }\n      }\n    }\n\n    return disableExpandRows\n  })\n  const disableDragRows = computed(() => {\n    const rowData = processedData.value\n    const dragColumn = state.columns.find(item => (item as TableDragColumn).type === 'drag') as\n      | TableDragColumn\n      | undefined\n    const disableDragRows = new Set<Key>()\n\n    if (dragColumn && typeof dragColumn.disableRow === 'function') {\n      const isDisabled = dragColumn.disableRow\n\n      for (let i = 0, len = rowData.length; i < len; ++i) {\n        const row = rowData[i]\n\n        if (isDisabled(row.data)) {\n          disableDragRows.add(row.key)\n        }\n      }\n    }\n\n    return disableDragRows\n  })\n  const usingTree = computed(() => {\n    return !state.disabledTree && state.rowData.some(row => row.children?.length)\n  })\n  const hasDragColumn = computed(() => {\n    return !!state.columns.find(column => 'type' in column && column.type === 'drag')\n  })\n  const rowDragging = computed(() => !!processedData.value.find(row => row.dragging))\n  const totalWidths = computed(() => getColumnsWidths())\n  const normalWidths = computed(() => getColumnsWidths(state.normalColumns))\n  const leftFixedWidths = computed(() => getColumnsWidths(state.leftFixedColumns))\n  const rightFixedWidths = computed(() => getColumnsWidths(state.rightFixedColumns))\n  const expandColumn = computed(() => {\n    return state.columns.find(column => (column as TableExpandColumn).type === 'expand') as\n      | TableExpandColumn\n      | undefined\n  })\n  const summaryData = computed(() => {\n    const { columns, summaries, data } = state\n    const map = new Map<Key, TableSummaryData>()\n\n    if (!summaries.length) return map\n\n    for (const column of columns) {\n      const key = column.key\n\n      if (column.type || column.noSummary) {\n        map.set(key, defaultSummaryData)\n        continue\n      }\n\n      const accessor = typeof column.accessor === 'function' ? column.accessor : (data: Data) => data[key]\n\n      let sum = 0\n      let min = Infinity\n      let max = -Infinity\n      let valid = false\n\n      for (let i = 0, len = data.length; i < len; ++i) {\n        const value = accessor(data[i], i)\n        const number = parseFloat(value as string)\n\n        if (Number.isNaN(number)) continue\n\n        sum += number\n        min = Math.min(min, number)\n        max = Math.max(max, number)\n        valid = true\n      }\n\n      valid\n        ? map.set(key, {\n          sum,\n          min,\n          max\n        })\n        : map.set(key, defaultSummaryData)\n    }\n\n    return map\n  })\n  const topFixedHeights = computed(() => getSummariesHeights(state.aboveSummaries))\n  const bottomFixedHeights = computed(() => getSummariesHeights())\n  const indentedColumn = computed(() => {\n    return state.columns.find(column => !column.type && column.indented)\n  })\n  const hasFixedColumn = computed(() => {\n    return !!(state.leftFixedColumns.length || state.rightFixedColumns.length)\n  })\n\n  const getters = reactive({\n    filteredData,\n    sortedData,\n    processedData,\n    visibleKeys,\n    disableCheckRows,\n    disableExpandRows,\n    disableDragRows,\n    usingTree,\n    hasDragColumn,\n    rowDragging,\n    totalWidths,\n    normalWidths,\n    leftFixedWidths,\n    rightFixedWidths,\n    expandColumn,\n    summaryData,\n    topFixedHeights,\n    bottomFixedHeights,\n    indentedColumn,\n    hasFixedColumn\n  })\n\n  const mutations = {\n    // 这几个个方法被 deep watch 回调\n    // 需要防止在一个微任务内被多次调用\n    setColumns: debounceMinor(setColumns),\n    // 设置列\n    setSummaries: debounceMinor(setSummaries),\n    setData: debounceMinor(setData),\n\n    // 这个方法被大量的 watch 回调，需要防抖\n    updateTotalHeight: debounceMinor(updateTotalHeight),\n\n    isGroupColumn,\n    buildSummaryKey,\n    setColumnProp,\n    setSummaryProp,\n    setDataKey,\n    setCurrentPage,\n    setPageSize,\n    setRowClass,\n    setRowStyle,\n    setRowAttrs,\n    setCellClass,\n    setCellStyle,\n    setCellAttrs,\n    setHeadClass,\n    setHeadStyle,\n    setHeadAttrs,\n    setFootClass,\n    setFootStyle,\n    setFootAttrs,\n    setTableWidth,\n    setRowHeight,\n    setRowMinHeight,\n    setCellHeight,\n    setVirtual,\n    setRowDraggable,\n    setBodyYScroll,\n    setBodyXScroll,\n    setBorder,\n    setStripe,\n    setHighlight,\n    setRowProp,\n    setLocale,\n    setTooltipTheme,\n    setTooltipWidth,\n    setSingleSorter,\n    setSingleFilter,\n    setDragging,\n    setKeyConfig,\n    setDisabledTree,\n    setNoCascaded,\n    setColResizable,\n    setCustomSorter,\n    setCustomFilter,\n    setColumnResizing,\n    setResizeLeft,\n    setExpandRenderer,\n    setCellSpan,\n    setSidePadding,\n    setBorderWidth,\n    setDataFilter,\n    setEllipsis,\n    setLocked,\n    setBarScrolling,\n\n    handleSort,\n    clearSort,\n    handleFilter,\n    clearFilter,\n    toggleFilterItemActive,\n    refreshRowIndex,\n    handleCheck,\n    handleCheckAll,\n    clearCheckAll,\n    setRenderRows,\n    handleExpand,\n    handleDrag,\n    collectUnderRows,\n    setTreeExpanded,\n    getParentRow,\n    handleColumnResize,\n    getCurrentData,\n    createMinRowState,\n    flatTreeRows,\n    refreshRowDepth,\n    triggerHeightChange,\n    queryRow\n  }\n\n  watchEffect(() => {\n    state.heightBITree = createBITree(processedData.value.length, state.rowHeight || state.rowMinHeight)\n\n    state.totalHeight = -1\n    updateTotalHeight()\n  })\n  watchEffect(computeCellSpan)\n\n  function triggerHeightChange() {\n    ++state.heightTrigger\n\n    if (state.heightTrigger >= Number.MAX_SAFE_INTEGER) {\n      state.heightTrigger = 0\n    }\n  }\n\n  function getColumnsWidths(columns = state.columns) {\n    const widths = state.widths\n    const combinedWidths: number[] = [0]\n\n    let width = 0\n\n    for (let i = 0, len = columns.length; i < len; ++i) {\n      const column = columns[i]\n      const key = column.key\n      const columnWidth = widths.get(key) || 0\n\n      width += columnWidth\n      combinedWidths.push(width)\n    }\n\n    return combinedWidths\n  }\n\n  function getSummariesHeights(summaries = state.belowSummaries) {\n    const rowMap = state.rowMap\n    const heights: number[] = [0]\n\n    let height = 0\n\n    for (let i = 0, len = summaries.length; i < len; ++i) {\n      const summary = summaries[i]\n      const key = buildSummaryKey(summary.key)\n      const row = rowMap.get(key)\n\n      if (row) {\n        height += row.height || 0\n      }\n\n      heights.push(height)\n    }\n\n    return heights\n  }\n\n  function createMinRowState(key: Key) {\n    return {\n      key,\n      cellHeights: {},\n      height: state.rowHeight ?? state.rowMinHeight\n    } as TableRowState\n  }\n\n  function isGroupColumn(column: any): column is ColumnGroupWithKey {\n    return !!column.children?.length\n  }\n\n  function buildColumns(columns: TableColumnRawOptions[]) {\n    const allColumns: ColumnRawWithKey[][] = []\n    const baseColumns: ColumnWithKey[] = []\n    const columnMap = new Map<Key, ColumnRawWithKey>()\n    const existedTypes = new Set<TableColumnType | ExhibitType>()\n\n    const getFixedOrder = (fixed?: boolean | 'left' | 'right') => {\n      return fixed === true || fixed === 'left' ? -1 : fixed === 'right' ? 1 : 0\n    }\n    const build = (\n      _columns: TableColumnRawOptions[],\n      fixed?: boolean | 'left' | 'right',\n      row = 0,\n      result: ColumnRawWithKey[][] = []\n    ) => {\n      _columns = _columns\n        .filter(column => !('children' in column) || isGroupColumn(column))\n        .sort((prev, next) => (prev.order || 0) - (next.order || 0))\n        .sort((prev, next) => getFixedOrder(prev.fixed) - getFixedOrder(next.fixed))\n      fixed = fixed === true ? 'left' : fixed\n\n      const columns = _columns as ColumnRawWithKey[]\n      const rowColumns = result[row] ?? (result[row] = [])\n\n      let index = row > 0 ? result[row - 1].length - 1 : 0\n\n      for (const { ...column } of columns) {\n        if (!isNullish(fixed)) {\n          column.fixed = fixed\n        }\n\n        rowColumns[index] = column\n\n        if (isGroupColumn(column)) {\n          const endIndex = build(column.children, column.fixed, row + 1, result)\n\n          column.key = Symbol('TableColumnGroup')\n          column.headSpan = endIndex - index\n          index = endIndex\n        } else {\n          const validType =\n            column.type &&\n            (columnTypes.includes(column.type as TableColumnType) || exhibitTypes.includes(column.type as ExhibitType))\n\n          if (validType) {\n            if (existedTypes.has(column.type)) {\n              console.warn(`[pocui:Table] 表具有重复的列，类型为 '${column.type}'`)\n            }\n\n            existedTypes.add(column.type)\n          }\n\n          let key = column.key\n\n          if (isNullish(key)) {\n            if (validType) {\n              key = `__poc_${column.type}`\n            } else {\n              console.warn('[pocui:Table] 表格列需要 key 属性，但缺失')\n\n              key = getIndexId()\n            }\n          }\n\n          column.key = key\n          baseColumns.push(column)\n          index += 1\n        }\n\n        columnMap.set(column.key, column)\n      }\n\n      return index\n    }\n\n    build(columns, undefined, 0, allColumns)\n\n    let length = 0\n\n    for (const rowColumns of allColumns) {\n      length = Math.max(rowColumns.length, length)\n    }\n\n    for (const rowColumns of allColumns) {\n      if (rowColumns.length) {\n        getLast(rowColumns)!.last = true\n      }\n\n      rowColumns.length = length\n    }\n\n    for (let i = 0, rowCount = allColumns.length; i < length; ++i) {\n      let span = 1\n\n      for (let j = rowCount - 1; j >= 0; --j) {\n        const column = allColumns[j][i]\n\n        if (column) {\n          column.colIndex = i\n          column.rowSpan = span\n          span = 1\n        } else {\n          ++span\n        }\n      }\n    }\n\n    return {\n      allColumns,\n      baseColumns,\n      columnMap\n    }\n  }\n\n  function setColumns(columns: TableColumnRawOptions[]) {\n    const { widths, sorters, filters } = state\n    const { allColumns, baseColumns, columnMap } = buildColumns(columns)\n\n    const normalColumns: ColumnWithKey[] = []\n    const rightFixedColumns: ColumnWithKey[] = []\n    const leftFixedColumns: ColumnWithKey[] = []\n\n    for (let i = 0, len = baseColumns.length; i < len; ++i) {\n      const column = baseColumns[i]\n      column.first = false\n      column.last = false\n      column.index = i\n\n      if (column.type && (columnTypes.includes(column.type as any) || exhibitTypes.includes(column.type as any))) {\n        switch (column.type) {\n          case 'order': {\n            column.truthIndex = !!column.truthIndex\n\n            if (typeof column.orderLabel !== 'function') {\n              column.orderLabel = defaultIndexLabel\n            }\n\n            if (isNullish(column.width)) column.width = 60\n\n            break\n          }\n          case 'selection': {\n            column.checkboxSize = column.checkboxSize || 'default'\n\n            if (typeof column.disableRow !== 'function') {\n              column.disableRow = toFalse\n            }\n\n            if (isNullish(column.width)) column.width = 40\n\n            break\n          }\n          case 'expand': {\n            if (typeof column.disableRow !== 'function') {\n              column.disableRow = toFalse\n            }\n\n            if (isNullish(column.width)) column.width = 40\n\n            break\n          }\n          case 'drag': {\n            if (typeof column.disableRow !== 'function') {\n              column.disableRow = toFalse\n            }\n\n            if (isNullish(column.width)) column.width = 40\n\n            break\n          }\n        }\n\n        if (!column.key) {\n          column.key = `__poc_${column.type}-${i}`\n        }\n      } else {\n        column.type = undefined\n      }\n\n      // 独立属性解析时注意隔断同对象引用\n      widths.set(column.key, column.width || 100)\n      sorters.set(column.key, parseSorter(column.sorter))\n      filters.set(column.key, parseFilter(column.filter))\n\n      const fixed = column.fixed\n      if (fixed === true || fixed === 'left') {\n        leftFixedColumns.push(column)\n      } else if (fixed === 'right') {\n        rightFixedColumns.push(column)\n      } else {\n        normalColumns.push(column)\n      }\n    }\n\n    if (state.allColumns.length > allColumns.length) {\n      for (let i = allColumns.length - 1, len = state.allColumns.length; i < len; ++i) {\n        state.rowMap.delete(`${TABLE_HEAD_PREFIX}${i}`)\n      }\n    }\n\n    for (let i = 0, len = allColumns.length; i < len; ++i) {\n      const rowKey = `${TABLE_HEAD_PREFIX}${i}`\n\n      state.rowMap.set(rowKey, createMinRowState(rowKey))\n    }\n\n    state.columnMap = columnMap\n    state.columns = Array.from(leftFixedColumns).concat(normalColumns, rightFixedColumns)\n    state.normalColumns = normalColumns\n    state.allColumns = allColumns\n\n    if (state.columns.length) {\n      for (const column of state.columns) {\n        if (!column.type) {\n          column.first = true\n          break\n        }\n      }\n\n      getLast(state.columns)!.last = true\n    }\n\n    if (leftFixedColumns.length) {\n      state.leftFixedColumns = leftFixedColumns\n    }\n\n    if (rightFixedColumns.length) {\n      state.rightFixedColumns = rightFixedColumns\n    }\n  }\n\n  function setColumnProp(key: Key, prop: string, value: any) {\n    if (state.columnMap.has(key)) {\n      ;(state.columnMap.get(key) as any)[prop] = value\n    }\n  }\n\n  function buildSummaryKey(key: Key) {\n    return isSymbol(key) ? key : `${TABLE_FOOT_PREFIX}${key}`\n  }\n\n  function setSummaries(summaries: TableSummaryOptions[]) {\n    summaries = Array.from(summaries).sort((prev, next) => {\n      return (prev.order || 0) - (next.order || 0)\n    })\n\n    const prevKeys = new Set(state.summaries.map(summary => summary.key))\n    const aboveSummaries: SummaryWithKey[] = []\n    const belowSummaries: SummaryWithKey[] = []\n    const summaryMap = new Map<Key, SummaryWithKey>()\n\n    for (let i = 0, len = summaries.length; i < len; ++i) {\n      const summary = { ...summaries[i] } as SummaryWithKey\n\n      let key = summary.key\n\n      if (isNullish(key)) {\n        console.error('[pocui:Table] 表格摘要需要关键属性，但缺失')\n\n        key = getIndexId()\n      }\n\n      summary.key = key\n      ;(summary.above ? aboveSummaries : belowSummaries).push(summary)\n\n      if (!prevKeys.has(summary.key)) {\n        const rowKey = buildSummaryKey(summary.key)\n\n        state.rowMap.set(rowKey, createMinRowState(rowKey))\n      }\n\n      prevKeys.delete(summary.key)\n      summaryMap.set(summary.key, summary)\n    }\n\n    state.summaries = Array.from(aboveSummaries).concat(belowSummaries)\n    state.summaryMap = summaryMap\n\n    if (aboveSummaries.length) {\n      state.aboveSummaries = aboveSummaries\n    }\n\n    if (belowSummaries.length) {\n      state.belowSummaries = belowSummaries\n    }\n\n    if (prevKeys.size) {\n      for (const key of prevKeys) {\n        state.rowMap.delete(buildSummaryKey(key))\n      }\n    }\n  }\n\n  function setSummaryProp(key: Key, prop: string, value: any) {\n    if (state.summaryMap.has(key)) {\n      ;(state.summaryMap.get(key) as any)[prop] = value\n    }\n  }\n\n  function setDataKey(field: string) {\n    const oldDataKey = state.dataKey\n\n    if (!isNullish(field) && oldDataKey !== field) {\n      const { rowData, idMaps } = state\n\n      state.dataKey = field\n\n      rowData.forEach(row => {\n        let key = row.data[field] as Key\n\n        if (isNullish(key)) {\n          key = getIndexId()\n        }\n\n        row.key = key\n        idMaps.set(row.data, key)\n      })\n    }\n  }\n\n  function collectUnderRows(row: TableRowState, result: TableRowState[] = []) {\n    if (row.treeExpanded && row.children?.length) {\n      for (const childRow of row.children) {\n        result.push(childRow)\n        collectUnderRows(childRow, result)\n      }\n    }\n\n    return result\n  }\n\n  function setData(data: Data[]) {\n    const clonedData: TableRowState[] = []\n    const rowMap = new Map<Key, TableRowState>()\n    const { allColumns, dataKey, keyConfig, idMaps, disabledTree } = state\n    const oldDataMap = state.rowMap\n    const hidden = !!state.virtual\n\n    const {\n      children: childrenKey,\n      checked: checkedKey,\n      height: heightKey,\n      expanded: expandedKey,\n      treeExpanded: treeExpandedKey\n    } = keyConfig\n\n    for (let i = 0, len = allColumns.length; i < len; ++i) {\n      const key = `${TABLE_HEAD_PREFIX}${i}`\n\n      rowMap.set(key, oldDataMap.get(key) || createMinRowState(key))\n    }\n\n    for (const summary of state.summaries) {\n      const key = buildSummaryKey(summary.key)\n\n      rowMap.set(key, oldDataMap.get(key) || createMinRowState(key))\n    }\n\n    const parseRow = (origin: Data[], result: TableRowState[], parent?: TableRowState) => {\n      for (let i = 0, len = origin.length; i < len; ++i) {\n        const item = origin[i]\n\n        let key = item[dataKey] as Key\n\n        if (isNullish(key)) {\n          key = idMaps.get(item)!\n\n          if (isNullish(key)) {\n            key = getIndexId()\n          }\n        }\n\n        let row: TableRowState\n\n        if (oldDataMap.has(key)) {\n          row = oldDataMap.get(key)!\n\n          const {\n            [checkedKey]: checked,\n            [heightKey]: height,\n            [expandedKey]: expanded,\n            [treeExpandedKey]: treeExpanded\n          } = row.data !== item ? Object.assign(row.data, item) : row.data\n\n          row.checked = !isNullish(checked) ? !!checked : row.checked\n          row.height = !isNullish(height) ? toNumber(height) : row.height\n          row.expanded = !isNullish(expanded) ? !!expanded : row.expanded\n          row.treeExpanded = !isNullish(treeExpanded) ? !!treeExpanded : row.treeExpanded\n        } else {\n          const {\n            [checkedKey]: checked,\n            [heightKey]: height,\n            [expandedKey]: expanded,\n            [treeExpandedKey]: treeExpanded\n          } = item\n\n          row = {\n            key,\n            hidden,\n            checked: !!checked,\n            height: toNumber(height),\n            expanded: !!expanded,\n            hover: false,\n            expandHeight: 0,\n            index: -1,\n            children: [],\n            depth: 0,\n            treeExpanded: !!treeExpanded,\n            partial: false,\n            dragging: false,\n            listIndex: 0,\n            cellHeights: reactive({}),\n            last: false,\n            expandAnimate: false,\n            data: item\n          }\n\n          idMaps.set(item, key)\n        }\n\n        if (parent) {\n          row.parent = parent.key\n          row.depth = parent.depth + 1\n        }\n\n        row.children = []\n\n        const children = row.data[childrenKey]\n        children?.length && parseRow(children, row.children, row)\n\n        result.push(row)\n        rowMap.set(key, row)\n      }\n    }\n\n    parseRow(data, clonedData)\n\n    state.rowMap = rowMap\n    state.treeRowData = clonedData\n\n    if (!disabledTree) {\n      flatTreeRows()\n    } else {\n      state.rowData = clonedData\n    }\n\n    state.data = data\n\n    refreshRowIndex()\n    computePartial()\n  }\n\n  function flatTreeRows() {\n    if (state.disabledTree) return\n\n    const rowData: TableRowState[] = []\n\n    for (const row of state.treeRowData) {\n      rowData.push(row)\n      collectUnderRows(row, rowData)\n    }\n\n    state.rowData = rowData\n  }\n\n  function refreshRowDepth() {\n    walkTree(state.treeRowData, (row, depth) => {\n      row.depth = depth\n    })\n  }\n\n  function setCurrentPage(currentPage: number) {\n    state.currentPage = currentPage ?? 1\n  }\n\n  function setPageSize(pageSize: number) {\n    state.pageSize = pageSize || 0\n  }\n\n  function setRowClass(rowClass: ClassType | TableRowPropFn<ClassType>) {\n    state.rowClass = rowClass ?? ''\n  }\n\n  function setRowStyle(rowStyle: StyleType | TableRowPropFn<StyleType>) {\n    state.rowStyle = rowStyle ?? ''\n  }\n\n  function setRowAttrs(rowAttrs: Record<string, any> | TableRowPropFn<Record<string, any>>) {\n    state.rowAttrs = rowAttrs ?? null!\n  }\n\n  function setCellClass(cellClass: ClassType | TableCellPropFn<ClassType>) {\n    state.cellClass = cellClass ?? ''\n  }\n\n  function setCellStyle(cellStyle: StyleType | TableCellPropFn<StyleType>) {\n    state.cellStyle = cellStyle ?? ''\n  }\n\n  function setCellAttrs(cellAttrs: Record<string, any> | TableCellPropFn<Record<string, any>>) {\n    state.cellAttrs = cellAttrs ?? null!\n  }\n\n  function setHeadClass(headClass: ClassType | TableHeadPropFn<ClassType>) {\n    state.headClass = headClass ?? ''\n  }\n\n  function setHeadStyle(headStyle: StyleType | TableHeadPropFn<StyleType>) {\n    state.headStyle = headStyle ?? ''\n  }\n\n  function setHeadAttrs(headAttrs: Record<string, any> | TableHeadPropFn<Record<string, any>>) {\n    state.headAttrs = headAttrs ?? null!\n  }\n\n  function setFootClass(footClass: ClassType | TableFootPropFn<ClassType>) {\n    state.footClass = footClass ?? ''\n  }\n\n  function setFootStyle(footStyle: StyleType | TableFootPropFn<StyleType>) {\n    state.footStyle = footStyle ?? ''\n  }\n\n  function setFootAttrs(footAttrs: Record<string, any> | TableFootPropFn<Record<string, any>>) {\n    state.footAttrs = footAttrs ?? null!\n  }\n\n  function setTableWidth(width: number) {\n    if (state.resized.size) return\n\n    width = toNumber(width)\n\n    const { columns, widths, resized, sidePadding } = state\n\n    const hasWidthColumns: any[] = []\n    const flexColumns: any[] = []\n\n    let flexWidth = width - (sidePadding[0] || 0) - (sidePadding[1] || 0)\n\n    for (let i = 0, len = columns.length; i < len; ++i) {\n      const column = columns[i]\n\n      if (column.width || resized.has(column.key)) {\n        flexWidth -= column.width ?? widths.get(column.key)!\n        hasWidthColumns.push(column)\n      } else {\n        flexColumns.push(column)\n      }\n    }\n\n    const flexColumnCount = flexColumns.length\n\n    let flexUnitWidth = 100\n\n    // 剩余空间有多时, 均分到弹性列\n    if (flexColumnCount) {\n      flexUnitWidth = Math.max(flexWidth / flexColumnCount, 100)\n    }\n\n    let usedWidth = 0\n\n    for (let i = 0; i < flexColumnCount; ++i) {\n      const column = flexColumns[i]\n      const width = Math[i % 2 ? 'ceil' : 'floor'](flexUnitWidth)\n\n      if (i < flexColumnCount - 1) {\n        usedWidth += width\n      }\n\n      widths.set(column.key, width)\n    }\n\n    if (flexColumnCount && flexWidth >= flexColumnCount * flexUnitWidth) {\n      widths.set(getLast(flexColumns)!.key, flexWidth - usedWidth)\n    }\n\n    state.width = width\n  }\n\n  function setRowHeight(height: number) {\n    state.rowHeight = height\n  }\n\n  function setRowMinHeight(height: number) {\n    state.rowMinHeight = height\n  }\n\n  function setCellHeight(rowKey: Key, columnKey: Key, height: number) {\n    if (!isNullish(height) && state.rowMap.has(rowKey)) {\n      state.rowMap.get(rowKey)!.cellHeights[columnKey] = height\n    }\n  }\n\n  function setRowDraggable(draggable: boolean) {\n    state.rowDraggable = !!draggable\n  }\n\n  function setBodyYScroll(scroll: number) {\n    state.bodyYScroll = scroll\n  }\n\n  function setBodyXScroll(scroll: number) {\n    state.bodyXScroll = scroll\n  }\n\n  function setBorder(able: boolean) {\n    state.border = !!able\n  }\n\n  function setStripe(able: boolean) {\n    state.stripe = !!able\n  }\n\n  function setHighlight(able: boolean) {\n    state.highlight = !!able\n  }\n\n  function setVirtual(virtual: boolean) {\n    state.virtual = !!virtual\n  }\n\n  function setRowProp(key: Key, prop: Exclude<keyof TableRowState, 'key'>, value: any) {\n    const row = state.rowMap.get(key)\n\n    if (row && row[prop] !== value) {\n      ;(row as any)[prop] = value\n    }\n  }\n\n  function setLocale(locale: LocaleConfig['table']) {\n    state.locale = locale\n  }\n\n  function setTooltipTheme(theme: TooltipTheme) {\n    state.tooltipTheme = theme\n  }\n\n  function setTooltipWidth(theme: number | string) {\n    state.tooltipWidth = theme\n  }\n\n  function setSingleSorter(able: boolean) {\n    state.singleSorter = !!able\n  }\n\n  function setSingleFilter(able: boolean) {\n    state.singleFilter = !!able\n  }\n\n  function setDragging(dragging: boolean) {\n    state.dragging = !!dragging\n  }\n\n  function setKeyConfig(keyConfig: Required<TableKeyConfig>) {\n    state.keyConfig = keyConfig\n  }\n\n  function setDisabledTree(disabled: boolean) {\n    state.disabledTree = !!disabled\n  }\n\n  function setNoCascaded(noCascaded: boolean) {\n    state.noCascaded = !!noCascaded\n  }\n\n  function setColResizable(resizable: boolean | TableColResizeType) {\n    state.colResizable = resizable === true ? 'lazy' : resizable\n  }\n\n  function setCustomSorter(able: boolean) {\n    state.customSorter = !!able\n  }\n\n  function setCustomFilter(able: boolean) {\n    state.customFilter = !!able\n  }\n\n  function setColumnResizing(resizing: boolean) {\n    state.colResizing = !!resizing\n  }\n\n  function setResizeLeft(left: number) {\n    state.resizeLeft = left\n  }\n\n  function setExpandRenderer(renderer: ExpandRenderFn | null) {\n    state.expandRenderer = renderer\n  }\n\n  function setCellSpan(spanFn: TableCellSpanFn | null) {\n    state.cellSpan = spanFn\n  }\n\n  function setSidePadding(padding: number | number[]) {\n    state.sidePadding = Array.isArray(padding) ? padding : [padding, padding]\n  }\n\n  function setBorderWidth(width: number) {\n    state.borderWidth = Math.max(width, 0)\n  }\n\n  function setDataFilter(filter: (data: Data) => boolean) {\n    state.dataFilter = filter\n  }\n\n  function setEllipsis(ellipsis: boolean) {\n    state.ellipsis = ellipsis\n  }\n\n  function setLocked(locked: boolean) {\n    state.locked = locked\n  }\n\n  function setBarScrolling(scrolling: boolean) {\n    state.barScrolling = scrolling\n  }\n\n  function handleSort(key: Key, type: ParsedTableSorterOptions['type']) {\n    if (state.sorters.has(key)) {\n      if (state.singleSorter && type) {\n        clearSort()\n      }\n\n      state.sorters.get(key)!.type = type\n    }\n  }\n\n  function clearSort() {\n    const sorters = state.sorters\n\n    for (const sorter of sorters.values()) {\n      sorter.type = null\n    }\n  }\n\n  function handleFilter(key: Key, active: ParsedFilterOptions['active']) {\n    if (state.filters.has(key)) {\n      if (state.singleFilter && (Array.isArray(active) ? active.length : active)) {\n        clearFilter()\n      }\n\n      state.filters.get(key)!.active = Array.isArray(active) ? Array.from(active) : active\n    }\n  }\n\n  function clearFilter() {\n    const filters = state.filters\n\n    for (const filter of filters.values()) {\n      filter.active = null\n\n      for (const option of filter.options) {\n        option.active = false\n      }\n    }\n  }\n\n  const { updateCheckedUpward, updateCheckedDown } = useCascadedChecked({\n    getNode: key => (!isNullish(key) ? state.rowMap.get(key) : undefined),\n    disableNode: row => disableCheckRows.value.has(row.key)\n  })\n\n  function computeChecked(key: Key) {\n    const { rowMap, rowData } = state\n    const { disableCheckRows } = getters\n\n    if (!rowMap.has(key)) return\n\n    const rowList = [rowMap.get(key)!].concat(\n      // 需要包含被禁用且被勾选的节点\n      rowData.filter(row => disableCheckRows.has(row.key) && row.checked)\n    )\n\n    for (let i = 0, len = rowList.length; i < len; ++i) {\n      updateCheckedUpward(rowList[i].key)\n      updateCheckedDown(rowList[i].key)\n    }\n  }\n\n  function handleCheck(key: Key, checked: boolean) {\n    const { rowMap, noCascaded } = state\n    const { disableCheckRows } = getters\n    const row = rowMap.get(key)\n\n    if (row && !disableCheckRows.has(key)) {\n      row.checked = !!checked\n      row.partial = false\n    }\n\n    !noCascaded && computeChecked(key)\n    computePartial()\n  }\n\n  function handleCheckAll() {\n    const { rowData, checkedAll } = state\n    const { disableCheckRows } = getters\n\n    let checked = !checkedAll\n\n    // 阻断 disabled 元素对全选的影响\n    if (disableCheckRows.size) {\n      // 由于被禁用的元素不可被操作，如果存在被禁用的元素且该状态为未被选中，则全选时仍然是 partial 状态\n      // 假设除了禁用的元素，其余元素均为选中状态（此时对于用户来说属于已经全选，点击的期望是取消全选）\n      let partialCheckedAll = true\n\n      for (const row of rowData) {\n        // 检查是否存在非禁用的且未被选中的元素（如有则证明现在不是全选，用户点击的期望是进行全选）\n        if (!disableCheckRows.has(row.key) && !row.checked) {\n          partialCheckedAll = false\n\n          break\n        }\n      }\n\n      checked = !partialCheckedAll\n    }\n\n    for (const row of rowData) {\n      if (!disableCheckRows.has(row.key)) {\n        row.checked = checked\n      }\n    }\n\n    state.checkedAll = checked\n    state.partial = false\n\n    computePartial()\n  }\n\n  function clearCheckAll() {\n    const { rowData } = state\n    const { disableCheckRows } = getters\n\n    for (const row of rowData) {\n      if (!disableCheckRows.has(row.key)) {\n        row.checked = false\n      }\n    }\n\n    state.checkedAll = false\n    state.partial = false\n\n    computePartial()\n  }\n\n  function computePartial() {\n    const data = state.rowData\n\n    let hasChecked = false\n    let hasNotChecked = false\n    let partial = false\n\n    for (let i = 0, len = data.length; i < len; ++i) {\n      const row = data[i]\n\n      if (row.checked) {\n        hasChecked = true\n      } else {\n        hasNotChecked = true\n      }\n\n      if (hasChecked && hasNotChecked) {\n        partial = true\n\n        break\n      }\n    }\n\n    if (hasChecked && !partial) {\n      state.checkedAll = true\n    } else {\n      state.checkedAll = false\n    }\n\n    state.partial = partial\n  }\n\n  function setRenderRows(start: number, end: number, force = false) {\n    const { startRow, endRow, heightBITree, virtualData } = state\n\n    if (!force && start === startRow && end === endRow) return\n\n    const { processedData } = getters\n\n    if (!processedData.length) {\n      virtualData.length = 0\n      return\n    }\n\n    const prevData = new Set([...virtualData])\n    const added: TableRowState[] = []\n    const removed: TableRowState[] = []\n\n    for (let i = 0, len = processedData.length; i < len; ++i) {\n      const data = processedData[i]\n\n      data.hidden = !(i >= start && i < end)\n\n      if (data.hidden) {\n        data.hover = false\n\n        if (prevData.has(data)) {\n          removed.push(data)\n        }\n      } else if (!prevData.has(data)) {\n        added.push(data)\n      }\n\n      prevData.delete(data)\n    }\n\n    removed.push(...prevData)\n\n    const length = Math.min(added.length, removed.length)\n\n    for (let i = 0; i < length; ++i) {\n      virtualData[virtualData.indexOf(removed[i])] = added[i]\n    }\n\n    if (added.length > removed.length) {\n      virtualData.push(...added.slice(length))\n    } else if (added.length < removed.length) {\n      state.virtualData = virtualData.filter(data => !removed.includes(data))\n    }\n\n    state.padTop = heightBITree?.sum(start) ?? 0\n    state.startRow = start\n    state.endRow = end\n  }\n\n  function handleExpand(key: Key, expanded: boolean) {\n    const { rowMap } = state\n    const { disableExpandRows } = getters\n\n    if (rowMap.has(key) && !disableExpandRows.has(key)) {\n      rowMap.get(key)!.expanded = !!expanded\n    }\n  }\n\n  function handleDrag(key: Key, dragging: boolean) {\n    const { rowMap } = state\n    const { disableDragRows } = getters\n\n    if (rowMap.has(key) && !disableDragRows.has(key)) {\n      rowMap.get(key)!.dragging = !!dragging\n    }\n  }\n\n  function setTreeExpanded(key: Key, expanded: boolean) {\n    if (!usingTree.value) return\n\n    const { rowMap, rowData, virtual } = state\n    const row = rowMap.get(key)\n\n    if (!row?.children?.length) return\n\n    const underRows = collectUnderRows({\n      ...row,\n      treeExpanded: true\n    })\n\n    if (expanded) {\n      rowData.splice(row.index + 1, 0, ...underRows)\n    } else {\n      rowData.splice(row.index + 1, underRows.length)\n    }\n\n    row.treeExpanded = !!expanded\n\n    refreshRowIndex()\n    virtual && setRenderRows(state.startRow, state.endRow, true)\n  }\n\n  function toggleFilterItemActive(options: {\n    key: Key,\n    value: number | string | null,\n    active?: boolean,\n    disableOthers?: boolean\n  }) {\n    const { key, value, active = false, disableOthers = false } = options\n\n    if (state.filters.has(key)) {\n      const filterOptions = state.filters.get(key)!.options\n\n      if (disableOthers) {\n        for (let i = 0, len = filterOptions.length; i < len; ++i) {\n          filterOptions[i].active = false\n        }\n      }\n\n      const item = filterOptions.find(item => item.value === value)\n\n      if (item) {\n        item.active = active\n      }\n    }\n  }\n\n  function refreshRowIndex() {\n    const data = state.rowData\n\n    for (let i = 0, len = data.length; i < len; ++i) {\n      data[i].index = i\n    }\n  }\n\n  function updateTotalHeight() {\n    const { heightBITree } = state\n\n    if (heightBITree) {\n      state.totalHeight = heightBITree.sum() ?? 0\n    } else {\n      state.totalHeight = 0\n    }\n  }\n\n  function parseSorter(sorter: boolean | TableSorterOptions = false): ParsedTableSorterOptions {\n    const raw = typeof sorter === 'boolean' ? { able: sorter } : sorter\n    const { able = true, type = null, order = 0, method = null } = raw\n\n    return {\n      able,\n      type,\n      order,\n      method\n    }\n  }\n\n  function parseFilter(filter?: TableFilterOptions | null): ParsedFilterOptions {\n    filter = filter || {\n      able: false,\n      options: []\n    }\n\n    const { able = true, custom = false, multiple = false, active = null, method = null, meta } = filter\n    // 防止内部变化触发 deep watch\n    const options = deepClone(filter.options ?? [])\n    const formattedOptions: any[] = []\n\n    for (let i = 0, len = options.length; i < len; ++i) {\n      const item = options[i]\n      const option = typeof item === 'string' ? { value: item } : { ...item }\n\n      option.label = option.label ?? option.value.toString()\n\n      let isActive = false\n\n      if (multiple && Array.isArray(active)) {\n        isActive = active.includes(option.value)\n      } else if (!isNullish(active)) {\n        isActive = Object.is(option.value, active)\n      }\n\n      option.active = isActive\n\n      formattedOptions.push(option as { value: string | number, label: string, active: boolean })\n    }\n\n    return {\n      able,\n      custom,\n      meta,\n      options: formattedOptions,\n      multiple,\n      active,\n      method\n    }\n  }\n\n  function filterData(filters: Map<Key, ParsedFilterOptions>, data: TableRowState[], isSingle: boolean) {\n    const usedFilter: ParsedFilterOptions[] = []\n    const usedData: TableRowState[] = []\n\n    for (const filter of filters.values()) {\n      const { able, active, method } = filter\n\n      if (able && active && typeof method === 'function') {\n        usedFilter.push(filter)\n\n        if (isSingle) break\n      }\n    }\n\n    const usedFilterCount = usedFilter.length\n\n    for (let i = 0, len = data.length; i < len; ++i) {\n      const row = data[i]\n\n      let isFilter = true\n\n      for (let j = 0; j < usedFilterCount; j++) {\n        const { active, method } = usedFilter[j]\n\n        isFilter = method!(active! as any, row.data)\n\n        if (!isFilter) {\n          break\n        }\n      }\n\n      if (isFilter) {\n        usedData.push(row)\n      }\n    }\n\n    return usedData\n  }\n\n  function sortData(\n    sorters: Map<Key, ParsedTableSorterOptions>,\n    data: TableRowState[],\n    columns: TableColumnOptions[],\n    isSingle: boolean\n  ) {\n    const usedSorter: any[] = []\n\n    for (const [_key, sorter] of sorters) {\n      const key = _key as keyof TableRowState\n      const { able, type, order, method } = sorter\n\n      if (able && type) {\n        const column = columns.find(item => item.key === key)\n        const accessor = column?.accessor\n\n        usedSorter.push({\n          able,\n          key,\n          order,\n          type,\n          method: method ?? undefined,\n          accessor(row: TableRowState) {\n            if (typeof accessor === 'function') {\n              return accessor(row.data, row.index)\n            }\n\n            return row.data[key]\n          }\n        })\n\n        if (isSingle) break\n      }\n    }\n\n    // 多列排序优先级\n    usedSorter.sort((prev, next) => prev.order - next.order)\n\n    return sortByProps(data, usedSorter)\n  }\n\n  function pageData(currentPage: number, pageSize: number, data: TableRowState[]) {\n    return pageSize > 0 ? data.slice((currentPage - 1) * pageSize, currentPage * pageSize) : data\n  }\n\n  function getParentRow(key: Key) {\n    const { rowMap } = state\n    const row = rowMap.get(key)\n\n    if (!isNullish(row?.parent)) {\n      return rowMap.get(row!.parent) ?? null\n    }\n\n    return null\n  }\n\n  let lastColumnWidth: number | undefined\n\n  function handleColumnResize(keys: Key[], newWidth: number) {\n    const { resized, widths, columns, width: tableWidth } = state\n    const length = keys.length\n\n    if (!columns.length || !length) return\n\n    const deltaWidth = newWidth / length\n    const lastKey = getLast(columns)!.key\n\n    for (let i = 0; i < length; ++i) {\n      const key = keys[i]\n\n      resized.add(key)\n      widths.set(key, length === 1 ? Math.round(deltaWidth) : Math[i % 2 ? 'ceil' : 'floor'](deltaWidth))\n    }\n\n    let totalWidth = 0\n\n    for (const width of widths.values()) {\n      totalWidth += width\n    }\n\n    totalWidth = toFixed(totalWidth, 1)\n\n    if (totalWidth - widths.get(lastKey)! < tableWidth - (lastColumnWidth ?? widths.get(lastKey)!)) {\n      if (!lastColumnWidth) {\n        lastColumnWidth = widths.get(lastKey)\n      }\n\n      widths.set(lastKey, widths.get(lastKey)! + tableWidth - totalWidth)\n    } else if (lastColumnWidth) {\n      widths.set(lastKey, lastColumnWidth!)\n      lastColumnWidth = undefined\n    }\n  }\n\n  function computeCellSpan() {\n    const {\n      normalColumns,\n      leftFixedColumns,\n      rightFixedColumns,\n      aboveSummaries,\n      belowSummaries,\n      rowData,\n      cellSpanMap,\n      collapseMap\n    } = state\n    const { processedData } = getters\n\n    for (const type of ['left', 'default', 'right'] as const) {\n      cellSpanMap.set(type, new Map())\n      collapseMap.set(type, new Map())\n    }\n\n    function setCellSpan(\n      rowIndex: number,\n      columnIndex: number,\n      fixed: 'left' | 'default' | 'right',\n      getSpan: () => Required<CellSpanResult>,\n      prefix = ''\n    ) {\n      const masterKey = `${prefix}${rowIndex},${columnIndex}`\n      const collapsed = collapseMap.get(fixed)!\n\n      if (collapsed.has(masterKey)) {\n        cellSpanMap.get(fixed)!.set(masterKey, {\n          colSpan: 0,\n          rowSpan: 0\n        })\n        return\n      }\n\n      const span = getSpan()\n      const { colSpan, rowSpan } = span\n\n      for (let i = 0; i < colSpan; ++i) {\n        for (let j = 0; j < rowSpan; ++j) {\n          if (!i && !j) continue\n\n          const key = `${prefix}${rowIndex + j},${columnIndex + i}`\n\n          let masterSet = collapsed.get(key)\n\n          if (!masterSet) {\n            masterSet = new Set()\n            collapsed.set(key, masterSet)\n          }\n\n          masterSet.add(masterKey)\n        }\n      }\n\n      cellSpanMap.get(fixed)!.set(masterKey, span)\n    }\n\n    for (const columns of [normalColumns, leftFixedColumns, rightFixedColumns]) {\n      if (!columns.length) continue\n\n      const fixed = columns[0].fixed === true ? 'left' : columns[0].fixed || 'default'\n      const columnFixed = columns[0].fixed === true ? 'left' : columns[0].fixed || undefined\n\n      const left = state.leftFixedColumns.length\n      const right = state.allColumns[0].length - state.rightFixedColumns.length\n\n      let allColumns: ColumnRawWithKey[][]\n\n      if (fixed === 'left') {\n        allColumns = state.allColumns.map(columns => columns.slice(0, left))\n      } else if (fixed === 'right') {\n        allColumns = state.allColumns.map(columns => columns.slice(right, state.allColumns[0].length))\n      } else {\n        allColumns = state.allColumns.map(columns => columns.slice(left, right))\n      }\n\n      for (let i = 0, len1 = allColumns.length; i < len1; ++i) {\n        const rowColumns = allColumns[i]\n\n        for (let j = 0, len2 = rowColumns.length; j < len2; ++j) {\n          const column = rowColumns[j]\n\n          if (!column) continue\n\n          const fixed = column.fixed === true ? 'left' : column.fixed || 'default'\n\n          setCellSpan(\n            i,\n            j,\n            fixed,\n            () => {\n              const columns =\n                fixed === 'left' ? leftFixedColumns : fixed === 'right' ? rightFixedColumns : normalColumns\n              const colSpan = boundRange(column.headSpan ?? 1, 0, columns.length - j)\n              const span = {\n                colSpan,\n                rowSpan: column.rowSpan\n              }\n\n              return span\n            },\n            'h'\n          )\n        }\n      }\n\n      for (let colIndex = 0, len = columns.length; colIndex < len; ++colIndex) {\n        const column = columns[colIndex]\n\n        for (const row of rowData) {\n          setCellSpan(row.index, column.index, fixed, () => {\n            let result: ReturnType<ColumnCellSpanFn>\n\n            if (typeof column.cellSpan === 'function') {\n              result = column.cellSpan({\n                row: row.data,\n                index: row.index,\n                fixed: columnFixed\n              })\n            } else if (typeof state.cellSpan === 'function') {\n              result = state.cellSpan({\n                row: row.data,\n                rowIndex: row.index,\n                column,\n                columnIndex: column.index,\n                fixed: columnFixed\n              })\n            }\n\n            result = result! || {\n              colSpan: 1,\n              rowSpan: 1\n            }\n\n            const span = {\n              colSpan: result.colSpan ?? 1,\n              rowSpan: result.rowSpan ?? 1\n            }\n\n            span.colSpan = boundRange(span.colSpan, 0, columns.length - colIndex)\n            span.rowSpan = boundRange(span.rowSpan, 0, processedData.length - row.listIndex)\n\n            return span\n          })\n        }\n\n        for (const { prefix, summaries } of [\n          {\n            prefix: 'af',\n            summaries: aboveSummaries\n          },\n          {\n            prefix: 'bf',\n            summaries: belowSummaries\n          }\n        ]) {\n          for (let i = 0, len = summaries.length; i < len; ++i) {\n            const summary = summaries[i]\n\n            setCellSpan(\n              i,\n              column.index,\n              fixed,\n              () => {\n                let result: ReturnType<SummaryCellSpanFn>\n\n                if (typeof summary.cellSpan === 'function') {\n                  result = summary.cellSpan({\n                    column,\n                    index: column.index,\n                    fixed: columnFixed\n                  })\n                }\n\n                const { colSpan, rowSpan } = result! || {\n                  colSpan: 1,\n                  rowSpan: 1\n                }\n                const span = {\n                  colSpan: colSpan ?? 1,\n                  rowSpan: rowSpan ?? 1\n                }\n\n                span.colSpan = boundRange(span.colSpan, 0, columns.length - colIndex)\n                span.rowSpan = boundRange(span.rowSpan, 0, summaries.length - i)\n\n                return span\n              },\n              prefix\n            )\n          }\n        }\n      }\n    }\n  }\n\n  function getCurrentData() {\n    const { treeRowData, disabledTree, keyConfig } = state\n\n    if (disabledTree) {\n      return treeRowData.map(row => ({ ...row.data }))\n    }\n\n    return mapTree(treeRowData, row => ({ ...row.data }), {\n      childField: keyConfig.children as 'children'\n    })\n  }\n\n  function queryRow(keyOrData: Key | Record<any, any>) {\n    const { dataKey, rowMap, idMaps } = state\n\n    let key: Key\n\n    if (typeof keyOrData === 'object') {\n      key = idMaps.get(keyOrData) ?? keyOrData[dataKey]\n    } else {\n      key = keyOrData\n    }\n\n    return isNullish(key) ? undefined : rowMap.get(key)\n  }\n\n  type Store = Readonly<{\n    state: Readonly<typeof state>,\n    getters: Readonly<typeof getters>,\n    mutations: Readonly<typeof mutations>\n  }>\n\n  return {\n    state,\n    getters,\n    mutations\n  } as Store\n}\n\nexport type TableStore = ReturnType<typeof useStore>\n"
    },
    {
      "target": "components/table/symbol.ts",
      "content": "import type { TooltipTheme } from '@/components/tooltip'\nimport type { ClassType, ComponentSize, LocaleConfig, StyleType } from '@pocui/config'\nimport type { BITree } from '@pocui/utils'\nimport type { InjectionKey, Slots } from 'vue'\nimport type { TableStore } from './store'\n\nexport type Key = string | number | symbol\nexport type Data = any\n\nexport type MouseEventType = 'Enter' | 'Leave' | 'Click' | 'Dblclick' | 'Contextmenu'\nexport type MoveEventType = 'Start' | 'Move' | 'End'\n\nexport type TableIconName = 'filter' | 'asc' | 'desc' | 'dragger' | 'expand' | 'plus' | 'minus'\nexport type TableRowPropFn<P = any> = (data: Data, index: number) => P\nexport type TableRowDropType = 'before' | 'after' | 'inner'\nexport type TableTextAlign = 'left' | 'center' | 'right'\nexport type TableColumnType = 'order' | 'selection' | 'expand' | 'drag'\nexport type TableColResizeType = 'lazy' | 'responsive'\nexport type ExhibitPropsFields = 'default' | 'src' | 'options' | 'content' | 'icon' | 'percentage' | 'datetime'\nexport type ExhibitType =\n  | 'avatar'\n  | 'avatar-group'\n  | 'badge'\n  | 'icon'\n  | 'image'\n  | 'image-group'\n  | 'linker'\n  | 'progress'\n  | 'tag'\n  | 'time-ago'\n  | 'viewer'\n\nexport type TableIcons = Partial<Record<TableIconName, Record<string, any> | (() => any)>>\n\nexport const enum DropType {\n  BEFORE = 'before',\n  INNER = 'inner',\n  AFTER = 'after'\n}\n\nexport interface CellSpanResult {\n  colSpan?: number,\n\n  rowSpan?: number\n}\n\nexport interface TableKeyConfig {\n  id?: string,\n\n  children?: string,\n\n  checked?: string,\n\n  height?: string,\n\n  expanded?: string,\n\n  treeExpanded?: string\n}\n\nexport type Accessor<D = Data, Val extends string | number = string | number> = (data: D, index: number) => Val\nexport type ExpandRenderFn<D = Data> = (data: {\n  /** @deprecated */\n  leftFixed: number,\n  /** @deprecated */\n  rightFixed: number,\n  row: D,\n  rowIndex: number\n}) => any\nexport type ColumnCellSpanFn<D = Data> = (data: {\n  row: D,\n  index: number,\n  fixed?: 'left' | 'right'\n}) => CellSpanResult | void\nexport type SummaryCellSpanFn<D = Data, Val extends string | number = string | number> = (data: {\n  column: TableColumnOptions<D, Val>,\n  index: number,\n  fixed?: 'left' | 'right'\n}) => CellSpanResult | void\n\nexport type TableFilterOptions<D = Data, Val extends string | number = string | number> =\n  | {\n    able?: boolean,\n    custom?: false,\n    options?: (string | { value: Val, label?: string, active?: boolean })[],\n    multiple?: false,\n    active?: null | Val,\n    method?: null | ((active: Val, data: D) => boolean),\n    meta?: any\n  }\n  | {\n    able?: boolean,\n    custom?: false,\n    options?: (string | { value: Val, label?: string, active?: boolean })[],\n    multiple: true,\n    active?: null | Val[],\n    method?: null | ((active: Val[], data: D) => boolean),\n    meta?: any\n  }\n  | {\n    able?: boolean,\n    custom: true,\n    options?: never,\n    multiple?: false,\n    active?: null | Val | Val[],\n    method?: null | ((active: any, data: D) => boolean),\n    meta?: any\n  }\n\nexport interface ParsedFilterOptions extends Omit<Required<TableFilterOptions>, 'options'> {\n  options: { value: string | number, label: string, active: boolean }[]\n}\n\nexport interface TableSorterOptions<D = Data> {\n  able?: boolean,\n\n  type?: null | 'asc' | 'desc',\n\n  order?: number, // 优先级\n  method?: null | ((prev: D, next: D) => number)\n}\n\nexport type ParsedTableSorterOptions = Required<TableSorterOptions>\n\nexport interface TableSummaryData {\n  sum: number,\n\n  min: number,\n\n  max: number\n}\n\nexport type SummaryRenderFn<D = Data, Val extends string | number = string | number> = (data: {\n  column: TableColumnOptions<D, Val>,\n  index: number,\n  rows: D[],\n  meta: TableSummaryData\n}) => any\n\nexport type ColumnSummaryRenderFn<D = Data, Val extends string | number = string | number> = (data: {\n  column: TableColumnOptions<D, Val>,\n  index: number,\n  rows: D[],\n  meta: TableSummaryData,\n  summary: TableSummaryOptions<D, Val>\n}) => any\n\nexport interface TableBaseColumn<D = Data, Val extends string | number = string | number> {\n  key: keyof D,\n\n  name: string,\n\n  type?: never,\n\n  meta?: any,\n\n  fixed?: boolean | 'left' | 'right',\n\n  class?: ClassType,\n\n  style?: StyleType,\n\n  attrs?: Record<string, any>,\n\n  width?: number,\n\n  filter?: TableFilterOptions<D, Val>,\n\n  sorter?: boolean | TableSorterOptions<D>,\n\n  order?: number,\n\n  ellipsis?: boolean | null,\n\n  textAlign?: TableTextAlign,\n\n  headSpan?: number,\n\n  noSummary?: boolean,\n\n  indented?: boolean,\n\n  accessor?: Accessor<D, Val>,\n\n  formatter?: (value: Val) => unknown,\n\n  cellSpan?: ColumnCellSpanFn<D>,\n\n  renderer?: ColumnRenderFn<D, Val>,\n\n  headRenderer?: HeadRenderFn,\n\n  filterRenderer?: FilterRenderFn,\n\n  summaryRenderer?: ColumnSummaryRenderFn<D, Val>\n}\n\nexport interface TableOrderColumn<D = Data, Val extends string | number = string | number>\n  extends Omit<TableBaseColumn<D, Val>, 'key' | 'type' | 'renderer'> {\n  key?: keyof D,\n\n  type: 'order',\n\n  truthIndex?: boolean,\n\n  orderLabel?: (index: number) => string | number\n}\n\nexport interface TableSelectionColumn<D = Data, Val extends string | number = string | number>\n  extends Omit<TableBaseColumn<D, Val>, 'key' | 'type' | 'renderer' | 'headRenderer'> {\n  key?: keyof D,\n\n  type: 'selection',\n\n  checkboxSize?: ComponentSize,\n\n  disableRow?: (data: Data) => boolean\n}\n\nexport interface TableExpandColumn<D = Data, Val extends string | number = string | number>\n  extends Omit<TableBaseColumn<D, Val>, 'key' | 'type' | 'renderer'> {\n  key?: keyof D,\n\n  type: 'expand',\n\n  disableRow?: (data: Data) => boolean,\n\n  renderer?: ExpandRenderFn<D>\n}\n\nexport interface TableDragColumn<D = Data, Val extends string | number = string | number>\n  extends Omit<TableBaseColumn<D, Val>, 'key' | 'type' | 'renderer'> {\n  key?: keyof D,\n\n  type: 'drag',\n\n  disableRow?: (data: Data) => boolean\n}\n\nexport interface TableExhibitColumn<D = Data, Val extends string | number = string | number>\n  extends Omit<TableBaseColumn<D, Val>, 'key' | 'type'> {\n  key?: keyof D,\n\n  type: ExhibitType,\n\n  propsFields?: ExhibitPropsFields\n}\n\nexport type TableTypeColumn<D = Data, Val extends string | number = string | number> =\n  | TableOrderColumn<D, Val>\n  | TableSelectionColumn<D, Val>\n  | TableExpandColumn<D, Val>\n  | TableDragColumn<D, Val>\nexport type TableColumnOptions<D = Data, Val extends string | number = string | number> =\n  | TableBaseColumn<D, Val>\n  | TableTypeColumn<D, Val>\n  | TableExhibitColumn<D, Val>\n\nexport type ColumnWithKey<D = Data, Val extends string | number = string | number> = TableColumnOptions<D, Val> & {\n  key: Key,\n  rowSpan: number,\n  /** @internal */\n  index: number,\n  /** @internal */\n  colIndex: number,\n  /** @internal */\n  first?: boolean,\n  /** @internal */\n  last?: boolean\n}\n\nexport interface TableColumnGroupOptions {\n  name: string,\n\n  fixed?: boolean | 'left' | 'right',\n\n  order?: number,\n\n  ellipsis?: boolean,\n\n  textAlign?: TableTextAlign,\n\n  renderer?: () => any,\n\n  children: TableColumnOptions<any, any>[]\n}\n\nexport interface ColumnGroupWithKey extends TableColumnGroupOptions {\n  key: symbol,\n\n  headSpan: number,\n\n  rowSpan: number,\n\n  /** @internal */\n  colIndex: number,\n\n  /** @internal */\n  last?: boolean\n}\n\nexport type ColumnRenderFn<D = Data, Val extends string | number = string | number> = (data: {\n  row: D,\n  rowIndex: number,\n  column: TableBaseColumn<D, Val>,\n  columnIndex: number\n}) => any\nexport type HeadRenderFn<D = Data, Val extends string | number = string | number> = (data: {\n  column: TableColumnOptions<D, Val>,\n  index: number\n}) => any\nexport type FilterRenderFn<D = Data, Val extends string | number = string | number> = (data: {\n  column: TableColumnOptions<D, Val>,\n  index: number,\n  filter: Required<TableFilterOptions<D, Val>>,\n  handleFilter: (active: any) => void\n}) => any\n\nexport type TableCellSpanFn<D = Data, Val extends string | number = string | number> = (data: {\n  row: D,\n  rowIndex: number,\n  column: TableColumnOptions<D, Val>,\n  columnIndex: number,\n  fixed?: 'left' | 'right'\n}) => CellSpanResult | undefined\n\nexport type TableCellPropFn<D = Data, P = any> = (data: {\n  row: D,\n  rowIndex: number,\n  column: ColumnWithKey,\n  columnIndex: number\n}) => P\nexport type TableHeadPropFn<P = any> = (data: { column: ColumnWithKey, index: number, rowIndex: number }) => P\nexport type TableFootPropFn<P = any> = (data: {\n  column: ColumnWithKey,\n  columnIndex: number,\n  summary: SummaryWithKey,\n  summaryIndex: number\n}) => P\n\nexport type ColumnProfile<D = Data, Val extends string | number = string | number> = Pick<\n  ColumnWithKey<D, Val>,\n  'name' | 'key' | 'meta'\n>\nexport type TableFilterProfile<D = Data, Val extends string | number = string | number> = ColumnProfile<D, Val> & {\n  active: Val | Val[]\n}\nexport type TableSorterProfile<D = Data, Val extends string | number = string | number> = ColumnProfile<D, Val> & {\n  type: 'asc' | 'desc',\n  order: number\n}\n\nexport interface TableSummaryOptions<D = Data, Val extends string | number = string | number> {\n  name: string,\n\n  key: keyof D,\n\n  class?: ClassType,\n\n  style?: StyleType,\n\n  attrs?: Record<string, any>,\n\n  order?: number,\n\n  above?: boolean,\n\n  meta?: Record<any, any>,\n\n  cellSpan?: SummaryCellSpanFn<D, Val>,\n\n  renderer?: SummaryRenderFn<D, Val>\n}\n\nexport type SummaryWithKey<D = Data, Val extends string | number = string | number> = TableSummaryOptions<D, Val> & {\n  key: Key\n}\n\n/** @internal */\nexport interface TableRowState {\n  key: Key,\n\n  index: number,\n\n  hidden: boolean,\n\n  hover: boolean,\n\n  checked: boolean,\n\n  height: number,\n\n  expanded: boolean,\n\n  expandHeight: number,\n\n  parent?: Key,\n\n  children: TableRowState[],\n\n  depth: number,\n\n  treeExpanded: boolean,\n\n  partial: boolean,\n\n  dragging: boolean,\n\n  listIndex: number,\n\n  cellHeights: Record<Key, number>,\n\n  last: boolean,\n\n  expandAnimate: boolean,\n\n  data: Data\n}\n\nexport interface StoreOptions {\n  columns: TableColumnRawOptions[],\n\n  summaries: TableSummaryOptions[],\n\n  data: Data[],\n\n  dataKey: string,\n\n  rowClass: ClassType | TableRowPropFn<ClassType>,\n\n  rowStyle: StyleType | TableRowPropFn<StyleType>,\n\n  rowAttrs: Record<string, any> | TableRowPropFn<Record<string, any>>,\n\n  cellClass: ClassType | TableCellPropFn<ClassType>,\n\n  cellStyle: StyleType | TableCellPropFn<StyleType>,\n\n  cellAttrs: Record<string, any> | TableCellPropFn<Record<string, any>>,\n\n  headClass: ClassType | TableHeadPropFn<ClassType>,\n\n  headStyle: StyleType | TableHeadPropFn<StyleType>,\n\n  headAttrs: Record<string, any> | TableHeadPropFn<Record<string, any>>,\n\n  footClass: ClassType | TableFootPropFn<ClassType>,\n\n  footStyle: StyleType | TableFootPropFn<StyleType>,\n\n  footAttrs: Record<string, any> | TableFootPropFn<Record<string, any>>,\n\n  border: boolean,\n\n  stripe: boolean,\n\n  highlight: boolean,\n\n  currentPage: number,\n\n  pageSize: number,\n\n  rowHeight: number,\n\n  rowMinHeight: number,\n\n  virtual: boolean,\n\n  rowDraggable: boolean,\n\n  locale: LocaleConfig['table'],\n\n  tooltipTheme: TooltipTheme,\n\n  tooltipWidth: number | string,\n\n  singleSorter: boolean,\n\n  singleFilter: boolean,\n\n  customSorter: boolean,\n\n  customFilter: boolean,\n\n  keyConfig: Required<TableKeyConfig>,\n\n  disabledTree: boolean,\n\n  noCascaded: boolean,\n\n  colResizable: false | TableColResizeType,\n\n  expandRenderer: ExpandRenderFn | null,\n\n  cellSpan: TableCellSpanFn | null,\n\n  sidePadding: number[],\n\n  borderWidth: number,\n\n  dataFilter: (data: Data) => boolean,\n\n  ellipsis: boolean\n}\n\nexport type TableColumnRawOptions = TableColumnOptions<any, any> | TableColumnGroupOptions\nexport type ColumnRawWithKey = ColumnGroupWithKey | ColumnWithKey\n\nexport interface DataShowKey {\n  key: Key,\n\n  name: string\n}\n\nexport interface StoreState extends StoreOptions {\n  columns: ColumnWithKey[],\n\n  normalColumns: ColumnWithKey[],\n\n  allColumns: ColumnRawWithKey[][],\n\n  summaries: SummaryWithKey[],\n\n  rowData: TableRowState[],\n\n  treeRowData: TableRowState[],\n\n  width: number,\n\n  rightFixedColumns: ColumnWithKey[],\n\n  leftFixedColumns: ColumnWithKey[],\n\n  aboveSummaries: SummaryWithKey[],\n\n  belowSummaries: SummaryWithKey[],\n\n  columnMap: Map<Key, ColumnRawWithKey>,\n\n  rowMap: Map<Key, TableRowState>,\n\n  summaryMap: Map<Key, SummaryWithKey>,\n\n  idMaps: WeakMap<Data, Key>,\n\n  checkedAll: boolean,\n\n  partial: boolean,\n\n  widths: Map<Key, number>,\n\n  sorters: Map<Key, ParsedTableSorterOptions>,\n\n  filters: Map<Key, ParsedFilterOptions>,\n\n  resized: Set<Key>,\n\n  bodyYScroll: number,\n\n  bodyXScroll: number,\n\n  padTop: number,\n\n  startRow: number,\n\n  endRow: number,\n\n  dragging: boolean,\n\n  heightBITree: BITree,\n\n  virtualData: TableRowState[],\n\n  totalHeight: number,\n\n  colResizing: boolean,\n\n  resizeLeft: number,\n\n  cellSpanMap: Map<'left' | 'default' | 'right', Map<string, Required<CellSpanResult>>>,\n\n  collapseMap: Map<'left' | 'default' | 'right', Map<string, Set<string>>>,\n\n  locked: boolean,\n\n  barScrolling: boolean,\n\n  heightTrigger: number\n}\n\nexport interface TableRowInstance {\n  el?: HTMLElement | null,\n\n  row: TableRowState\n}\n\nexport interface TableRowPayload {\n  row: Data,\n\n  key: Key,\n\n  index: number,\n\n  event: Event,\n\n  checked?: boolean,\n\n  expanded?: boolean\n}\n\nexport interface TableCellPayload {\n  row: Data,\n\n  key: Key,\n\n  rowIndex: number,\n\n  column: TableColumnOptions,\n\n  columnIndex: number,\n\n  event: Event\n}\n\nexport interface TableHeadPayload {\n  column: TableColumnOptions,\n\n  index: number,\n\n  event: Event\n}\n\nexport interface TableColResizePayload extends TableHeadPayload {\n  width: number\n}\n\nexport interface TableFootPayload {\n  column: TableColumnOptions,\n\n  columnIndex: number,\n\n  summary: TableSummaryOptions,\n\n  summaryIndex: number,\n\n  event: Event\n}\n\nexport interface TableActions {\n  increaseColumn(column: TableColumnRawOptions): void,\n\n  decreaseColumn(column: TableColumnRawOptions): void,\n\n  increaseSummary(column: TableSummaryOptions): void,\n\n  decreaseSummary(column: TableSummaryOptions): void,\n\n  getTableElement(): HTMLElement | undefined,\n\n  refreshXScroll(): void,\n\n  emitRowCheck(payload: TableRowPayload & { checked: boolean }): void,\n\n  emitAllRowCheck(checked: boolean, partial: boolean): void,\n\n  emitRowExpand(payload: TableRowPayload & { expanded: boolean }): void,\n\n  emitRowTreeExpand(payload: TableRowPayload & { expanded: boolean }): void,\n\n  emitRowFilter(): void,\n\n  emitRowSort(): void,\n\n  handleRowDragStart(rowInstance: TableRowInstance, event: DragEvent): void,\n\n  handleRowDragOver(rowInstance: TableRowInstance, event: DragEvent): void,\n\n  handleRowDrop(rowInstance: TableRowInstance, event: DragEvent): void,\n\n  handleRowDragEnd(event: DragEvent): void,\n\n  emitRowEvent(type: MouseEventType, payload: TableRowPayload): void,\n\n  emitCellEvent(type: MouseEventType, payload: TableCellPayload): void,\n\n  emitHeadEvent(type: MouseEventType, payload: TableHeadPayload): void,\n\n  emitFootEvent(type: MouseEventType, payload: TableFootPayload): void,\n\n  emitColResize(type: MoveEventType, payload: TableColResizePayload): void,\n\n  hasIcon(name: TableIconName): boolean,\n\n  getIcon(name: TableIconName): TableIcons[TableIconName],\n\n  renderTableSlot(payload: { name: string }): any,\n\n  runInLocked(handler?: (...args: any[]) => any, delay?: number): Promise<void>,\n\n  updateColumns(): void,\n\n  setColumnProp(key: Key, prop: string, value: any): void,\n\n  updateSummaries(): void,\n\n  setSummaryProp(key: Key, prop: string, value: any): void,\n\n  startRefresh(): void\n}\n\nexport interface ColumnGroupActions {\n  increaseColumn(column: TableColumnRawOptions): void,\n\n  decreaseColumn(column: TableColumnRawOptions): void\n}\n\nexport const DEFAULT_KEY_FIELD = 'id'\n/**\n * 表格状态管理\n */\nexport const TABLE_STORE: InjectionKey<TableStore> = Symbol('TABLE_STORE')\n/**\n * 表格组件的顶层 Api\n */\nexport const TABLE_ACTIONS: InjectionKey<TableActions> = Symbol('TABLE_ACTIONS')\nexport const TABLE_SLOTS: InjectionKey<Slots> = Symbol('TABLE_SLOTS')\nexport const TABLE_HEAD_PREFIX = '__poc-table-head-'\nexport const TABLE_FOOT_PREFIX = '__poc-table-foot-'\n\nexport const COLUMN_GROUP_ACTIONS: InjectionKey<ColumnGroupActions> = Symbol('COLUMN_GROUP_ACTIONS')\n\nexport const columnTypes: TableColumnType[] = ['order', 'selection', 'expand', 'drag']\n\nexport const exhibitTypes: ExhibitType[] = [\n  'avatar',\n  'avatar-group',\n  'badge',\n  'icon',\n  'image',\n  'image-group',\n  'linker',\n  'progress',\n  'tag',\n  'time-ago',\n  'viewer'\n]\n\nexport const noopFormatter = (v: any) => v\n"
    },
    {
      "target": "components/table/table-body.vue",
      "content": "<script setup lang=\"ts\">\n\nimport { computed, inject, toRef } from 'vue'\n\nimport { getLast } from '@pocui/utils'\nimport { useNameHelper } from '@pocui/config'\nimport { TABLE_STORE } from './symbol'\n\nimport TableCell from './table-cell.vue'\nimport TableRow from './table-row.vue'\n\nimport type { PropType } from 'vue'\n\ndefineOptions({ name: 'TableBody' ,\n  description:'表格主体组件，用于渲染表格的数据行部分。',\n  categories: ['display']})\n\nconst props = defineProps({\n  fixed: {\n    type: String as PropType<'left' | 'right' | undefined>,\n    default: null\n  }\n})\n\ndefineSlots<{\n  empty(props: { isFixed: boolean }): any\n}>()\n\nconst { state, getters } = inject(TABLE_STORE)!\n\nconst nh = useNameHelper('table')\nconst locale = toRef(state, 'locale')\n\nconst columns = computed(() => {\n  return props.fixed === 'left'\n    ? state.leftFixedColumns\n    : props.fixed === 'right'\n      ? state.rightFixedColumns\n      : state.normalColumns\n})\n\nconst data = computed(() => (state.virtual ? state.virtualData : getters.processedData))\nconst style = computed(() => {\n  const width =\n    props.fixed === 'left'\n      ? getLast(getters.leftFixedWidths)\n      : props.fixed === 'right'\n        ? getLast(getters.rightFixedWidths)\n        : getLast(getters.normalWidths)\n  const padLeft = columns.value[0]?.fixed === 'left' ? state.sidePadding[0] || 0 : 0\n  const padRight = getLast(columns.value)?.fixed === 'right' ? state.sidePadding[1] || 0 : 0\n\n  return {\n    [nh.cv('expanded-fix-width')]: props.fixed === 'right' && width ? `${width + padLeft + padRight}px` : '0px',\n    minWidth: width && `${width + padLeft + padRight}px`,\n    minHeight: `${state.totalHeight}px`\n  }\n})\nconst emptyStyle = computed(() => {\n  const { rowHeight, rowMinHeight } = state\n\n  return {\n    minHeight: `${rowHeight || rowMinHeight}px`\n  }\n})\n</script>\n\n<template>\n  <div :class=\"nh.be('body')\" role=\"rowgroup\" :style=\"style\">\n    <template v-if=\"data.length\">\n      <TableRow\n        v-for=\"(row, index) in data\"\n        :key=\"index\"\n        :row=\"row\"\n        :index=\"row.listIndex\"\n        :fixed=\"fixed\"\n        :aria-rowindex=\"row.index\"\n      >\n        <TableCell\n          v-for=\"(column, colIndex) in columns\"\n          :key=\"colIndex\"\n          :row=\"row\"\n          :row-index=\"row.listIndex\"\n          :column=\"column\"\n          :col-index=\"colIndex\"\n          :fixed=\"fixed\"\n          :aria-colindex=\"colIndex\"\n        ></TableCell>\n      </TableRow>\n    </template>\n    <div v-else :class=\"nh.be('empty')\" :style=\"emptyStyle\">\n      <slot name=\"empty\" :is-fixed=\"!!fixed\">\n        <template v-if=\"!fixed\">\n          {{ locale.empty }}\n        </template>\n      </slot>\n    </div>\n  </div>\n</template>\n"
    },
    {
      "target": "components/table/table-cell.vue",
      "content": "<script setup lang=\"ts\">\nimport { Checkbox } from '@/components/checkbox'\nimport { Ellipsis } from '@/components/ellipsis'\nimport { Renderer } from '@/components/renderer'\nimport { ResizeObserver } from '@/components/resize-observer'\nimport { Tooltip } from '@/components/tooltip'\n\nimport { computed, inject, nextTick, ref, watchEffect } from 'vue'\n\nimport { PROVIDED_PROPS_PREFIX, useIcons, useNameHelper } from '@pocui/config'\nimport { getLast, isFunction } from '@pocui/utils'\n\nimport { TABLE_ACTIONS, TABLE_STORE, columnTypes, exhibitTypes, noopFormatter } from './symbol'\n\nimport TableIcon from './table-icon.vue'\n\nimport type {\n  ColumnWithKey,\n  TableDragColumn,\n  TableExhibitColumn,\n  TableExpandColumn,\n  TableOrderColumn,\n  TableRowState,\n  TableSelectionColumn,\n  TableTypeColumn\n} from './symbol'\nimport type { PropType } from 'vue'\n\ndefineOptions({ name: 'TableCell',\n  description:'表格单元格组件，用于渲染表格中的单个数据单元格。',\n  categories: ['display'] })\n\nconst props = defineProps({\n  row: {\n    type: Object as PropType<TableRowState>,\n    default: () => ({})\n  },\n  rowIndex: {\n    type: Number,\n    default: -1\n  },\n  column: {\n    type: Object as PropType<ColumnWithKey>,\n    default: () => ({})\n  },\n  colIndex: {\n    type: Number,\n    default: -1\n  },\n  fixed: {\n    type: String as PropType<'left' | 'right' | undefined>,\n    default: null\n  }\n})\n\nconst { state, getters, mutations } = inject(TABLE_STORE)!\nconst tableActions = inject(TABLE_ACTIONS)!\nconst prefix = inject(PROVIDED_PROPS_PREFIX, '')\nconst nh = useNameHelper('table')\nconst icons = useIcons()\nconst contentHeight = ref(0)\n\nconst wrapper = ref<HTMLElement>()\n\nconst inLast = computed(() => {\n  return props.column.index + cellSpan.value.colSpan >= state.columns.length\n})\nconst className = computed(() => {\n  let customClass: any\n\n  if (typeof state.cellClass === 'function') {\n    customClass = state.cellClass({\n      row: props.row.data,\n      rowIndex: props.rowIndex,\n      column: props.column,\n      columnIndex: props.column.index\n    })\n  } else {\n    customClass = state.cellClass\n  }\n\n  const typed = columnTypes.includes((props.column as TableTypeColumn).type)\n\n  return [\n    nh.be('cell'),\n    {\n      [nh.bem('cell', 'typed')]: typed,\n      [nh.bem('cell', 'center')]: typed || props.column.textAlign === 'center',\n      [nh.bem('cell', 'right')]: props.column.textAlign === 'right',\n      [nh.bem('cell', 'last')]: inLast.value\n    },\n    props.column.class,\n    customClass\n  ]\n})\nconst columns = computed(() => {\n  return props.fixed === 'left'\n    ? state.leftFixedColumns\n    : props.fixed === 'right'\n      ? state.rightFixedColumns\n      : state.normalColumns\n})\nconst cellSpan = computed(() => {\n  return (\n    state.cellSpanMap.get(props.fixed || 'default')!.get(`${props.row.index},${props.column.index}`) || {\n      colSpan: 1,\n      rowSpan: 1\n    }\n  )\n})\nconst customStyle = computed(() => {\n  if (typeof state.cellStyle === 'function') {\n    return state.cellStyle({\n      row: props.row.data,\n      rowIndex: props.rowIndex,\n      column: props.column,\n      columnIndex: props.column.index\n    })\n  }\n\n  return state.cellStyle\n})\nconst style = computed(() => {\n  const totalWidths =\n    props.fixed === 'left'\n      ? getters.leftFixedWidths\n      : props.fixed === 'right'\n        ? getters.rightFixedWidths\n        : getters.normalWidths\n  const { colSpan, rowSpan } = cellSpan.value\n  const noFixed = !getters.hasFixedColumn\n  const padLeft = noFixed || columns.value[0]?.fixed === 'left' ? state.sidePadding[0] || 0 : 0\n  const padRight = noFixed || getLast(columns.value)?.fixed === 'right' ? state.sidePadding[1] || 0 : 0\n  const width = totalWidths[props.colIndex + colSpan] - totalWidths[props.colIndex]\n\n  let height: number | undefined\n\n  if (rowSpan > 1 && state.heightBITree) {\n    height = state.heightBITree.sum(props.row.listIndex + rowSpan) - state.heightBITree.sum(props.row.listIndex)\n  }\n\n  return [\n    props.column.style || '',\n    customStyle.value,\n    {\n      display: !colSpan || !rowSpan ? 'none' : undefined,\n      width: `${(props.column.index ? 0 : padLeft) + (inLast.value ? padRight : 0) + width}px`,\n      height: height ? `${height}px` : undefined,\n      visibility: props.column.fixed && !props.fixed ? 'hidden' : undefined,\n      borderRightWidth:\n        !state.border && colSpan > 1 && props.colIndex + colSpan >= totalWidths.length - 1 ? 0 : undefined,\n      borderBottomWidth: rowSpan > 1 && props.rowIndex + rowSpan >= getters.processedData.length ? 0 : undefined,\n      transform: `translate3d(${(props.column.index ? padLeft : 0) + totalWidths[props.colIndex]}px, 0, 0)`\n    }\n  ]\n})\nconst attrs = computed(() => {\n  let customAttrs: Record<string, any>\n\n  if (typeof state.cellAttrs === 'function') {\n    customAttrs = state.cellAttrs({\n      row: props.row.data,\n      rowIndex: props.rowIndex,\n      column: props.column,\n      columnIndex: props.colIndex\n    })\n  } else {\n    customAttrs = state.cellAttrs\n  }\n\n  return { ...(isExhibitColumn(props.column) ? {} : props.column.attrs || {}), ...(customAttrs || {}) }\n})\n\nconst formatter = computed(() => {\n  return isFunction(props.column.formatter) ? props.column.formatter : noopFormatter\n})\n\nconst exhibitColumnRenderer = computed(() => {\n  if (isExhibitColumn(props.column)) {\n    if (isFunction(props.column.renderer)) {\n      return props.column.renderer({\n        row: props.row.data,\n        rowIndex: props.rowIndex,\n        column: props.column,\n        columnIndex: props.column.index\n      } as any)\n    } else if (isFunction(props.column.accessor)) {\n      return formatter.value(props.column.accessor(props.row.data, props.rowIndex))\n    } else {\n      return formatter.value(props.row.data[props.column.key])\n    }\n  }\n  return void 0\n})\n\nconst propsFields = computed(() => {\n  if (isExhibitColumn(props.column)) {\n    return props.column.propsFields && props.column.propsFields !== 'default'\n      ? { [props.column.propsFields]: exhibitColumnRenderer.value, ...props.column.attrs }\n      : { ...props.column.attrs }\n  }\n  return { ...props.column.attrs }\n})\n\nconst exhibitComponent = computed(() => {\n  return `${prefix}${props.column.type}`\n})\n\nwatchEffect(() => {\n  if (isTypeColumn(props.column)) return\n\n  mutations.setCellHeight(props.row.key, props.column.key, contentHeight.value)\n})\n\nfunction isSelectionColumn(column: unknown): column is TableSelectionColumn {\n  return (column as TableTypeColumn).type === 'selection'\n}\n\nfunction isOrderColumn(column: unknown): column is TableOrderColumn {\n  return (column as TableTypeColumn).type === 'order'\n}\n\nfunction isExpandColumn(column: unknown): column is TableExpandColumn {\n  return (column as TableTypeColumn).type === 'expand'\n}\n\nfunction isDragColumn(column: unknown): column is TableDragColumn {\n  return (column as TableTypeColumn).type === 'drag'\n}\n\nfunction isTypeColumn(column: unknown): column is TableTypeColumn {\n  return isSelectionColumn(column) || isOrderColumn(column) || isExpandColumn(column) || isDragColumn(column)\n}\n\nfunction isExhibitColumn(column: unknown): column is TableExhibitColumn {\n  return exhibitTypes.includes((column as TableExhibitColumn).type)\n}\n\nfunction buildEventPayload(event: Event) {\n  return {\n    row: props.row.data,\n    key: props.row.key,\n    rowIndex: props.rowIndex,\n    column: props.column,\n    columnIndex: props.colIndex,\n    event\n  }\n}\n\nfunction handleMouseEnter(event: MouseEvent) {\n  tableActions?.emitCellEvent('Enter', buildEventPayload(event))\n}\n\nfunction handleMouseLeave(event: MouseEvent) {\n  tableActions?.emitCellEvent('Leave', buildEventPayload(event))\n}\n\nfunction handleClick(event: MouseEvent) {\n  tableActions?.emitCellEvent('Click', buildEventPayload(event))\n}\n\nfunction handleDblclick(event: MouseEvent) {\n  tableActions?.emitCellEvent('Dblclick', buildEventPayload(event))\n}\n\nfunction handleContextmenu(event: MouseEvent) {\n  tableActions?.emitCellEvent('Contextmenu', buildEventPayload(event))\n}\n\nfunction handleCheckRow(row: TableRowState, event: MouseEvent) {\n  if (!getters.disableCheckRows.has(row.key)) {\n    const checked = !row.checked\n    const { data, key, index } = row\n\n    mutations.handleCheck(key, checked)\n    tableActions.emitRowCheck({\n      row: data,\n      key,\n      index,\n      event,\n      checked\n    })\n  }\n}\n\nfunction handleExpandRow(row: TableRowState, event: MouseEvent) {\n  if (!getters.disableExpandRows.has(row.key)) {\n    const expanded = !row.expanded\n    const { data, key, index } = row\n\n    mutations.setRowProp(key, 'expandAnimate', true)\n    nextTick(() => {\n      mutations.handleExpand(key, expanded)\n      tableActions.emitRowExpand({\n        row: data,\n        key,\n        index,\n        event,\n        expanded\n      })\n    })\n  }\n}\n\nfunction handleDragRow(row: TableRowState) {\n  if (!getters.disableDragRows.has(row.key)) {\n    mutations.handleDrag(row.key, true)\n  }\n}\n\nfunction handleExpandTree(row: TableRowState, event: MouseEvent) {\n  if (!row.children?.length) return\n\n  const expanded = !row.treeExpanded\n  const { data, key, index } = row\n\n  tableActions.runInLocked()\n  mutations.setTreeExpanded(row.key, expanded)\n  tableActions.emitRowExpand({\n    row: data,\n    key,\n    index,\n    event,\n    expanded\n  })\n}\n\nif (isExhibitColumn(props.column)) {\n  if (isFunction(props.column.renderer)) {\n    props.column.renderer({\n      row: props.row.data,\n      rowIndex: props.rowIndex,\n      column: props.column,\n      columnIndex: props.column.index\n    } as any)\n  } else if (isFunction(props.column.accessor)) {\n    formatter.value(props.column.accessor(props.row.data, props.rowIndex))\n  } else {\n    formatter.value(props.row.data[props.column.key])\n  }\n}\n\nfunction handleCellResize(entry: ResizeObserverEntry) {\n  contentHeight.value = (entry.borderBoxSize?.[0]?.blockSize ?? entry.contentRect.height) + state.borderWidth\n}\n</script>\n\n<template>\n  <div\n    v-bind=\"attrs\"\n    ref=\"wrapper\"\n    :class=\"className\"\n    role=\"cell\"\n    :scope=\"column.first ? 'row' : undefined\"\n    :colspan=\"cellSpan.colSpan !== 1 ? cellSpan.colSpan : undefined\"\n    :rowspan=\"cellSpan.rowSpan !== 1 ? cellSpan.rowSpan : undefined\"\n    :style=\"style\"\n    @mouseenter=\"handleMouseEnter\"\n    @mouseleave=\"handleMouseLeave\"\n    @click=\"handleClick\"\n    @dblclick=\"handleDblclick\"\n    @contextmenu=\"handleContextmenu\"\n  >\n    <div\n      v-if=\"column.index === 0\"\n      :class=\"nh.be('side-pad')\"\n      role=\"none\"\n      aria-hidden=\"true\"\n    ></div>\n    <div v-if=\"isTypeColumn(column)\" :class=\"nh.be('content')\">\n      <Checkbox\n        v-if=\"isSelectionColumn(column)\"\n        inherit\n        :class=\"nh.be('selection')\"\n        :checked=\"row.checked\"\n        :size=\"column.checkboxSize || 'default'\"\n        :disabled=\"getters.disableCheckRows.has(row.key)\"\n        :partial=\"row.partial\"\n        :control=\"!!row.children?.length\"\n        @click.prevent.stop=\"handleCheckRow(row, $event)\"\n      ></Checkbox>\n      <span v-else-if=\"isOrderColumn(column)\" :class=\"nh.be('order')\">\n        {{ column.orderLabel && column.orderLabel(column.truthIndex ? row.index : rowIndex) }}\n      </span>\n      <template v-else-if=\"isExpandColumn(column)\">\n        <button\n          v-if=\"!getters.disableExpandRows.has(row.key)\"\n          type=\"button\"\n          :class=\"{\n            [nh.be('expand')]: true,\n            [nh.bem('expand', 'active')]: row.expanded\n          }\"\n          @click.stop=\"handleExpandRow(row, $event)\"\n        >\n          <TableIcon name=\"expand\" :origin=\"icons.angleRight\"></TableIcon>\n        </button>\n      </template>\n      <template v-else-if=\"isDragColumn(column)\">\n        <button\n          v-if=\"!getters.disableDragRows.has(row.key)\"\n          type=\"button\"\n          :class=\"nh.be('dragger')\"\n          @mousedown=\"handleDragRow(row)\"\n        >\n          <TableIcon name=\"dragger\" :origin=\"icons.dragger\"></TableIcon>\n        </button>\n      </template>\n    </div>\n    <div v-else-if=\"isExhibitColumn(column)\" :class=\"nh.be('content')\">\n      <Tooltip\n        v-if=\"column.type === 'progress'\"\n        placement=\"left\"\n        trigger=\"hover\"\n        transfer\n        :tip-style=\"{ width: 'auto' }\"\n      >\n        <template #trigger>\n          <component :is=\"exhibitComponent\" v-bind=\"propsFields\">\n            {{ column.propsFields === 'default' ? exhibitColumnRenderer : null }}\n          </component>\n        </template>\n        {{ `${exhibitColumnRenderer}%` }}\n      </Tooltip>\n      <component :is=\"exhibitComponent\" v-else v-bind=\"propsFields\">\n        {{ column.propsFields === 'default' ? exhibitColumnRenderer : null }}\n      </component>\n    </div>\n    <ResizeObserver v-else :on-resize=\"handleCellResize\">\n      <span :class=\"nh.be('content')\">\n        <template\n          v-if=\"\n            getters.usingTree && (getters.indentedColumn ? column.key === getters.indentedColumn.key : column.first)\n          \"\n        >\n          <span\n            :class=\"nh.be('pad')\"\n            :style=\"{\n              [nh.cv('row-depth')]: row.depth\n            }\"\n          ></span>\n          <button\n            type=\"button\"\n            :class=\"[nh.be('tree-expand'), !row.children?.length && nh.bem('tree-expand', 'hidden')]\"\n            @click=\"handleExpandTree(row, $event)\"\n          >\n            <TableIcon v-if=\"row.treeExpanded\" name=\"minus\" :origin=\"icons.minusSquare\"></TableIcon>\n            <TableIcon v-else name=\"plus\" :origin=\"icons.plusSquare\"></TableIcon>\n          </button>\n        </template>\n        <Ellipsis\n          v-if=\"column.ellipsis ?? state.ellipsis\"\n          inherit\n          :class=\"nh.be('ellipsis')\"\n          :tip-disabled=\"state.barScrolling\"\n          :tooltip-theme=\"state.tooltipTheme\"\n          :tip-max-width=\"state.tooltipWidth\"\n        >\n          <Renderer\n            v-if=\"isFunction(column.renderer)\"\n            :renderer=\"column.renderer\"\n            :data=\"{ row: row.data, rowIndex, column, columnIndex: column.index }\"\n          ></Renderer>\n          <template v-else-if=\"isFunction(column.accessor)\">\n            {{ formatter(column.accessor(row.data, rowIndex)) }}\n          </template>\n          <template v-else>\n            {{ formatter(row.data[column.key]) }}\n          </template>\n        </Ellipsis>\n        <template v-else>\n          <Renderer\n            v-if=\"isFunction(column.renderer)\"\n            :renderer=\"column.renderer\"\n            :data=\"{ row: row.data, rowIndex, column, columnIndex: column.index }\"\n          ></Renderer>\n          <template v-else-if=\"isFunction(column.accessor)\">\n            {{ formatter(column.accessor(row.data, rowIndex)) }}\n          </template>\n          <template v-else>\n            {{ formatter(row.data[column.key]) }}\n          </template>\n        </template>\n      </span>\n    </ResizeObserver>\n    <div\n      v-if=\"inLast\"\n      :class=\"[nh.be('side-pad'), nh.bem('side-pad', 'right')]\"\n      role=\"none\"\n      aria-hidden=\"true\"\n    ></div>\n  </div>\n</template>\n"
    },
    {
      "target": "components/table/table-column-group.tsx",
      "content": "import {\n  SlotsType,\n  computed,\n  defineComponent,\n  inject,\n  onBeforeUnmount,\n  provide,\n  reactive,\n  renderSlot,\n  watch\n} from 'vue'\n\nimport { useProps } from '@pocui/config'\nimport { tableColumnGroupProps } from './props'\n\nimport { COLUMN_GROUP_ACTIONS, TABLE_ACTIONS } from './symbol'\n\nimport TableColumn from './table-column'\n\nimport type { ColumnGroupWithKey, TableColumnOptions } from './symbol'\n\ntype GroupPropKey = keyof typeof tableColumnGroupProps\n\nconst propKeys = Object.keys(tableColumnGroupProps) as GroupPropKey[]\nconst ignoredProps: GroupPropKey[] = ['renderer', 'children']\nconst triggerProps: GroupPropKey[] = ['fixed', 'order']\n\nconst TableColumnGroup = defineComponent({\n  name: 'TableColumnGroup',\n  description:'表格列组组件，用于对相关的表格列进行分组管理。',\n  categories: ['display'],\n  inheritAttrs: false,\n  props: tableColumnGroupProps,\n  slots: Object as SlotsType<{\n    default(): any,\n    head(): any\n  }>,\n  setup(_props, { slots }) {\n    const props = useProps('tableColumn', _props, {\n      name: {\n        default: '',\n        static: true\n      },\n      fixed: {\n        default: false,\n        static: true\n      },\n      order: {\n        default: 0,\n        static: true\n      },\n      ellipsis: null,\n      textAlign: 'center',\n      renderer: {\n        default: null,\n        isFunc: true,\n        static: true\n      },\n      children: {\n        default: () => [],\n        static: true\n      }\n    })\n    const tableAction = inject(TABLE_ACTIONS, null)\n    const parentActions = inject(COLUMN_GROUP_ACTIONS, null)\n\n    const columns = reactive(new Set<TableColumnOptions>())\n    const children = computed(() => [...columns])\n    const options = reactive({ children }) as ColumnGroupWithKey\n\n    options.key = Symbol('TableColumnGroup')\n\n    for (const key of propKeys) {\n      if (ignoredProps.includes(key)) {\n        continue\n      }\n      ;(options[key as keyof ColumnGroupWithKey] as any) = props[key]\n\n      const trigger = triggerProps.includes(key)\n\n      watch(\n        () => props[key],\n        value => {\n          ;(options[key as keyof ColumnGroupWithKey] as any) = value\n          trigger ? tableAction?.updateColumns() : tableAction?.setColumnProp(options.key, key as string, value)\n        }\n      )\n    }\n\n    watch(() => props.renderer, setRenderer, { immediate: true })\n\n    provide(COLUMN_GROUP_ACTIONS, {\n      increaseColumn,\n      decreaseColumn\n    })\n\n    if (parentActions) {\n      parentActions.increaseColumn(options)\n\n      onBeforeUnmount(() => {\n        parentActions.decreaseColumn(options)\n      })\n    } else {\n      tableAction?.increaseColumn(options)\n\n      onBeforeUnmount(() => {\n        tableAction?.decreaseColumn(options)\n      })\n    }\n\n    function increaseColumn(column: TableColumnOptions) {\n      columns.add(column)\n    }\n\n    function decreaseColumn(column: TableColumnOptions) {\n      columns.delete(column)\n    }\n\n    function setRenderer() {\n      options.renderer = () => {\n        if (typeof slots.head === 'function') {\n          return renderSlot(slots, 'head')\n        }\n\n        if (typeof props.renderer === 'function') {\n          return props.renderer()\n        }\n\n        return props.name\n      }\n    }\n\n    function renderChildren() {\n      return props.children.map(child => {\n        if ('children' in child) {\n          return <TableColumnGroup {...child}></TableColumnGroup>\n        }\n\n        const { key, ...others } = child\n\n        return <TableColumn {...others} id-key={key}></TableColumn>\n      })\n    }\n\n    return () => [renderSlot(slots, 'default'), ...renderChildren()]\n  }\n})\n\nexport default TableColumnGroup\n"
    },
    {
      "target": "components/table/table-column.ts",
      "content": "import { SlotsType, computed, defineComponent, inject, onBeforeUnmount, reactive, renderSlot, watch } from 'vue'\n\nimport { createSizeProp, useProps } from '@pocui/config'\nimport { isNullish } from '@pocui/utils'\nimport { tableColumnProps } from './props'\n\nimport {\n  COLUMN_GROUP_ACTIONS,\n  ColumnRenderFn,\n  ColumnSummaryRenderFn,\n  FilterRenderFn,\n  HeadRenderFn,\n  TABLE_ACTIONS,\n  columnTypes,\n  exhibitTypes,\n  noopFormatter\n} from './symbol'\n\nimport type { ColumnWithKey, Data, TableRowState, TableTextAlign } from './symbol'\n\ntype ColumnPropKey = keyof typeof tableColumnProps\n\nconst propKeys = Object.keys(tableColumnProps) as ColumnPropKey[]\nconst aliases: Partial<Record<ColumnPropKey, string>> = {\n  idKey: 'key'\n}\nconst ignoredProps: ColumnPropKey[] = ['renderer', 'headRenderer', 'filterRenderer', 'summaryRenderer']\nconst triggerProps: ColumnPropKey[] = [\n  'idKey',\n  'fixed',\n  'type',\n  'width',\n  'sorter',\n  'order',\n  'orderLabel',\n  'disableRow',\n  'headSpan',\n  'cellSpan'\n]\nconst aligns: TableTextAlign[] = ['left', 'center', 'right']\n\nconst funcProp = {\n  default: null,\n  isFunc: true,\n  static: true\n}\n\nexport default defineComponent({\n  name: 'TableColumn',\n  description:'表格列组件，用于定义表格的列结构和数据显示方式。',\n  categories: ['display'],\n  inheritAttrs: false,\n  props: tableColumnProps,\n  slots: Object as SlotsType<{\n    default: ColumnRenderFn,\n    head: HeadRenderFn,\n    filter: FilterRenderFn,\n    summary: ColumnSummaryRenderFn\n  }>,\n  setup(_props, { slots }) {\n    const props = useProps('tableColumn', _props, {\n      idKey: {\n        default: null,\n        validator: value => !isNullish(value),\n        static: true\n      },\n      name: {\n        default: '',\n        static: true\n      },\n      accessor: {\n        default: null,\n        isFunc: true,\n        static: true\n      },\n      fixed: {\n        default: false,\n        static: true\n      },\n      class: null,\n      style: null,\n      attrs: null,\n      type: {\n        default: null,\n        validator: value => columnTypes.includes(value as any) || exhibitTypes.includes(value as any),\n        static: true\n      },\n      propsFields: {\n        default: 'default',\n        static: true\n      },\n      width: null,\n      filter: null,\n      sorter: false,\n      renderer: funcProp,\n      headRenderer: funcProp,\n      filterRenderer: funcProp,\n      order: {\n        default: 0,\n        static: true\n      },\n      ellipsis: null,\n      checkboxSize: createSizeProp(),\n      disableRow: {\n        default: null,\n        isFunc: true\n      },\n      truthIndex: false,\n      orderLabel: {\n        default: null,\n        isFunc: true\n      },\n      meta: null,\n      textAlign: {\n        default: 'center',\n        validator: value => aligns.includes(value)\n      },\n      headSpan: {\n        default: 1,\n        static: true\n      },\n      cellSpan: funcProp,\n      noSummary: false,\n      summaryRenderer: funcProp,\n      indented: false,\n      formatter: {\n        default: null,\n        isFunc: true\n      }\n    })\n    const tableAction = inject(TABLE_ACTIONS, null)\n    const parentActions = inject(COLUMN_GROUP_ACTIONS, null)\n    const options = reactive({}) as ColumnWithKey\n\n    for (const key of propKeys) {\n      if (ignoredProps.includes(key)) continue\n\n      const aliasKey = (aliases[key] || key) as keyof ColumnWithKey\n\n      ;(options[aliasKey] as any) = props[key]\n\n      if (key === 'idKey') {\n        const update = (value: string | number) => {\n          if (isNullish(value) && props.type) {\n            ;(options[aliasKey] as any) = value = `__poc_${props.type}`\n          } else {\n            ;(options[aliasKey] as any) = value\n          }\n        }\n\n        update(props.idKey)\n        watch(\n          () => props.idKey,\n          value => {\n            update(value)\n            tableAction?.updateColumns()\n          }\n        )\n      } else if (key === 'filter') {\n        const filterWithoutMeta = computed(() => {\n          if (props.filter) {\n            const { meta, ...filter } = props.filter\n            return filter\n          }\n\n          return props.filter\n        })\n\n        watch(\n          filterWithoutMeta,\n          () => {\n            options.filter = props.filter\n            tableAction?.updateColumns()\n          },\n          { deep: true }\n        )\n      } else {\n        const trigger = triggerProps.includes(key)\n\n        watch(\n          () => props[key],\n          value => {\n            ;(options[aliasKey] as any) = value\n            trigger ? tableAction?.updateColumns() : tableAction?.setColumnProp(options.key, <string>key, value)\n          }\n        )\n      }\n    }\n\n    watch(() => props.renderer, setRenderer)\n    watch(() => props.headRenderer, setHeadRenderer)\n    watch(() => props.filterRenderer, setFilterRenderer)\n    watch(() => props.summaryRenderer, setSummaryRenderer)\n\n    setRenderer()\n    setHeadRenderer()\n    setFilterRenderer()\n    setSummaryRenderer()\n\n    if (parentActions) {\n      parentActions.increaseColumn(options)\n\n      onBeforeUnmount(() => {\n        parentActions.decreaseColumn(options)\n      })\n    } else {\n      tableAction?.increaseColumn(options)\n\n      onBeforeUnmount(() => {\n        tableAction?.decreaseColumn(options)\n      })\n    }\n\n    // TODO: 在动态列时会触发无限 watch，初步估计是重置单元格合并状态导致的\n    // onBeforeUpdate(() => {\n    //   setRenderer()\n    //   setHeadRenderer()\n    //   setFilterRenderer()\n    // }\n\n    function setRenderer() {\n      if (options.type === 'order' || options.type === 'drag' || options.type === 'selection') {\n        ;(options as any).renderer = undefined\n        return\n      }\n\n      if (!(typeof props.renderer === 'function') && !slots.default) {\n        ;(options as any).renderer = undefined\n        return\n      }\n\n      options.renderer = (data: any) => {\n        if (typeof slots.default === 'function') {\n          return renderSlot(slots, 'default', data)\n        }\n\n        if (typeof props.renderer === 'function') {\n          return props.renderer(data)\n        }\n\n        if (options.type === 'expand') {\n          return ''\n        }\n\n        const row = data.row\n        const rowIndex = data.rowIndex as number\n        const formatter = typeof options.formatter === 'function' ? options.formatter : noopFormatter\n\n        const result = formatter(\n          typeof props.accessor === 'function'\n            ? props.accessor(row as Data, rowIndex)\n            : (row as TableRowState)[options.key as unknown as keyof TableRowState]\n        )\n\n        return isNullish(result) ? '' : String(result)\n      }\n    }\n\n    function setHeadRenderer() {\n      if (options.type === 'selection') {\n        ;(options as any).renderer = undefined\n        return\n      }\n\n      options.headRenderer = data => {\n        if (typeof slots.head === 'function') {\n          return renderSlot(slots, 'head', data)\n        }\n\n        if (typeof props.headRenderer === 'function') {\n          return props.headRenderer(data)\n        }\n\n        return props.name\n      }\n    }\n\n    function setFilterRenderer() {\n      if (typeof slots.filter === 'function' || typeof props.filterRenderer === 'function') {\n        options.filterRenderer = data => {\n          if (typeof slots.filter === 'function') {\n            return renderSlot(slots, 'filter', data)\n          }\n\n          return props.filterRenderer(data)\n        }\n      } else {\n        options.filterRenderer = undefined\n      }\n    }\n\n    function setSummaryRenderer() {\n      if (typeof slots.summary === 'function' || typeof props.summaryRenderer === 'function') {\n        options.summaryRenderer = data => {\n          if (typeof slots.summary === 'function') {\n            return renderSlot(slots, 'summary', data)\n          }\n\n          if (typeof props.summaryRenderer === 'function') {\n            return props.summaryRenderer(data)\n          }\n\n          return ''\n        }\n      } else {\n        options.summaryRenderer = undefined\n      }\n    }\n\n    return () => null\n  }\n})\n"
    },
    {
      "target": "components/table/table-foot-cell.vue",
      "content": "<script setup lang=\"ts\">\nimport { Ellipsis } from '@/components/ellipsis'\nimport { Renderer } from '@/components/renderer'\nimport { ResizeObserver } from '@/components/resize-observer'\n\nimport { computed, inject, ref } from 'vue'\n\nimport { useNameHelper } from '@pocui/config'\nimport { getLast, isFunction } from '@pocui/utils'\n\nimport { TABLE_ACTIONS, TABLE_STORE, columnTypes } from './symbol'\n\nimport type { PropType } from 'vue'\n\nimport type { ColumnWithKey, SummaryWithKey, TableRowState, TableTypeColumn } from './symbol'\n\ndefineOptions({ name: 'TableFootCell',\n  description:'表格脚部单元格组件，用于渲染表格底部的汇总数据单元格。',\n  categories: ['display'] })\n\nconst props = defineProps({\n  row: {\n    type: Object as PropType<TableRowState>,\n    default: () => ({})\n  },\n  column: {\n    type: Object as PropType<ColumnWithKey>,\n    default: () => ({})\n  },\n  colIndex: {\n    type: Number,\n    default: -1\n  },\n  summary: {\n    type: Object as PropType<SummaryWithKey>,\n    default: () => ({})\n  },\n  summaryIndex: {\n    type: Number,\n    default: -1\n  },\n  fixed: {\n    type: String as PropType<'left' | 'right' | undefined>,\n    default: null\n  },\n  above: {\n    type: Boolean,\n    default: false\n  }\n})\n\nconst { state, getters, mutations } = inject(TABLE_STORE)!\nconst tableActions = inject(TABLE_ACTIONS)!\n\nconst nh = useNameHelper('table')\n\nconst wrapper = ref<HTMLElement>()\n\nconst inLast = computed(() => {\n  return props.column.index + cellSpan.value.colSpan >= state.columns.length\n})\nconst columns = computed(() => {\n  return props.fixed === 'left'\n    ? state.leftFixedColumns\n    : props.fixed === 'right'\n      ? state.rightFixedColumns\n      : state.normalColumns\n})\n// 我们用 'a' 和 'b' 来区分上面和下面\nconst prefix = computed(() => (props.above ? 'af' : 'bf'))\nconst summaries = computed(() => (props.above ? state.aboveSummaries : state.belowSummaries))\nconst heights = computed(() => (props.above ? getters.topFixedHeights : getters.bottomFixedHeights))\nconst className = computed(() => {\n  let customClass: any\n\n  if (typeof state.footClass === 'function') {\n    customClass = state.footClass({\n      column: props.column,\n      columnIndex: props.column.index,\n      summary: props.summary,\n      summaryIndex: props.summaryIndex\n    })\n  } else {\n    customClass = state.footClass\n  }\n\n  const typed = columnTypes.includes((props.column as TableTypeColumn).type)\n\n  return [\n    nh.be('foot-cell'),\n    {\n      [nh.bem('foot-cell', 'typed')]: typed,\n      [nh.bem('foot-cell', 'center')]: typed || props.column.textAlign === 'center',\n      [nh.bem('foot-cell', 'right')]: props.column.textAlign === 'right',\n      [nh.bem('foot-cell', 'last')]: inLast.value\n    },\n    props.column.class,\n    customClass\n  ]\n})\nconst cellSpan = computed(() => {\n  return (\n    state.cellSpanMap\n      .get(props.fixed || 'default')!\n      .get(`${prefix.value}${props.summaryIndex},${props.column.index}`) || {\n      colSpan: 1,\n      rowSpan: 1\n    }\n  )\n})\nconst customStyle = computed(() => {\n  if (typeof state.footStyle === 'function') {\n    return state.footStyle({\n      column: props.column,\n      columnIndex: props.column.index,\n      summary: props.summary,\n      summaryIndex: props.summaryIndex\n    })\n  }\n\n  return state.cellStyle\n})\nconst style = computed(() => {\n  const totalWidths =\n    props.fixed === 'left'\n      ? getters.leftFixedWidths\n      : props.fixed === 'right'\n        ? getters.rightFixedWidths\n        : getters.normalWidths\n  const { colSpan, rowSpan } = cellSpan.value\n  const padLeft = columns.value[0]?.fixed === 'left' ? state.sidePadding[0] || 0 : 0\n  const padRight = getLast(columns.value)?.fixed === 'right' ? state.sidePadding[1] || 0 : 0\n  const width = totalWidths[props.colIndex + colSpan] - totalWidths[props.colIndex]\n\n  let height: number | undefined\n\n  if (rowSpan > 1) {\n    height = heights.value[props.summaryIndex + rowSpan] - heights.value[props.summaryIndex]\n  }\n\n  return [\n    props.column.style || '',\n    customStyle.value,\n    {\n      display: !colSpan || !rowSpan ? 'none' : undefined,\n      width: `${(props.column.index ? 0 : padLeft) + (inLast.value ? padRight : 0) + width}px`,\n      height: height ? `${height}px` : undefined,\n      visibility: props.column.fixed && !props.fixed ? 'hidden' : undefined,\n      borderRightWidth:\n        !state.border && colSpan > 1 && props.colIndex + colSpan >= totalWidths.length - 1 ? 0 : undefined,\n      borderBottomWidth: rowSpan > 1 && props.summaryIndex + rowSpan >= summaries.value.length ? 0 : undefined,\n      transform: `translate3d(${(props.column.index ? padLeft : 0) + totalWidths[props.colIndex]}px, 0, 0)`\n    }\n  ]\n})\nconst attrs = computed(() => {\n  let customAttrs: Record<string, any>\n\n  if (typeof state.footAttrs === 'function') {\n    customAttrs = state.footAttrs({\n      column: props.column,\n      columnIndex: props.column.index,\n      summary: props.summary,\n      summaryIndex: props.summaryIndex\n    })\n  } else {\n    customAttrs = state.footAttrs\n  }\n\n  return { ...(props.column.attrs || {}), ...(customAttrs || {}) }\n})\nconst summaryData = computed(() => getters.summaryData.get(props.column.key))\n\nfunction buildEventPayload(event: Event) {\n  return {\n    column: props.column,\n    columnIndex: props.column.index,\n    summary: props.summary,\n    summaryIndex: props.summaryIndex,\n    event\n  }\n}\n\nfunction handleMouseEnter(event: MouseEvent) {\n  tableActions?.emitFootEvent('Enter', buildEventPayload(event))\n}\n\nfunction handleMouseLeave(event: MouseEvent) {\n  tableActions?.emitFootEvent('Leave', buildEventPayload(event))\n}\n\nfunction handleClick(event: MouseEvent) {\n  tableActions?.emitFootEvent('Click', buildEventPayload(event))\n}\n\nfunction handleDblclick(event: MouseEvent) {\n  tableActions?.emitFootEvent('Dblclick', buildEventPayload(event))\n}\n\nfunction handleContextmenu(event: MouseEvent) {\n  tableActions?.emitFootEvent('Contextmenu', buildEventPayload(event))\n}\n\nfunction handleCellResize(entry: ResizeObserverEntry) {\n  mutations.setCellHeight(\n    props.row.key,\n    props.column.key,\n    (entry.borderBoxSize?.[0]?.blockSize ?? entry.contentRect.height) + state.borderWidth\n  )\n}\n</script>\n\n<template>\n  <div\n    v-bind=\"attrs\"\n    ref=\"wrapper\"\n    :class=\"className\"\n    role=\"cell\"\n    :scope=\"column.first ? 'row' : undefined\"\n    :colspan=\"cellSpan.colSpan !== 1 ? cellSpan.colSpan : undefined\"\n    :rowspan=\"cellSpan.rowSpan !== 1 ? cellSpan.rowSpan : undefined\"\n    :style=\"style\"\n    @mouseenter=\"handleMouseEnter\"\n    @mouseleave=\"handleMouseLeave\"\n    @click=\"handleClick\"\n    @dblclick=\"handleDblclick\"\n    @contextmenu=\"handleContextmenu\"\n  >\n    <div\n      v-if=\"column.index === 0\"\n      :class=\"nh.be('side-pad')\"\n      role=\"none\"\n      aria-hidden=\"true\"\n    ></div>\n    <ResizeObserver\n      v-if=\"isFunction(summary.renderer)\"\n      :disabled=\"column.ellipsis ?? state.ellipsis\"\n      :on-resize=\"handleCellResize\"\n    >\n      <span :class=\"nh.be('content')\">\n        <Ellipsis\n          v-if=\"column.ellipsis ?? state.ellipsis\"\n          inherit\n          :class=\"nh.be('ellipsis')\"\n          :tooltip-theme=\"state.tooltipTheme\"\n          :tip-max-width=\"state.tooltipWidth\"\n        >\n          <Renderer\n            :renderer=\"summary.renderer\"\n            :data=\"{ column, index: column.index, rows: state.data, meta: summaryData }\"\n          ></Renderer>\n        </Ellipsis>\n        <Renderer\n          v-else\n          :renderer=\"summary.renderer\"\n          :data=\"{ column, index: column.index, rows: state.data, meta: summaryData }\"\n        ></Renderer>\n      </span>\n    </ResizeObserver>\n    <div\n      v-if=\"inLast\"\n      :class=\"[nh.be('side-pad'), nh.bem('side-pad', 'right')]\"\n      role=\"none\"\n      aria-hidden=\"true\"\n    ></div>\n  </div>\n</template>\n"
    },
    {
      "target": "components/table/table-foot.vue",
      "content": "<script setup lang=\"ts\">\nimport { computed, inject } from 'vue'\n\nimport { getLast } from '@pocui/utils'\nimport { useNameHelper } from '@pocui/config'\nimport { TABLE_STORE } from './symbol'\n\nimport TableFootCell from './table-foot-cell.vue'\nimport TableRow from './table-row.vue'\n\nimport type { PropType } from 'vue'\n\ndefineOptions({ name: 'TableFoot',\n  description:'表格脚部组件，用于渲染表格的底部汇总信息。',\n  categories: ['display'] })\n\nconst props = defineProps({\n  fixed: {\n    type: String as PropType<'left' | 'right' | undefined>,\n    default: null\n  },\n  above: {\n    type: Boolean,\n    default: false\n  }\n})\n\nconst { state, getters, mutations } = inject(TABLE_STORE)!\n\nconst nh = useNameHelper('table')\n\nconst columns = computed(() => {\n  return props.fixed === 'left'\n    ? state.leftFixedColumns\n    : props.fixed === 'right'\n      ? state.rightFixedColumns\n      : state.normalColumns\n})\nconst summaries = computed(() => (props.above ? state.aboveSummaries : state.belowSummaries))\nconst summaryData = computed(() => {\n  return summaries.value.map(summary => {\n    const key = mutations.buildSummaryKey(summary.key)\n    const row = state.rowMap.get(key) || mutations.createMinRowState(key)\n\n    return {\n      summary,\n      row\n    }\n  })\n})\nconst className = computed(() => {\n  return [nh.be('foot'), nh.bem('foot', props.above ? 'above' : 'below')]\n})\nconst style = computed(() => {\n  const width =\n    props.fixed === 'left'\n      ? getLast(getters.leftFixedWidths)\n      : props.fixed === 'right'\n        ? getLast(getters.rightFixedWidths)\n        : getLast(getters.normalWidths)\n  const padLeft = columns.value[0]?.fixed === 'left' ? state.sidePadding[0] || 0 : 0\n  const padRight = getLast(columns.value)?.fixed === 'right' ? state.sidePadding[1] || 0 : 0\n\n  return {\n    minWidth: width && `${width + padLeft + padRight}px`\n  }\n})\n</script>\n\n<template>\n  <div :class=\"className\" role=\"rowgroup\" :style=\"style\">\n    <TableRow\n      v-for=\"({ row, summary }, index) in summaryData\"\n      :key=\"row.key\"\n      is-foot\n      :fixed=\"fixed\"\n      :row=\"row\"\n      :aria-rowindex=\"index\"\n    >\n      <TableFootCell\n        v-for=\"(column, colIndex) in columns\"\n        :key=\"colIndex\"\n        :row=\"row\"\n        :column=\"column\"\n        :col-index=\"colIndex\"\n        :summary=\"summary\"\n        :summary-index=\"index\"\n        :fixed=\"fixed\"\n        :above=\"above\"\n        :aria-colindex=\"colIndex\"\n      ></TableFootCell>\n    </TableRow>\n  </div>\n</template>\n"
    },
    {
      "target": "components/table/table-head-cell.vue",
      "content": "<script setup lang=\"ts\">\nimport { Button } from '@/components/button'\nimport { Checkbox } from '@/components/checkbox'\nimport { Ellipsis } from '@/components/ellipsis'\nimport { Renderer } from '@/components/renderer'\nimport { ResizeObserver } from '@/components/resize-observer'\nimport { Tooltip } from '@/components/tooltip'\n\nimport { computed, inject, ref, toRef } from 'vue'\n\nimport { type ClassType, useIcons, useNameHelper } from '@pocui/config'\n\nimport { useMoving } from '@pocui/hooks'\nimport { getLast, isFunction, nextFrameOnce } from '@pocui/utils'\n\nimport { TABLE_ACTIONS, TABLE_HEAD_PREFIX, TABLE_STORE, columnTypes } from './symbol'\n\nimport TableIcon from './table-icon.vue'\n\nimport type { PropType } from 'vue'\n\nimport type {\n  ColumnWithKey,\n  ParsedFilterOptions,\n  ParsedTableSorterOptions,\n  TableRowState,\n  TableSelectionColumn,\n  TableTypeColumn\n} from './symbol'\n\nimport type { MovingState } from '@pocui/hooks'\n\ndefineOptions({ name: 'TableHeadCell',\n  description:'表格头部单元格组件，用于渲染表格头部的列标题和操作。',\n  categories: ['display'] })\n\nconst props = defineProps({\n  column: {\n    type: Object as PropType<ColumnWithKey>,\n    default: () => ({})\n  },\n  index: {\n    type: Number,\n    default: -1\n  },\n  row: {\n    type: Object as PropType<TableRowState>,\n    default: () => ({})\n  },\n  rowIndex: {\n    type: Number,\n    default: 0\n  },\n  fixed: {\n    type: String as PropType<'left' | 'right' | undefined>,\n    default: null\n  }\n})\n\nconst { state, getters, mutations } = inject(TABLE_STORE)!\nconst tableActions = inject(TABLE_ACTIONS)!\n\nconst nh = useNameHelper('table')\nconst locale = toRef(state, 'locale')\nconst icons = useIcons()\n\nconst filterVisible = ref(false)\nconst resizable = toRef(state, 'colResizable')\nconst resizing = computed(() => state.colResizing)\n\nconst wrapper = ref<HTMLElement>()\n\nconst isGroup = computed(() => mutations.isGroupColumn(props.column))\nconst columns = computed(() => {\n  return props.fixed === 'left'\n    ? state.leftFixedColumns\n    : props.fixed === 'right'\n      ? state.rightFixedColumns\n      : state.normalColumns\n})\nconst cellSpan = computed(() => {\n  return (\n    state.cellSpanMap.get(props.fixed || 'default')!.get(`h${props.rowIndex},${props.index}`) || {\n      colSpan: 1,\n      rowSpan: 1\n    }\n  )\n})\nconst inLast = computed(() => {\n  return isGroup.value ? props.column.last : props.column.index + cellSpan.value.colSpan >= state.columns.length\n})\n\nconst minWidth = 10\n\nlet currentWidth = 0\n\nfunction processColResize(payload: MovingState, lazy = false) {\n  const width = Math.max(currentWidth + payload.deltaX, minWidth)\n\n  !lazy &&\n    mutations.handleColumnResize(\n      state.columns.slice(props.column.index, props.column.index + cellSpan.value.colSpan).map(column => column.key),\n      width\n    )\n\n  return width\n}\n\nconst { target: resizer } = useMoving({\n  capture: false,\n  onStart: (payload, event) => {\n    if (!resizable.value || resizing.value || isGroup.value) return false\n\n    const table = tableActions.getTableElement()\n\n    if (!table || !wrapper.value) return false\n\n    payload.xStart = payload.clientX - table.getBoundingClientRect().left\n    currentWidth = wrapper.value.getBoundingClientRect().width\n\n    mutations.setColumnResizing(true)\n    mutations.setResizeLeft(payload.xStart)\n    tableActions.emitColResize('Start', {\n      ...buildEventPayload(event),\n      width: currentWidth\n    })\n  },\n  onMove: (payload, event) => {\n    payload.xEnd = Math.max(payload.xStart - currentWidth + minWidth, payload.xEnd)\n\n    mutations.setResizeLeft(payload.xEnd)\n    tableActions.emitColResize('Move', {\n      ...buildEventPayload(event),\n      width: processColResize(payload, state.colResizable !== 'responsive')\n    })\n  },\n  onEnd: (payload, event) => {\n    mutations.setColumnResizing(false)\n    tableActions.emitColResize('End', {\n      ...buildEventPayload(event),\n      width: processColResize(payload)\n    })\n  }\n})\n\nconst typed = computed(() => columnTypes.includes((props.column as TableTypeColumn).type))\nconst className = computed(() => {\n  let customClass: ClassType\n\n  if (typeof state.headClass === 'function') {\n    customClass = state.headClass({\n      column: props.column,\n      index: props.column.colIndex,\n      rowIndex: props.rowIndex\n    })\n  } else {\n    customClass = state.headClass\n  }\n\n  return [\n    nh.be('head-cell'),\n    {\n      [nh.bem('head-cell', 'group')]: isGroup.value,\n      [nh.bem('head-cell', 'typed')]: typed.value,\n      [nh.bem('head-cell', 'center')]: typed.value || props.column.textAlign === 'center',\n      [nh.bem('head-cell', 'right')]: props.column.textAlign === 'right',\n      [nh.bem('head-cell', 'last')]: inLast.value\n    },\n    props.column.class,\n    customClass\n  ]\n})\nconst customStyle = computed(() => {\n  if (typeof state.headStyle === 'function') {\n    return state.headStyle({\n      column: props.column,\n      index: props.column.colIndex,\n      rowIndex: props.rowIndex\n    })\n  }\n\n  return state.headStyle\n})\nconst style = computed(() => {\n  const totalWidths =\n    props.fixed === 'left'\n      ? getters.leftFixedWidths\n      : props.fixed === 'right'\n        ? getters.rightFixedWidths\n        : getters.normalWidths\n  const { colSpan, rowSpan } = cellSpan.value\n  const noFixed = !getters.hasFixedColumn\n  const padLeft = noFixed || columns.value[0]?.fixed === 'left' ? state.sidePadding[0] || 0 : 0\n  const padRight = noFixed || getLast(columns.value)?.fixed === 'right' ? state.sidePadding[1] || 0 : 0\n  const width = totalWidths[props.index + colSpan] - totalWidths[props.index]\n\n  let height: number | undefined\n\n  if (rowSpan > 1) {\n    height = 0\n\n    for (let i = 0; i < rowSpan; ++i) {\n      height += state.rowMap.get(`${TABLE_HEAD_PREFIX}${props.rowIndex + i}`)?.height ?? 0\n    }\n  }\n\n  return [\n    props.column.style || '',\n    customStyle.value,\n    {\n      display: !colSpan ? 'none' : undefined,\n      width: `${(props.column.index ? 0 : padLeft) + (inLast.value ? padRight : 0) + width}px`,\n      height: height ? `${height}px` : undefined,\n      visibility: props.column.fixed && !props.fixed ? 'hidden' : undefined,\n      borderRightWidth: !state.border && colSpan > 1 && props.index + colSpan >= totalWidths.length - 1 ? 0 : undefined,\n      transform: `translate3d(${(props.column.index ? padLeft : 0) + totalWidths[props.index]}px, 0, 0)`\n    }\n  ]\n})\nconst attrs = computed(() => {\n  let customAttrs: Record<string, any>\n\n  if (typeof state.headAttrs === 'function') {\n    customAttrs = state.headAttrs({\n      column: props.column,\n      index: props.column.colIndex,\n      rowIndex: props.rowIndex\n    })\n  } else {\n    customAttrs = state.headAttrs\n  }\n\n  return { ...(props.column.attrs || {}), ...(customAttrs || {}) }\n})\nconst sorter = computed(() => {\n  return state.sorters.get(props.column.key) || ({} as ParsedTableSorterOptions)\n})\nconst filter = computed(() => {\n  return state.filters.get(props.column.key) || ({} as ParsedFilterOptions)\n})\nconst hasFilterActive = computed(() => {\n  const options = filter.value.options ?? []\n\n  for (let i = 0, len = options.length; i < len; ++i) {\n    if (options[i].active) {\n      return true\n    }\n  }\n\n  return false\n})\nconst checkboxDisabled = computed(() => {\n  if (!isSelection(props.column)) {\n    return false\n  }\n\n  const records = Object.values(getters.disableCheckRows)\n\n  return getters.processedData.length === records.length && !Object.values(getters.disableCheckRows).includes(false)\n})\n\nconst refreshXScroll = () => nextFrameOnce(tableActions.refreshXScroll)\n\nfunction isSelection(column: unknown): column is TableSelectionColumn {\n  return !isGroup.value && (column as TableTypeColumn).type === 'selection'\n}\n\nfunction buildEventPayload(event: Event) {\n  return {\n    column: props.column,\n    index: props.column.colIndex,\n    event\n  }\n}\n\nfunction handleMouseEnter(event: MouseEvent) {\n  tableActions?.emitHeadEvent('Enter', buildEventPayload(event))\n}\n\nfunction handleMouseLeave(event: MouseEvent) {\n  tableActions?.emitHeadEvent('Leave', buildEventPayload(event))\n}\n\nfunction handleClick(event: MouseEvent) {\n  tableActions?.emitHeadEvent('Click', buildEventPayload(event))\n}\n\nfunction handleDblclick(event: MouseEvent) {\n  tableActions?.emitHeadEvent('Dblclick', buildEventPayload(event))\n}\n\nfunction handleContextmenu(event: MouseEvent) {\n  tableActions?.emitHeadEvent('Contextmenu', buildEventPayload(event))\n}\n\nfunction handleSortAsc() {\n  const key = props.column.key\n  const type = sorter.value.type === 'asc' ? null : 'asc'\n\n  mutations.handleSort(key, type)\n  tableActions.emitRowSort()\n}\n\nfunction handleSortDesc() {\n  const key = props.column.key\n  const type = sorter.value.type === 'desc' ? null : 'desc'\n\n  mutations.handleSort(key, type)\n  tableActions.emitRowSort()\n}\n\nfunction handleFilter(value: ParsedFilterOptions['active']) {\n  mutations.handleFilter(props.column.key, value)\n}\n\nfunction handleFilterItemSelect(value: string | number, active: boolean) {\n  mutations.toggleFilterItemActive({\n    key: props.column.key,\n    value,\n    active,\n    disableOthers: true\n  })\n  handleFilter(value)\n  filterVisible.value = false\n  tableActions.emitRowFilter()\n}\n\nfunction handleFilterCheck(value: string | number, checked: boolean) {\n  mutations.toggleFilterItemActive({\n    key: props.column.key,\n    value,\n    active: checked\n  })\n}\n\nfunction handleFilterMultiple() {\n  const options = filter.value.options ?? []\n  const activeValues: any[] = []\n\n  for (let i = 0, len = options.length; i < len; ++i) {\n    const option = options[i]\n\n    if (option.active) {\n      activeValues.push(option.value)\n    }\n  }\n\n  handleFilter(activeValues)\n  filterVisible.value = false\n  tableActions.emitRowFilter()\n}\n\nfunction handleResetFilter() {\n  filterVisible.value = false\n  handleFilter(null)\n  mutations.toggleFilterItemActive({\n    key: props.column.key,\n    value: null,\n    disableOthers: true\n  })\n  tableActions.emitRowFilter()\n}\n\nfunction handleCheckAllRow() {\n  mutations.handleCheckAll()\n  tableActions.emitAllRowCheck(state.checkedAll, state.partial)\n}\n\nfunction handleCellResize(entry: ResizeObserverEntry) {\n  mutations.setCellHeight(\n    props.row.key,\n    props.column.key,\n    (entry.borderBoxSize?.[0]?.blockSize ?? entry.contentRect.height) + state.borderWidth\n  )\n}\n</script>\n\n<template>\n  <div\n    v-bind=\"attrs\"\n    ref=\"wrapper\"\n    :class=\"className\"\n    role=\"columnheader\"\n    scope=\"col\"\n    :colspan=\"cellSpan.colSpan !== 1 ? cellSpan.colSpan : undefined\"\n    :rowspan=\"cellSpan.rowSpan !== 1 ? cellSpan.rowSpan : undefined\"\n    :style=\"style\"\n    :aria-sort=\"\n      !isGroup && sorter.able\n        ? sorter.type\n          ? sorter.type === 'asc'\n            ? 'ascending'\n            : 'descending'\n          : 'none'\n        : undefined\n    \"\n    @mouseenter=\"handleMouseEnter\"\n    @mouseleave=\"handleMouseLeave\"\n    @click=\"handleClick\"\n    @dblclick=\"handleDblclick\"\n    @contextmenu=\"handleContextmenu\"\n    @transitionend=\"refreshXScroll\"\n  >\n    <div\n      v-if=\"column.index === 0\"\n      :class=\"nh.be('side-pad')\"\n      role=\"none\"\n      aria-hidden=\"true\"\n    ></div>\n    <div v-if=\"isSelection(column)\" :class=\"nh.be('content')\">\n      <Checkbox\n        inherit\n        control\n        :class=\"nh.be('selection')\"\n        :checked=\"state.checkedAll\"\n        :partial=\"state.partial\"\n        :disabled=\"checkboxDisabled\"\n        :size=\"column.checkboxSize || 'default'\"\n        @click.prevent=\"handleCheckAllRow\"\n      ></Checkbox>\n    </div>\n    <ResizeObserver v-else :disabled=\"column.ellipsis ?? state.ellipsis\" :on-resize=\"handleCellResize\">\n      <span :class=\"nh.be('content')\">\n        <Ellipsis\n          v-if=\"column.ellipsis ?? state.ellipsis\"\n          inherit\n          :class=\"nh.be('ellipsis')\"\n          :tooltip-theme=\"state.tooltipTheme\"\n          :tip-max-width=\"state.tooltipWidth\"\n        >\n          <Renderer\n            v-if=\"isGroup && isFunction((column as any).renderer)\"\n            :renderer=\"(column as any).renderer\"\n          ></Renderer>\n          <Renderer\n            v-else-if=\"isFunction(column.headRenderer)\"\n            :renderer=\"column.headRenderer\"\n            :data=\"{ column, index }\"\n          ></Renderer>\n          <template v-else>\n            {{ column.name }}\n          </template>\n        </Ellipsis>\n        <template v-else>\n          <Renderer\n            v-if=\"isGroup && isFunction((column as any).renderer)\"\n            :renderer=\"(column as any).renderer\"\n          ></Renderer>\n          <Renderer\n            v-else-if=\"isFunction(column.headRenderer)\"\n            :renderer=\"column.headRenderer\"\n            :data=\"{ column, index }\"\n          ></Renderer>\n          <template v-else>\n            {{ column.name }}\n          </template>\n        </template>\n        <template v-if=\"!isGroup\">\n          <div v-if=\"sorter.able\" :class=\"nh.be('sorter')\">\n            <span\n              :class=\"{\n                [nh.bem('sorter', 'asc')]: true,\n                [nh.bem('sorter', 'active')]: sorter.type === 'asc'\n              }\"\n              @click=\"handleSortAsc()\"\n            >\n              <TableIcon name=\"asc\" :origin=\"icons.angleUp\"></TableIcon>\n            </span>\n            <span\n              :class=\"{\n                [nh.bem('sorter', 'desc')]: true,\n                [nh.bem('sorter', 'active')]: sorter.type === 'desc'\n              }\"\n              @click=\"handleSortDesc()\"\n            >\n              <TableIcon name=\"desc\" :origin=\"icons.angleDown\"></TableIcon>\n            </span>\n          </div>\n          <template v-if=\"filter.able\">\n            <Renderer\n              v-if=\"isFunction(column.filterRenderer)\"\n              :renderer=\"column.filterRenderer\"\n              :data=\"{ column, index, filter, handleFilter }\"\n            ></Renderer>\n            <Tooltip\n              v-else\n              v-model:visible=\"filterVisible\"\n              transfer\n              placement=\"bottom\"\n              trigger=\"click\"\n              :class=\"{\n                [nh.be('filter')]: true,\n                [nh.bem('filter', 'visible')]: filterVisible,\n                [nh.bem('filter', 'active')]: filter.active\n              }\"\n              :tip-class=\"{\n                [nh.be('filter-wrapper')]: true,\n                [nh.bs('vars')]: true,\n                [nh.bem('filter-wrapper', 'multiple')]: filter.multiple\n              }\"\n            >\n              <template #trigger>\n                <div :class=\"nh.be('filter-trigger')\">\n                  <TableIcon name=\"filter\" :origin=\"icons.filter\"></TableIcon>\n                </div>\n              </template>\n              <template v-if=\"filter.multiple\" #default>\n                <div vertical :class=\"nh.be('filter-group')\">\n                  <Checkbox\n                    v-for=\"item in filter.options\"\n                    :key=\"item.value\"\n                    inherit\n                    :checked=\"item.active\"\n                    :label=\"item.label\"\n                    :value=\"item.value\"\n                    @change=\"handleFilterCheck(item.value, $event)\"\n                  ></Checkbox>\n                </div>\n                <div :class=\"nh.be('filter-actions')\">\n                  <Button\n                    inherit\n                    text\n                    size=\"small\"\n                    :disabled=\"!hasFilterActive\"\n                    @click=\"handleFilterMultiple()\"\n                  >\n                    {{ locale.filterConfirm }}\n                  </Button>\n                  <Button\n                    inherit\n                    text\n                    size=\"small\"\n                    @click=\"handleResetFilter\"\n                  >\n                    {{ locale.filterReset }}\n                  </Button>\n                </div>\n              </template>\n              <template v-else #default>\n                <div\n                  :class=\"{\n                    [nh.be('filter-item')]: true,\n                    [nh.bem('filter-item', 'active')]: !filter.active\n                  }\"\n                  @click=\"handleResetFilter\"\n                >\n                  {{ locale.filterAll }}\n                </div>\n                <div\n                  v-for=\"item in filter.options\"\n                  :key=\"item.value\"\n                  :class=\"{\n                    [nh.be('filter-item')]: true,\n                    [nh.bem('filter-item', 'active')]: item.active\n                  }\"\n                  @click=\"handleFilterItemSelect(item.value, !item.active)\"\n                >\n                  {{ item.label }}\n                </div>\n              </template>\n            </Tooltip>\n          </template>\n        </template>\n      </span>\n    </ResizeObserver>\n    <div v-if=\"!isGroup && resizable && !typed && !column.last\" ref=\"resizer\" :class=\"nh.be('resizer')\"></div>\n    <div\n      v-if=\"inLast\"\n      :class=\"[nh.be('side-pad'), nh.bem('side-pad', 'right')]\"\n      role=\"none\"\n      aria-hidden=\"true\"\n    ></div>\n  </div>\n</template>\n"
    },
    {
      "target": "components/table/table-head.vue",
      "content": "<script setup lang=\"ts\">\nimport { computed, inject } from 'vue'\n\nimport { getLast } from '@pocui/utils'\nimport { useNameHelper } from '@pocui/config'\nimport { TABLE_HEAD_PREFIX, TABLE_STORE } from './symbol'\n\nimport TableHeadCell from './table-head-cell.vue'\nimport TableRow from './table-row.vue'\n\nimport type { PropType } from 'vue'\n\ndefineOptions({ name: 'TableHead',\n  description:'表格头部组件，用于渲染表格的头部列标题。',\n  categories: ['display'] })\n\nconst props = defineProps({\n  fixed: {\n    type: String as PropType<'left' | 'right' | undefined>,\n    default: null\n  }\n})\n\nconst { state, getters, mutations } = inject(TABLE_STORE)!\n\nconst nh = useNameHelper('table')\nconst allColumns = computed(() => {\n  const left = state.leftFixedColumns.length\n  const right = state.allColumns[0].length - state.rightFixedColumns.length\n\n  if (props.fixed === 'left') {\n    return state.allColumns.map(columns => columns.slice(0, left))\n  } else if (props.fixed === 'right') {\n    return state.allColumns.map(columns => columns.slice(right, state.allColumns[0].length))\n  }\n\n  return state.allColumns.map(columns => columns.slice(left, right))\n})\nconst columns = computed(() => {\n  return props.fixed === 'left'\n    ? state.leftFixedColumns\n    : props.fixed === 'right'\n      ? state.rightFixedColumns\n      : state.normalColumns\n})\nconst style = computed(() => {\n  const width =\n    props.fixed === 'left'\n      ? getLast(getters.leftFixedWidths)\n      : props.fixed === 'right'\n        ? getLast(getters.rightFixedWidths)\n        : getLast(getters.normalWidths)\n  const padLeft = columns.value[0]?.fixed === 'left' ? state.sidePadding[0] || 0 : 0\n  const padRight = getLast(columns.value)?.fixed === 'right' ? state.sidePadding[1] || 0 : 0\n\n  return {\n    minWidth: width && `${width + padLeft + padRight}px`\n  }\n})\n\nfunction getRow(index: number) {\n  const key = `${TABLE_HEAD_PREFIX}${index}`\n\n  return state.rowMap.get(key) || mutations.createMinRowState(key)\n}\n</script>\n\n<template>\n  <div :class=\"nh.be('head')\" role=\"rowgroup\" :style=\"style\">\n    <TableRow\n      v-for=\"(rowColumns, rowIndex) in allColumns\"\n      :key=\"rowIndex\"\n      :index=\"rowIndex\"\n      is-head\n      :fixed=\"fixed\"\n      :row=\"getRow(rowIndex)\"\n      :aria-rowindex=\"rowIndex\"\n    >\n      <template v-for=\"(column, index) in rowColumns as any\" :key=\"index\">\n        <TableHeadCell\n          v-if=\"column\"\n          :column=\"column\"\n          :index=\"index\"\n          :row=\"getRow(rowIndex)\"\n          :row-index=\"rowIndex\"\n          :fixed=\"fixed\"\n          :aria-colindex=\"index\"\n        ></TableHeadCell>\n      </template>\n    </TableRow>\n  </div>\n</template>\n"
    },
    {
      "target": "components/table/table-icon.vue",
      "content": "<script setup lang=\"ts\">\nimport { Icon } from '@/components/icon'\nimport { Renderer } from '@/components/renderer'\n\nimport { computed, inject } from 'vue'\n\nimport { isFunction } from '@pocui/utils'\n\nimport { TABLE_ACTIONS, TABLE_SLOTS } from './symbol'\n\nimport type { PropType } from 'vue'\nimport type { TableIconName } from './symbol'\n\ndefineOptions({ name: 'TableIcon',\n  description:'表格图标组件，用于在表格中显示各种功能图标。',\n  categories: ['display'] })\n\nconst props = defineProps({\n  name: {\n    type: String as PropType<TableIconName>,\n    required: true\n  },\n  origin: {\n    type: Object,\n    default: null\n  }\n})\n\nconst tableActions = inject(TABLE_ACTIONS)!\nconst tableSlots = inject(TABLE_SLOTS)!\n\nconst customIcon = computed(() => tableActions.getIcon(props.name))\n</script>\n\n<template>\n  <Renderer\n    v-if=\"isFunction(tableSlots[`icon-${name}`])\"\n    :renderer=\"tableActions.renderTableSlot\"\n    :data=\"{ name: `icon-${name}` }\"\n  ></Renderer>\n  <Icon v-else-if=\"tableActions.hasIcon(name)\" :icon=\"customIcon\"></Icon>\n  <Icon v-else v-bind=\"origin\"></Icon>\n</template>\n"
    },
    {
      "target": "components/table/table-row.vue",
      "content": "<script setup lang=\"ts\">\nimport { CollapseTransition } from '@/components/collapse-transition'\nimport { Renderer } from '@/components/renderer'\nimport { ResizeObserver } from '@/components/resize-observer'\n\nimport { computed, inject, nextTick, onMounted, reactive, ref, toRef, watchEffect } from 'vue'\n\nimport { useNameHelper } from '@pocui/config'\nimport { useSetTimeout } from '@pocui/hooks'\nimport { isFunction } from '@pocui/utils'\n\nimport { TABLE_ACTIONS, TABLE_STORE } from './symbol'\n\nimport type { PropType } from 'vue'\n\nimport type { TableRowState } from './symbol'\n\ndefineOptions({ name: 'TableRow',\n  description:'表格行组件，用于渲染表格中的单行数据。',\n  categories: ['display'] })\n\nconst props = defineProps({\n  row: {\n    type: Object as PropType<TableRowState>,\n    default: () => ({})\n  },\n  index: {\n    type: Number,\n    default: null\n  },\n  isHead: {\n    type: Boolean,\n    default: false\n  },\n  isFoot: {\n    type: Boolean,\n    default: false\n  },\n  fixed: {\n    type: String as PropType<'left' | 'right' | undefined>,\n    default: null\n  }\n})\n\nconst { state, getters, mutations } = inject(TABLE_STORE)!\nconst tableAction = inject(TABLE_ACTIONS)!\n\nconst nh = useNameHelper('table')\n\nconst { timer } = useSetTimeout()\nconst dragging = ref(false)\nconst isDragOver = ref(false)\n\nconst wrapper = ref<HTMLElement>()\nconst rowEl = ref<HTMLElement>()\nconst expandEl = ref<HTMLElement>()\n\nconst instance = reactive({\n  el: wrapper,\n  row: toRef(props, 'row')\n})\n\nconst rowKey = computed(() => props.row.key)\nconst rowType = computed(() => (props.isHead ? 'head' : props.isFoot ? 'foot' : undefined))\nconst className = computed(() => {\n  let customClass: any\n\n  if (!rowType.value) {\n    if (typeof state.rowClass === 'function') {\n      customClass = state.rowClass(props.row.data, props.index)\n    } else {\n      customClass = state.rowClass\n    }\n  }\n\n  return [\n    nh.be('row'),\n    {\n      [nh.bem('row', 'fixed')]: state.rowHeight && state.rowHeight > 0,\n      [nh.bem('row', 'hover')]: !rowType.value && state.highlight && props.row.hover,\n      [nh.bem('row', 'stripe')]: state.stripe && props.index % 2 === 1,\n      [nh.bem('row', 'checked')]: props.row.checked,\n      [nh.bem('row', 'dragging')]: dragging.value,\n      [nh.bem('row', 'drag-over')]: isDragOver.value\n    },\n    customClass\n  ]\n})\nconst maxHeight = computed(() => Math.max(...Object.values(props.row.cellHeights || {}), state.rowMinHeight))\nconst style = computed(() => {\n  let customStyle: any = ''\n\n  if (!rowType.value) {\n    if (typeof state.rowStyle === 'function') {\n      customStyle = state.rowStyle(props.row.data, props.index)\n    } else {\n      customStyle = state.rowStyle\n    }\n  }\n\n  return [\n    customStyle,\n    {\n      height: !state.rowHeight ? `${maxHeight.value}px` : `${state.rowHeight}px`,\n      minHeight: state.rowHeight ? undefined : `${state.rowMinHeight}px`,\n      border: '0'\n    }\n  ]\n})\nconst attrs = computed(() => {\n  if (!rowType.value) {\n    if (typeof state.rowAttrs === 'function') {\n      return state.rowAttrs(props.row.data, props.index)\n    } else {\n      return state.rowAttrs\n    }\n  }\n\n  return null\n})\nconst groupStyle = computed(() => {\n  if (props.isHead || props.isFoot) return undefined\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n  state.heightTrigger\n\n  const offset = state.heightBITree && !rowType.value && props.index ? state.heightBITree.sum(props.index) : 0\n\n  return {\n    transform: offset ? `translate3d(0, ${offset}px, 0)` : undefined\n  }\n})\nconst cellDraggable = computed(() => {\n  return getters.hasDragColumn && !getters.disableDragRows.has(rowKey.value)\n})\nconst rowDraggable = computed(() => !rowType.value && state.rowDraggable)\nconst draggable = computed(() => !rowType.value && (state.rowDraggable || cellDraggable.value))\nconst expandRenderer = computed(() => state.expandRenderer)\nconst hasExpand = computed(() => {\n  if (props.isHead || props.isFoot || !getters.expandColumn) return false\n  if (state.rightFixedColumns.length) return props.fixed === 'right'\n  if (state.leftFixedColumns.length) return props.fixed === 'left'\n\n  return !!state.normalColumns.length && !props.fixed\n})\n\nfunction setExpandHeight() {\n  let targetHeight: number\n\n  if (props.row.expanded && expandEl.value) {\n    targetHeight = expandEl.value.scrollHeight\n  } else {\n    targetHeight = 0\n  }\n\n  if (targetHeight !== props.row.expandHeight) {\n    mutations.setRowProp(rowKey.value, 'expandHeight', targetHeight)\n    updateTotalHeight(true)\n  }\n}\n\nfunction updateTotalHeight(force = false) {\n  if (state.heightBITree && getters.visibleKeys.has(rowKey.value) && (force || !props.fixed)) {\n    const height = props.row.height + props.row.expandHeight\n    const tree = state.heightBITree\n    const prev = tree.get(props.index)\n\n    if (height !== prev) {\n      tree.add(props.index, height - prev)\n      mutations.updateTotalHeight()\n      mutations.triggerHeightChange()\n    }\n  }\n}\n\nfunction handleResize(entry: ResizeObserverEntry) {\n  const height = entry.borderBoxSize?.[0]?.blockSize ?? entry.contentRect.height\n  mutations.setRowProp(rowKey.value, 'height', height)\n  !rowType.value && updateTotalHeight()\n}\n\nwatchEffect(() => {\n  if (props.isHead || props.isFoot) return\n\n  mutations.setRowProp(rowKey.value, 'height', state.rowHeight || maxHeight.value)\n  !rowType.value && updateTotalHeight()\n  nextTick(() => {\n    hasExpand.value && setExpandHeight()\n  })\n})\n\nonMounted(() => {\n  nextTick(() => {\n    mutations.setRowProp(rowKey.value, 'height', state.rowHeight || maxHeight.value)\n    nextTick(() => {\n      hasExpand.value && setExpandHeight()\n    })\n  })\n})\n\nfunction buildEventPayload(event: Event) {\n  return {\n    row: props.row.data,\n    key: props.row.key,\n    index: props.index,\n    event\n  }\n}\n\nfunction handleMouseEnter(event: MouseEvent) {\n  mutations.setRowProp(rowKey.value, 'hover', true)\n\n  if (!rowType.value && tableAction) {\n    tableAction.emitRowEvent('Enter', buildEventPayload(event))\n  }\n}\n\nfunction handleMouseLeave(event: MouseEvent) {\n  mutations.setRowProp(rowKey.value, 'hover', false)\n\n  if (!rowType.value && tableAction) {\n    tableAction.emitRowEvent('Leave', buildEventPayload(event))\n  }\n}\n\nfunction handleClick(event: MouseEvent) {\n  if (!rowType.value && tableAction) {\n    tableAction.emitRowEvent('Click', buildEventPayload(event))\n  }\n}\n\nfunction handleDblclick(event: MouseEvent) {\n  if (!rowType.value && tableAction) {\n    tableAction.emitRowEvent('Dblclick', buildEventPayload(event))\n  }\n}\n\nfunction handleContextmenu(event: MouseEvent) {\n  if (!rowType.value && tableAction) {\n    tableAction.emitRowEvent('Contextmenu', buildEventPayload(event))\n  }\n}\n\nfunction shouldProcessDrag() {\n  return draggable.value && state.dragging\n}\n\nfunction handleDragStart(event: DragEvent) {\n  if (!draggable.value && !cellDraggable.value) return\n\n  dragging.value = true\n  tableAction.handleRowDragStart(instance, event)\n}\n\nfunction handleDragOver(event: DragEvent) {\n  if (!shouldProcessDrag() || (cellDraggable.value && !getters.rowDragging)) return\n\n  clearTimeout(timer.drag)\n  event.stopPropagation()\n  event.preventDefault()\n\n  isDragOver.value = true\n\n  tableAction.handleRowDragOver(instance, event)\n}\n\nfunction handleDrop(event: DragEvent) {\n  if (!shouldProcessDrag()) return\n\n  clearTimeout(timer.drag)\n  event.stopPropagation()\n  event.preventDefault()\n\n  isDragOver.value = false\n\n  tableAction.handleRowDrop(instance, event)\n  nextTick(() => mutations.handleDrag(rowKey.value, false))\n}\n\nfunction handleDragEnd(event: DragEvent) {\n  if (!shouldProcessDrag()) return\n\n  event.stopPropagation()\n  dragging.value = true\n\n  tableAction.handleRowDragEnd(event)\n  nextTick(() => mutations.handleDrag(rowKey.value, false))\n}\n\nfunction handleDragLeave(event: DragEvent) {\n  if (!shouldProcessDrag()) return\n\n  clearTimeout(timer.drag)\n  event.preventDefault()\n\n  timer.drag = setTimeout(() => {\n    isDragOver.value = false\n  }, 100)\n}\n\nfunction afterExpand() {\n  mutations.setRowProp(rowKey.value, 'expandAnimate', false)\n}\n</script>\n\n<template>\n  <div\n    v-if=\"!row.hidden\"\n    ref=\"wrapper\"\n    :class=\"{\n      [nh.be('group')]: true,\n      [nh.bem('group', 'checked')]: row.checked,\n      [nh.bem('group', 'last')]: row.last\n    }\"\n    role=\"row\"\n    :draggable=\"rowDraggable || row.dragging\"\n    :style=\"groupStyle\"\n    @mouseenter=\"handleMouseEnter\"\n    @mouseleave=\"handleMouseLeave\"\n    @click=\"handleClick\"\n    @dblclick=\"handleDblclick\"\n    @contextmenu=\"handleContextmenu\"\n    @dragstart.stop=\"handleDragStart\"\n    @dragover=\"handleDragOver\"\n    @drop=\"handleDrop\"\n    @dragend=\"handleDragEnd\"\n    @dragleave=\"handleDragLeave\"\n  >\n    <ResizeObserver :on-resize=\"handleResize\">\n      <div\n        v-bind=\"attrs\"\n        ref=\"rowEl\"\n        :class=\"className\"\n        :style=\"style\"\n      >\n        <slot></slot>\n      </div>\n    </ResizeObserver>\n    <CollapseTransition\n      v-if=\"hasExpand\"\n      :disabled=\"!row.expandAnimate\"\n      @enter=\"setExpandHeight\"\n      @leave=\"setExpandHeight\"\n      @after-enter=\"afterExpand\"\n      @after-leave=\"afterExpand\"\n    >\n      <div\n        v-if=\"row.expanded\"\n        ref=\"expandEl\"\n        :class=\"[nh.be('expanded'), fixed === 'right' && nh.bem('expanded', 'fixed')]\"\n      >\n        <ResizeObserver :disabled=\"row.expandAnimate\" :on-resize=\"setExpandHeight\">\n          <div :class=\"nh.be('expanded-wrapper')\">\n            <Renderer\n              v-if=\"isFunction(getters.expandColumn!.renderer)\"\n              :renderer=\"getters.expandColumn!.renderer\"\n              :data=\"{ leftFixed: 0, rightFixed: 0, row: row.data, rowIndex: index }\"\n            ></Renderer>\n            <Renderer\n              v-else-if=\"isFunction(expandRenderer)\"\n              :renderer=\"expandRenderer\"\n              :data=\"{ leftFixed: 0, rightFixed: 0, row: row.data, rowIndex: index }\"\n            ></Renderer>\n          </div>\n        </ResizeObserver>\n      </div>\n    </CollapseTransition>\n  </div>\n</template>\n"
    },
    {
      "target": "components/table/table-summary.ts",
      "content": "import { SlotsType, defineComponent, inject, onBeforeUnmount, reactive, renderSlot, watch } from 'vue'\n\nimport { useProps } from '@pocui/config'\nimport { isNullish } from '@pocui/utils'\nimport { tableSummaryProps } from './props'\n\nimport { SummaryRenderFn, TABLE_ACTIONS } from './symbol'\n\nimport type { SummaryWithKey } from './symbol'\n\ntype SummaryPropKey = keyof typeof tableSummaryProps\n\nconst propKeys = Object.keys(tableSummaryProps) as SummaryPropKey[]\nconst aliases: Partial<Record<SummaryPropKey, string>> = {\n  idKey: 'key'\n}\nconst ignoredProps: SummaryPropKey[] = ['renderer']\nconst triggerProps: SummaryPropKey[] = ['idKey', 'cellSpan', 'order', 'above']\n\nconst funcProp = {\n  default: null,\n  isFunc: true,\n  static: true\n}\n\nexport default defineComponent({\n  name: 'TableSummary',\n  description:'表格汇总组件，用于定义表格的汇总行数据显示。',\n  categories: ['display'],\n  props: tableSummaryProps,\n  slots: Object as SlotsType<{\n    default: SummaryRenderFn\n  }>,\n  setup(_props, { slots }) {\n    const props = useProps('tableSummary', _props, {\n      idKey: {\n        default: null,\n        validator: value => !isNullish(value),\n        static: true\n      },\n      class: null,\n      style: null,\n      attrs: null,\n      cellSpan: funcProp,\n      order: {\n        default: 0,\n        static: true\n      },\n      above: {\n        default: false,\n        static: true\n      },\n      meta: null,\n      renderer: funcProp\n    })\n\n    const tableAction = inject(TABLE_ACTIONS, null)\n    const options = reactive({}) as SummaryWithKey\n\n    for (const key of propKeys) {\n      if (ignoredProps.includes(key)) continue\n\n      const aliasKey = (aliases[key] || key) as keyof SummaryWithKey\n      const trigger = triggerProps.includes(key)\n\n      ;(options[aliasKey] as any) = props[key]\n\n      watch(\n        () => props[key],\n        value => {\n          ;(options[aliasKey] as any) = value\n          trigger ? tableAction?.updateSummaries() : tableAction?.setSummaryProp(options.key, <string>key, value)\n        }\n      )\n    }\n\n    watch(() => props.renderer, setRenderer)\n\n    setRenderer()\n    tableAction?.increaseSummary(options)\n\n    onBeforeUnmount(() => {\n      tableAction?.decreaseSummary(options)\n    })\n\n    function setRenderer() {\n      options.renderer = data => {\n        if (typeof data.column.summaryRenderer === 'function') {\n          return data.column.summaryRenderer({\n            ...data,\n            summary: options\n          })\n        }\n\n        if (typeof slots.default === 'function') {\n          return renderSlot(slots, 'default', data)\n        }\n\n        if (typeof props.renderer === 'function') {\n          return props.renderer(data)\n        }\n\n        return ''\n      }\n    }\n\n    return () => null\n  }\n})\n"
    },
    {
      "target": "components/table/table-toolbar.vue",
      "content": "<script setup lang=\"ts\">\nimport { Button } from '@/components/button'\nimport { ButtonGroup } from '@/components/button-group'\nimport { CheckboxGroup } from '@/components/checkbox-group'\nimport { Dropdown } from '@/components/dropdown'\nimport { DropdownItem } from '@/components/dropdown-item'\nimport { DropdownList } from '@/components/dropdown-list'\nimport { Input } from '@/components/input'\nimport { Space } from '@/components/space'\nimport { Tooltip } from '@/components/tooltip'\n\nimport { computed, inject, ref, toRef, watch } from 'vue'\n\nimport { localeProp, sizeProp, useIcons, useLocale, useNameHelper } from '@pocui/config'\n\nimport { TABLE_ACTIONS, TABLE_STORE } from './symbol'\n\nimport type { DataShowKey, Key } from './symbol'\nimport type { PropType } from 'vue'\n\ndefineOptions({ name: 'TableToolbar',\n  description:'表格工具栏组件，提供表格的搜索、筛选、操作等功能。',\n  categories: ['display'] })\n\nconst props = defineProps({\n  locale: {\n    type: localeProp('table'),\n    default: null\n  },\n  customSearch: {\n    type: Boolean,\n    default: false\n  },\n  size: {\n    type: sizeProp,\n    default: 'small'\n  },\n  loading: {\n    type: Boolean,\n    default: false\n  },\n  keyValues: {\n    type: Array as PropType<Key[]>,\n    default: () => []\n  },\n  availableColumns: {\n    type: Array as PropType<DataShowKey[]>,\n    default: () => []\n  },\n  defaultHidden: {\n    type: Array as PropType<Key[]>,\n    default: () => []\n  }\n})\nconst emit = defineEmits<{\n  (e: 'update:keyValues', value: Key[]): void,\n  (e: 'fuzzySearch', value: string): void\n}>()\n\nconst locale = useLocale('table', toRef(props, 'locale'))\nconst nh = useNameHelper('table')\nconst { state } = inject(TABLE_STORE)!\nconst { startRefresh } = inject(TABLE_ACTIONS)!\nconst icons = useIcons()\n// 模糊搜索\nconst fuzzySearchValue = ref<string>('')\nconst style = computed(() => {\n  return {\n    height: state.rowHeight ? undefined : `${state.rowMinHeight}px`,\n    minHeight: state.rowHeight ? undefined : `${state.rowMinHeight}px`\n  }\n})\n\nwatch(fuzzySearchValue, value => {\n  emit('fuzzySearch', value)\n})\n\nfunction updateKeyValues(value: Key[]) {\n  emit('update:keyValues', value)\n}\n</script>\n\n<template>\n  <div :class=\"nh.be('toolbar-wrapper')\" :style=\"style\">\n    <Space size=\"small\">\n      <Button\n        circle\n        :size=\"props.size\"\n        :loading=\"props.loading\"\n        type=\"primary\"\n        v-bind=\"icons.refresh\"\n        @click.stop=\"startRefresh\"\n      >\n      </Button>\n      <slot></slot>\n    </Space>\n    <div :class=\"nh.be('toolbar-fixed')\">\n      <Input\n        v-model:value=\"fuzzySearchValue\"\n        :size=\"props.size\"\n        debounce\n        sync\n        :delay=\"1000\"\n        :placeholder=\"locale.fuzzySearch\"\n        style=\"max-width: 300px\"\n      >\n      </Input>\n      <ButtonGroup :size=\"props.size\">\n        <Dropdown transfer>\n          <Button v-bind=\"icons.grid\"></Button>\n          <template #drop>\n            <CheckboxGroup :value=\"keyValues\" keep-one @update:value=\"updateKeyValues\">\n              <DropdownList>\n                <DropdownItem v-for=\"item in props.availableColumns\" :key=\"item.key\" reference>\n                  <PocCheckbox :label=\"item.name\" :value=\"item.key\"></PocCheckbox>\n                </DropdownItem>\n              </DropdownList>\n            </CheckboxGroup>\n          </template>\n        </Dropdown>\n        <Tooltip transfer>\n          <template #trigger>\n            <Button v-bind=\"icons.search\" :disabled=\"!props.customSearch\"></Button>\n          </template>\n          {{ locale.customSearch || '' }}\n        </Tooltip>\n      </ButtonGroup>\n    </div>\n  </div>\n</template>\n"
    },
    {
      "target": "components/table/table.vue",
      "content": "<script setup lang=\"ts\">\nimport { NativeScroll } from '@/components/native-scroll'\n\nimport { Scrollbar } from '@/components/scrollbar'\nimport { Spin } from '@/components/spin'\n\nimport { computed, nextTick, onBeforeUnmount, onMounted, provide, reactive, ref, renderSlot, toRef, watch } from 'vue'\n\nimport { useSetTimeout } from '@pocui/hooks'\nimport {\n  debounce,\n  debounceMinor,\n  getLast,\n  isDefined,\n  isValidNumber,\n  listToMap,\n  nextFrameOnce,\n  noop,\n  removeArrayItem,\n  toNumber\n} from '@pocui/utils'\n\nimport { emitEvent, useLocale, useNameHelper, useProps } from '@pocui/config'\nimport { tableProps } from './props'\nimport { useStore } from './store'\n\nimport { DropType, TABLE_ACTIONS, TABLE_SLOTS, TABLE_STORE } from './symbol'\nimport TableBody from './table-body.vue'\n\nimport TableColumn from './table-column'\nimport TableColumnGroup from './table-column-group'\nimport TableFoot from './table-foot.vue'\nimport TableHead from './table-head.vue'\nimport TableSummary from './table-summary'\nimport TableToolbar from './table-toolbar.vue'\n\nimport type {\n  DataShowKey,\n  Key,\n  MouseEventType,\n  MoveEventType,\n  StoreOptions,\n  TableCellPayload,\n  TableColResizePayload,\n  TableColumnGroupOptions,\n  TableColumnOptions,\n  TableColumnRawOptions,\n  TableFootPayload,\n  TableHeadPayload,\n  TableKeyConfig,\n  TableRowInstance,\n  TableRowPayload,\n  TableRowState,\n  TableSummaryOptions\n} from './symbol'\nimport type { StyleType } from '@pocui/config'\nimport type { ScrollbarExposed } from '@/components/scrollbar'\nimport type { NativeScrollExposed, NativeScrollPayload } from '@/components/native-scroll'\n\nconst defaultKeyConfig: Required<TableKeyConfig> = {\n  id: 'id',\n  children: 'children',\n  checked: 'checked',\n  height: 'height',\n  expanded: 'expanded',\n  treeExpanded: 'treeExpanded'\n}\n\ndefineOptions({ name: 'Table',\n  description:'用于展示结构化二维数据，可以快速实对数据进行排序、搜索、分组、编辑、分页、汇总等操作。',\n  categories: ['display'] })\n\nconst _props = defineProps(tableProps)\nconst props = useProps('table', _props, {\n  locale: null,\n  columns: {\n    default: () => [],\n    static: true\n  },\n  defaultHidden: {\n    default: () => [],\n    static: true\n  },\n  toolbar: false,\n  toolbarSize: {\n    default: 'small',\n    validator: value => ['default', 'small', 'large'].includes(value)\n  },\n  summaries: {\n    default: () => [],\n    static: true\n  },\n  data: {\n    default: () => [],\n    static: true\n  },\n  width: null,\n  height: null,\n  minHeight: null,\n  rowClass: null,\n  rowStyle: null,\n  rowAttrs: null,\n  customSearch: false,\n  stripe: false,\n  border: false,\n  highlight: false,\n  useXBar: false,\n  useYBar: false,\n  barFade: 1500,\n  rowDraggable: false,\n  rowHeight: {\n    default: null,\n    validator: value => value > 0\n  },\n  rowMinHeight: {\n    default: 36,\n    validator: value => value > 0\n  },\n  virtual: false,\n  bufferCount: {\n    default: 5,\n    validator: value => value >= 0\n  },\n  scrollClass: () => ({}),\n  expandRenderer: {\n    default: null,\n    isFunc: true\n  },\n  currentPage: {\n    default: 1,\n    validator: value => value > 0,\n    static: true\n  },\n  pageSize: 0,\n  transparent: false,\n  tooltipTheme: {\n    default: 'dark',\n    validator: value => ['light', 'dark'].includes(value)\n  },\n  tooltipWidth: 500,\n  singleSorter: false,\n  singleFilter: false,\n  cellClass: null,\n  cellStyle: null,\n  cellAttrs: null,\n  headClass: null,\n  headStyle: null,\n  headAttrs: null,\n  footClass: null,\n  footStyle: null,\n  footAttrs: null,\n  customSorter: false,\n  customFilter: false,\n  keyConfig: () => ({}),\n  disabledTree: false,\n  rowIndent: '16px',\n  noCascaded: false,\n  colResizable: false,\n  cellSpan: {\n    default: null,\n    isFunc: true\n  },\n  sidePadding: 0,\n  icons: () => ({}),\n  borderWidth: 1,\n  dataFilter: {\n    default: null,\n    isFunc: true\n  },\n  noTransition: false,\n  ellipsis: false\n})\n\n// 仅适用于有效载荷\nconst emit = defineEmits(['update:data', 'fuzzySearch', 'refresh'])\n\nconst slots = defineSlots<{\n  default(): any,\n  empty(props: { isFixed: boolean }): any,\n  toolbar(): any\n}>()\n\nconst nh = useNameHelper('table')\nconst { timer } = useSetTimeout()\n\nconst bodyHeight = ref<number | undefined>(props.height)\nconst bodyMinHeight = ref(props.height || 0)\nconst xScrollEnabled = ref(false)\nconst yScrollEnabled = ref(false)\nconst xScrollPercent = ref(0)\nconst yScrollPercent = ref(0)\nconst headHeight = ref(0)\nconst footHeight = ref(0)\nconst indicatorShow = ref(false)\nconst indicatorType = ref(DropType.BEFORE)\nconst tempColumns = reactive(new Set<TableColumnGroupOptions | TableColumnOptions>())\nconst tempSummaries = reactive(new Set<TableSummaryOptions>())\nconst tableWidth = ref<number | string>()\nconst hasDragColumn = ref(false)\nconst bodyWidth = ref(0)\nconst localLoading = ref(false)\n\nconst wrapper = ref<HTMLElement>()\nconst mainScroll = ref<NativeScrollExposed>()\nconst xHeadScroll = ref<NativeScrollExposed>()\nconst xAboveScroll = ref<NativeScrollExposed>()\nconst xBelowScroll = ref<NativeScrollExposed>()\nconst thead = ref<HTMLElement>()\nconst aboveTfoot = ref<HTMLElement>()\nconst belowTfoot = ref<HTMLElement>()\nconst indicator = ref<HTMLElement>()\nconst xScrollbar = ref<ScrollbarExposed>()\nconst yScrollbar = ref<ScrollbarExposed>()\nconst keyValues = ref<Key[]>([])\n\nlet isMounted = false\n\nconst locale = useLocale('table', toRef(props, 'locale'))\nconst keyConfig = computed(() => ({ ...defaultKeyConfig, ...props.keyConfig }))\nconst allColumns = computed(() => Array.from(tempColumns))\nconst allSummaries = computed(() => Array.from(tempSummaries))\n\nconst syncToStoreProps = [\n  'rowClass',\n  'rowStyle',\n  'rowAttrs',\n  'cellClass',\n  'cellStyle',\n  'cellAttrs',\n  'headClass',\n  'headStyle',\n  'headAttrs',\n  'footClass',\n  'footStyle',\n  'footAttrs',\n  'border',\n  'stripe',\n  'highlight',\n  'currentPage',\n  'pageSize',\n  'rowHeight',\n  'rowMinHeight',\n  'rowDraggable',\n  'tooltipTheme',\n  'tooltipWidth',\n  'singleSorter',\n  'singleFilter',\n  'customSorter',\n  'customFilter',\n  'noCascaded',\n  'colResizable',\n  'expandRenderer',\n  'cellSpan',\n  'sidePadding',\n  'borderWidth',\n  'dataFilter',\n  'ellipsis'\n] as const\n\nconst store = useStore({\n  ...(syncToStoreProps.reduce((prev, current) => ((prev[current] = props[current]), prev), {} as any) as StoreOptions),\n  columns: allColumns.value,\n  summaries: allSummaries.value,\n  data: props.data,\n  dataKey: keyConfig.value.id,\n  virtual: props.virtual,\n  locale: locale.value,\n  keyConfig: keyConfig.value,\n  disabledTree: props.disabledTree,\n  colResizable: props.colResizable === true ? 'lazy' : props.colResizable,\n  sidePadding: Array.isArray(props.sidePadding) ? props.sidePadding : [props.sidePadding, props.sidePadding]\n})\nprovide(TABLE_STORE, store)\nprovide(TABLE_ACTIONS, {\n  increaseColumn,\n  decreaseColumn,\n  increaseSummary,\n  decreaseSummary,\n  getTableElement,\n  refreshXScroll,\n  emitRowCheck,\n  emitAllRowCheck,\n  emitRowExpand,\n  emitRowTreeExpand,\n  emitRowFilter,\n  emitRowSort,\n  handleRowDragStart,\n  handleRowDragOver,\n  handleRowDrop,\n  handleRowDragEnd,\n  emitRowEvent,\n  emitCellEvent,\n  emitHeadEvent,\n  emitColResize,\n  emitFootEvent,\n  hasIcon: name => !!props.icons[name],\n  getIcon: name => props.icons[name],\n  renderTableSlot,\n  runInLocked,\n  updateColumns: () => debounceMinor(updateColumns),\n  setColumnProp,\n  updateSummaries: () => debounceMinor(updateSummaries),\n  setSummaryProp,\n  startRefresh\n})\nprovide(TABLE_SLOTS, slots)\n\nconst { state, getters, mutations } = store\n\nconst mergedLocked = computed(() => props.noTransition || state.locked || state.barScrolling)\nconst className = computed(() => {\n  return {\n    [nh.b()]: true,\n    [nh.bs('vars')]: true,\n    [nh.in()]: props.inherit,\n    [nh.bm('stripe')]: props.stripe,\n    [nh.bm('border')]: props.border,\n    [nh.bm('highlight')]: props.highlight,\n    [nh.bm('use-y-bar')]: props.useYBar,\n    [nh.bm('transparent')]: props.transparent,\n    [nh.bm('virtual')]: props.virtual,\n    [nh.bm('col-resizable')]: props.colResizable,\n    [nh.bm('col-resizing')]: state.colResizing,\n    [nh.bm('locked')]: mergedLocked.value,\n    [nh.bm('above-foot')]: state.aboveSummaries.length,\n    [nh.bm('below-foot')]: state.belowSummaries.length,\n    [nh.bm('using-bar')]: state.barScrolling\n  }\n})\nconst style = computed(() => {\n  const width = tableWidth.value ?? props.width\n  const [padLeft, padRight] = state.sidePadding\n\n  const style: StyleType = {\n    [nh.cv('row-indent-width')]: typeof props.rowIndent === 'number' ? `${props.rowIndent}px` : props.rowIndent,\n    [nh.cv('b-width')]: `${props.borderWidth}px`,\n    [nh.cv('expanded-width')]: `${bodyWidth.value}px`\n  }\n\n  if (padLeft) {\n    style[nh.cv('side-pad-left')] = `${padLeft}px`\n  }\n\n  if (padRight) {\n    style[nh.cv('side-pad-right')] = `${padRight}px`\n  }\n\n  if (isDefined(width)) {\n    if (typeof width === 'number' || isValidNumber(width, true)) {\n      style.width = `${width}px`\n      style.minWidth = `${width}px`\n    } else {\n      style.width = width\n    }\n  }\n\n  return style\n})\nconst useXScroll = computed(() => {\n  return !!(isDefined(props.width) || state.leftFixedColumns.length || state.rightFixedColumns.length)\n})\nconst bodyScrollHeight = computed(() => {\n  const { totalHeight } = state\n\n  return bodyHeight.value ? Math.min(bodyHeight.value, totalHeight) : undefined\n})\nconst xBarLength = computed(() => mainScroll.value?.xBarLength || 35)\nconst yBarLength = computed(() => {\n  const { totalHeight } = state\n\n  if (bodyScrollHeight.value && totalHeight) {\n    return Math.max(Math.min((bodyScrollHeight.value / totalHeight) * 100, 99), 5) || 35\n  }\n\n  return 35\n})\nconst totalWidths = computed(() => {\n  return (getLast(getters.totalWidths) || 0) + (state.sidePadding[0] || 0) + (state.sidePadding[1] || 0)\n})\nconst leftFixedActive = computed(() => xScrollEnabled.value && xScrollPercent.value > 0)\nconst rightFixedActive = computed(() => xScrollEnabled.value && xScrollPercent.value < 100)\n\n// 可用列\nconst availableColumns = computed(() => {\n  return extractKeys(props.columns)\n})\n\nconst showColumns = computed(() => {\n  return props.columns.filter(item =>\n    'children' in item\n      ? item.children.filter(item => keyValues.value.some(value => value === item.key))\n      : keyValues.value.some(value => value === item.key)\n  )\n})\n\nconst {\n  setColumns,\n  setSummaries,\n  setData,\n  setDataKey,\n  setTableWidth,\n  setBodyYScroll,\n  setBodyXScroll,\n  setRenderRows,\n  setVirtual,\n  setLocale,\n  setDragging,\n  setKeyConfig,\n  setDisabledTree,\n  setLocked,\n  setBarScrolling,\n  clearSort,\n  clearFilter,\n  refreshRowIndex,\n  clearCheckAll,\n  getParentRow,\n  getCurrentData,\n  flatTreeRows,\n  refreshRowDepth,\n  queryRow,\n  handleCheck,\n  setTreeExpanded\n} = mutations\n\nwatch(allColumns, updateColumns)\nwatch(allSummaries, updateSummaries)\nwatch(() => keyConfig.value.id, setDataKey)\nwatch(() => props.data, forceRefreshData, { deep: true })\nwatch(() => props.width, computeTableWidth)\nwatch([() => props.height, () => props.borderWidth], () => {\n  nextTick(computeBodyHeight)\n})\nwatch(locale, setLocale, { deep: true })\nwatch(\n  () => props.virtual,\n  value => {\n    setVirtual(value)\n    setData(props.data)\n    refreshPercentScroll()\n  }\n)\nwatch(\n  keyConfig,\n  config => {\n    setKeyConfig(config)\n    setData(props.data)\n  },\n  { deep: true }\n)\nwatch(\n  () => props.disabledTree,\n  value => {\n    setDisabledTree(value)\n    setData(props.data)\n  }\n)\nwatch([() => props.rowHeight, () => props.rowMinHeight], () => {\n  refresh()\n})\n\nfor (const prop of syncToStoreProps) {\n  const watchCallback =\n    mutations[`set${prop.charAt(0).toLocaleUpperCase()}${prop.slice(1)}` as `set${Capitalize<typeof prop>}`]\n\n  watch(() => props[prop], watchCallback as any)\n}\n\nfunction extractKeys(items: TableColumnRawOptions[]) {\n  let keys: DataShowKey[] = []\n\n  items.forEach(item => {\n    if ('children' in item) {\n      keys = keys.concat(extractKeys(item.children))\n    } else {\n      item.key\n        ? keys.push({\n          key: item.key,\n          name: item.name\n        })\n        : keys.push({\n          key: Symbol(item.name),\n          name: item.name\n        })\n    }\n  })\n\n  return keys\n}\n\nfunction syncBarScroll() {\n  xScrollbar.value?.handleScroll(xScrollPercent.value)\n  yScrollbar.value?.handleScroll(yScrollPercent.value)\n}\n\nconst handlerResize = debounce(refresh)\n\nonMounted(() => {\n  isMounted = true\n\n  watch(bodyScrollHeight, refreshPercentScroll)\n  refresh()\n  window.addEventListener('resize', handlerResize)\n  nextTick(() => {\n    hasDragColumn.value = getters.hasDragColumn\n  })\n\n  if (mainScroll.value) {\n    xScrollEnabled.value = mainScroll.value.enableXScroll\n    yScrollEnabled.value = mainScroll.value.enableYScroll\n  }\n})\n\nonBeforeUnmount(() => {\n  isMounted = false\n\n  window.removeEventListener('resize', handlerResize)\n})\n\ndefineExpose({\n  bodyHeight,\n  xScrollEnabled,\n  yScrollEnabled,\n  xScrollPercent,\n  yScrollPercent,\n  headHeight,\n  footHeight,\n  indicatorShow,\n  bodyScrollHeight,\n  totalWidths,\n  totalHeight: computed(() => state.totalHeight),\n  locked: mergedLocked,\n\n  store,\n\n  wrapper,\n  mainScroll,\n  xHeadScroll,\n  xAboveScroll,\n  xBelowScroll,\n  thead,\n  aboveTfoot,\n  belowTfoot,\n  indicator,\n  xScrollbar,\n  yScrollbar,\n\n  clearSort,\n  clearFilter,\n  clearSelected: clearCheckAll,\n  refresh,\n  refreshData: forceRefreshData,\n  getSelected,\n  getData: getCurrentData,\n  selectRow: setRowChecked,\n  treeExpandRow: setRowTreeExpanded,\n  startLoading,\n  stopLoading\n})\n\nfunction forceRefreshData(data = props.data) {\n  return runInLocked(() => {\n    setData(data)\n    nextTick(() => computeRenderRows(true))\n    refreshPercentScroll()\n  })\n}\n\nfunction computeTableWidth() {\n  const width = props.width\n\n  if (isDefined(width)) {\n    if (typeof width === 'string' && parseFloat(width).toString() !== width) {\n      tableWidth.value = width\n    } else {\n      tableWidth.value = `${toNumber(width)}px`\n    }\n  }\n\n  nextTick(() => {\n    mainScroll.value?.content && setTableWidth(mainScroll.value.content.offsetWidth)\n    refreshXScroll()\n  })\n}\n\nfunction computeBodyHeight() {\n  const height = props.height\n  const minHeight = props.minHeight\n  const borderWidth = props.borderWidth\n\n  let fixedHeight = 0\n\n  if (thead.value || aboveTfoot.value || belowTfoot.value) {\n    if (thead.value) {\n      fixedHeight = thead.value.offsetHeight\n    }\n\n    if (aboveTfoot.value) {\n      fixedHeight += aboveTfoot.value.offsetHeight\n    }\n\n    if (belowTfoot.value) {\n      fixedHeight = belowTfoot.value.offsetHeight\n    }\n  } else {\n    // 一行作为头占位符\n    fixedHeight = props.rowHeight || props.rowMinHeight\n  }\n\n  fixedHeight += 2 * borderWidth\n\n  if (isDefined(height)) {\n    bodyHeight.value = height - fixedHeight\n  } else {\n    bodyHeight.value = undefined\n  }\n\n  if (isDefined(minHeight)) {\n    bodyMinHeight.value = Math.min(minHeight, height ?? Infinity) - fixedHeight\n  } else {\n    bodyMinHeight.value = 0\n  }\n}\n\nfunction handleMainScroll(payload: NativeScrollPayload) {\n  if (state.barScrolling) return\n\n  if (payload.type !== 'vertical') {\n    handleXScroll(payload)\n  }\n\n  if (payload.type !== 'horizontal') {\n    handleYScroll(payload)\n  }\n}\n\nfunction handleXScroll({ clientX, percentX }: { clientX: number, percentX: number }) {\n  if (state.barScrolling) return\n\n  xScrollPercent.value = percentX\n  setBodyXScroll(clientX)\n  syncBarScroll()\n  emitEvent(props.onScroll, {\n    type: 'horizontal',\n    client: clientX,\n    percent: percentX\n  })\n}\n\nfunction handleYScroll({ clientY, percentY }: { clientY: number, percentY: number }) {\n  if (state.barScrolling) return\n\n  yScrollPercent.value = percentY\n  setBodyYScroll(clientY)\n  syncBarScroll()\n  emitYScroll(clientY, percentY)\n}\n\nfunction handleXBarScroll(percent: number) {\n  if (!mainScroll.value) return\n\n  const client = (mainScroll.value.xScrollLimit * percent) / 100\n\n  xScrollPercent.value = percent\n  setBodyXScroll(client)\n  emitEvent(props.onScroll, {\n    type: 'horizontal',\n    client,\n    percent\n  })\n}\n\nfunction handleYBarScroll(percent: number) {\n  const { totalHeight } = state\n  const client = (percent * (totalHeight - (bodyScrollHeight.value ?? 0))) / 100\n\n  yScrollPercent.value = percent\n  setBodyYScroll(client)\n  emitYScroll(client, percent)\n}\n\nfunction emitYScroll(client: number, percent: number) {\n  runInLocked()\n  nextFrameOnce(computeRenderRows)\n  emitEvent(props.onScroll, {\n    type: 'vertical',\n    client,\n    percent\n  })\n}\n\nfunction handleResize() {\n  if (mainScroll.value?.content) {\n    bodyWidth.value = mainScroll.value.content.offsetWidth\n  }\n\n  isMounted && refresh()\n}\n\nfunction increaseColumn(column: TableColumnOptions) {\n  tempColumns.add(column)\n}\n\nfunction decreaseColumn(column: TableColumnOptions) {\n  tempColumns.delete(column)\n}\n\nfunction increaseSummary(summary: TableSummaryOptions) {\n  tempSummaries.add(summary)\n}\n\nfunction decreaseSummary(summary: TableSummaryOptions) {\n  tempSummaries.delete(summary)\n}\n\nfunction updateColumns() {\n  runInLocked(() => {\n    setColumns(allColumns.value)\n    isMounted && computeTableWidth()\n    nextTick(() => {\n      hasDragColumn.value = getters.hasDragColumn\n    })\n  })\n}\n\nfunction setColumnProp(key: Key, prop: string, value: any) {\n  mutations.setColumnProp(key, prop, value)\n}\n\nfunction updateSummaries() {\n  runInLocked(() => {\n    setSummaries(allSummaries.value)\n  })\n}\n\nfunction setSummaryProp(key: Key, prop: string, value: any) {\n  mutations.setSummaryProp(key, prop, value)\n}\n\nfunction getTableElement() {\n  return wrapper.value\n}\n\nfunction startLoading() {\n  localLoading.value = true\n}\n\nfunction startRefresh() {\n  emit('refresh')\n}\n\nfunction stopLoading() {\n  localLoading.value = false\n}\n\nfunction refreshXScroll() {\n  mainScroll.value?.refresh()\n  xHeadScroll.value?.refresh()\n  xAboveScroll.value?.refresh()\n  xBelowScroll.value?.refresh()\n}\n\nfunction emitRowCheck(payload: TableRowPayload & { checked: boolean }) {\n  emitEvent(props.onRowCheck, payload)\n}\n\nfunction emitAllRowCheck(checked: boolean, partial: boolean) {\n  emitEvent(props.onRowCheckAll, checked, partial)\n}\n\nfunction emitRowExpand(payload: TableRowPayload & { expanded: boolean }) {\n  emitEvent(props.onRowExpand, payload)\n}\n\nfunction emitRowTreeExpand(payload: TableRowPayload & { expanded: boolean }) {\n  emitEvent(props.onRowTreeExpand, payload)\n}\n\nfunction emitRowFilter() {\n  const { columns, filters } = state\n  const columnMap = listToMap(columns, 'key')\n  const profiles = Array.from(filters.keys())\n    .filter(key => filters.get(key)!.active)\n    .map(key => {\n      const column = columnMap[key as string]\n\n      return {\n        name: column.name,\n        key: column.key,\n        meta: column.meta!,\n        active: filters.get(key)!.active!\n      }\n    })\n\n  computeRenderRows(true)\n  emitEvent(\n    props.onRowFilter,\n    profiles,\n    getters.filteredData.map(row => row.data)\n  )\n}\n\nfunction emitRowSort() {\n  const { columns, sorters } = state\n  const columnMap = listToMap(columns, 'key')\n  const profiles = Array.from(sorters.keys())\n    .filter(key => sorters.get(key)!.type)\n    .map(key => {\n      const column = columnMap[key as string]\n      const sorter = sorters.get(key)!\n\n      return {\n        name: column.name,\n        key: column.key,\n        meta: column.meta!,\n        type: sorter.type!,\n        order: sorter.order\n      }\n    })\n\n  computeRenderRows(true)\n  emitEvent(\n    props.onRowSort,\n    profiles,\n    getters.sortedData.map(row => row.data)\n  )\n}\n\nlet dragState: {\n  draggingRow: TableRowState,\n  tableRect: DOMRect,\n  willDropRow: TableRowState | null,\n  dropType: DropType,\n  dropped: boolean\n} | null\n\nfunction handleRowDragStart(rowInstance: TableRowInstance, event: DragEvent) {\n  dragState = {\n    draggingRow: rowInstance.row,\n    tableRect: wrapper.value!.getBoundingClientRect(),\n    willDropRow: null,\n    dropType: DropType.BEFORE,\n    dropped: false\n  }\n\n  setDragging(true)\n  emitEvent(props.onRowDragStart, rowInstance.row.data, event)\n}\n\nfunction handleRowDragOver(rowInstance: TableRowInstance, event: DragEvent) {\n  if (!dragState || !rowInstance.el) return\n\n  const dropRowRect = rowInstance.el.getBoundingClientRect()\n  const tableRect = dragState.tableRect\n  const prevPercent = state.disabledTree ? 0.5 : 0.25\n  const nextPercent = state.disabledTree ? 0.5 : 0.75\n  const distance = event.clientY - dropRowRect.top\n  const dropRowHeight = dropRowRect.height\n\n  let dropType: DropType\n  let indicatorTop = -9999\n  let isIndicatorShow = true\n\n  if (distance < dropRowHeight * prevPercent) {\n    dropType = DropType.BEFORE\n    indicatorTop = dropRowRect.top - tableRect.top\n  } else if (distance >= dropRowHeight * nextPercent) {\n    dropType = DropType.AFTER\n    indicatorTop = dropRowRect.bottom - tableRect.top\n  } else {\n    dropType = DropType.INNER\n    isIndicatorShow = false\n  }\n\n  if (indicator.value) {\n    indicator.value.style.top = `${indicatorTop - 2}px`\n  }\n\n  dragState.willDropRow = rowInstance.row\n  dragState.dropType = dropType\n\n  indicatorShow.value = isIndicatorShow\n  indicatorType.value = dropType\n\n  emitEvent(props.onRowDragOver, rowInstance.row.data, event)\n}\n\nfunction isLeftInsideRight(left: TableRowState, right: TableRowState) {\n  if (!left || !right) return true\n\n  while (left) {\n    if (left === right || left.key === right.key) {\n      return true\n    }\n\n    left = getParentRow(left.key)!\n  }\n\n  return false\n}\n\nfunction handleRowDrop(rowInstance: TableRowInstance, event: DragEvent) {\n  if (!dragState) return\n\n  const { draggingRow, willDropRow, dropType } = dragState\n\n  if (!willDropRow || isLeftInsideRight(willDropRow, draggingRow)) return\n\n  let currentKey: Key\n  let parent: TableRowState | null\n\n  if (draggingRow) {\n    parent = getParentRow(draggingRow.key)\n\n    if (!parent) {\n      parent = {\n        children: state.treeRowData\n      } as TableRowState\n    }\n\n    currentKey = draggingRow.key\n    removeArrayItem(parent.children, item => item.key === currentKey)\n\n    if (!parent.children?.length) {\n      parent.treeExpanded = false\n    }\n  }\n\n  if (dropType === DropType.INNER) {\n    if (!Array.isArray(willDropRow.children)) {\n      willDropRow.children = []\n    }\n\n    const children = Array.from(willDropRow.children)\n\n    children.push(draggingRow)\n\n    willDropRow.children = children\n    willDropRow.treeExpanded = true\n    draggingRow.parent = willDropRow.key\n  } else {\n    currentKey = willDropRow.key\n    parent = getParentRow(willDropRow.key)\n\n    if (!parent) {\n      parent = {\n        children: state.treeRowData\n      } as TableRowState\n    }\n\n    const index = parent.children.findIndex(row => row.key === currentKey)\n\n    if (~index) {\n      parent.children.splice(+(dropType === DropType.AFTER) + index, 0, draggingRow)\n\n      draggingRow.parent = parent.key\n    }\n  }\n\n  dragState.dropped = true\n\n  refreshRowDepth()\n  flatTreeRows()\n  refreshRowIndex()\n  emitEvent(props.onRowDrop, rowInstance.row.data, dropType!, event)\n}\n\nfunction handleRowDragEnd(event: DragEvent) {\n  if (!dragState) return\n\n  const { draggingRow, dropped } = dragState\n\n  dragState = null\n  indicatorShow.value = false\n\n  nextTick(() => {\n    const allDataPayload = dropped ? getCurrentData() : state.data\n\n    setDragging(false)\n    dropped && emit('update:data', allDataPayload)\n    emitEvent(props.onRowDragEnd, draggingRow.data, allDataPayload, event)\n  })\n}\n\nfunction emitRowEvent(type: MouseEventType, payload: TableRowPayload) {\n  emitEvent(props[`onRow${type}`], payload)\n}\n\nfunction emitCellEvent(type: MouseEventType, payload: TableCellPayload) {\n  emitEvent(props[`onCell${type}`], payload)\n}\n\nfunction emitHeadEvent(type: MouseEventType, payload: TableHeadPayload) {\n  emitEvent(props[`onHead${type}`], payload)\n}\n\nfunction emitColResize(type: MoveEventType, payload: TableColResizePayload) {\n  emitEvent(props[`onColResize${type}`], payload)\n}\n\nfunction emitFootEvent(type: MouseEventType, payload: TableFootPayload) {\n  emitEvent(props[`onFoot${type}`], payload)\n}\n\nfunction computeRenderRows(force = false) {\n  const { totalHeight, bodyYScroll, heightBITree } = state\n  const { processedData } = getters\n  const rowCount = processedData.length\n\n  if (!props.virtual) {\n    setRenderRows(0, rowCount, force)\n\n    return\n  }\n\n  const viewHeight = Math.max(Math.min(bodyHeight.value || 0, bodyScrollHeight.value || 0), bodyMinHeight.value)\n\n  if (!viewHeight) {\n    setRenderRows(0, 0, force)\n  }\n\n  let viewStart = bodyYScroll\n  let viewEnd = bodyYScroll + viewHeight\n\n  if (viewEnd > totalHeight) {\n    viewEnd = totalHeight\n    viewStart = viewEnd - viewHeight\n  }\n\n  const start = heightBITree.boundIndex(viewStart)\n  const end = heightBITree.boundIndex(viewEnd)\n  const renderStart = Math.max(start - props.bufferCount, 0)\n  const renderEnd = Math.min(end + props.bufferCount + 1, rowCount)\n\n  setRenderRows(renderStart, renderEnd, force)\n}\n\nfunction refresh() {\n  return runInLocked(() => {\n    nextTick(computeTableWidth)\n    setTimeout(() => {\n      computeBodyHeight()\n      refreshPercentScroll()\n      nextFrameOnce(computeRenderRows)\n    }, 0)\n  })\n}\n\nasync function runInLocked(handler = noop, delay = 250) {\n  clearTimeout(timer.locked)\n\n  setLocked(true)\n  await handler()\n\n  return new Promise<void>(resolve => {\n    timer.locked = setTimeout(() => {\n      setLocked(false)\n      resolve()\n    }, delay)\n  })\n}\n\nfunction refreshPercentScroll() {\n  clearTimeout(timer.scroll)\n\n  timer.scroll = setTimeout(() => {\n    const { totalHeight, bodyYScroll } = state\n\n    yScrollPercent.value = Math.max(\n      Math.min((bodyYScroll / (totalHeight - (bodyScrollHeight.value ?? 0) || 1)) * 100, 100),\n      0\n    )\n    syncBarScroll()\n    nextTick(() => {\n      computeBodyHeight()\n    })\n    runInLocked()\n    nextFrameOnce(computeRenderRows)\n  }, 10)\n}\n\nfunction getSelected() {\n  const data = state.rowData\n  const selectedData: any[] = []\n\n  for (let i = 0, len = data.length; i < len; ++i) {\n    const row = data[i]\n\n    if (row.checked) {\n      selectedData.push(row.data)\n    }\n  }\n\n  return selectedData\n}\n\nfunction setRowChecked(keyOrData: Key | Record<any, any>, checked?: boolean) {\n  const row = queryRow(keyOrData)\n\n  if (!row || getters.disableCheckRows.has(row.key)) return\n\n  handleCheck(row.key, checked ?? !row.checked)\n}\n\nfunction setRowTreeExpanded(keyOrData: Key | Record<any, any>, expanded?: boolean) {\n  const row = queryRow(keyOrData)\n\n  if (!row) return\n\n  runInLocked()\n  setTreeExpanded(row.key, expanded ?? !row.treeExpanded)\n}\n\nfunction renderTableSlot({ name }: { name: string }) {\n  return renderSlot(slots, name)\n}\n\nfunction filterArrayByKeys() {\n  return availableColumns.value.filter(item => !props.defaultHidden.includes(item.key)).map(item => item.key)\n}\n\nonMounted(() => {\n  keyValues.value = filterArrayByKeys()\n})\n</script>\n\n<template>\n  <div\n    ref=\"wrapper\"\n    :class=\"className\"\n    role=\"table\"\n    :style=\"style\"\n    :aria-rowcount=\"props.data.length\"\n  >\n    <Spin :active=\"localLoading\" :delay=\"[50, 300]\">\n      <div v-show=\"false\" role=\"none\">\n        <slot></slot>\n        <template v-for=\"(column, _index) in showColumns\" :key=\"`__inner-column-${_index}`\">\n          <TableColumnGroup v-if=\"'children' in column\" v-bind=\"column\"></TableColumnGroup>\n          <TableColumn v-else v-bind=\"column\" :id-key=\"column.key\"></TableColumn>\n        </template>\n        <TableSummary\n          v-for=\"({ key, ...others }, index) in props.summaries\"\n          v-bind=\"others\"\n          :key=\"`__inner-summary-${index}`\"\n          :id-key=\"key\"\n        ></TableSummary>\n      </div>\n      <TableToolbar\n        v-if=\"toolbar\"\n        v-model:key-values=\"keyValues\"\n        :custom-search=\"props.customSearch\"\n        :loading=\"localLoading\"\n        :available-columns=\"availableColumns\"\n        :default-hidden=\"props.defaultHidden\"\n        @fuzzy-search=\"emit('fuzzySearch', $event)\"\n      >\n        <slot name=\"toolbar\"></slot>\n      </TableToolbar>\n      <div ref=\"thead\" :class=\"nh.be('head-wrapper')\">\n        <NativeScroll\n          ref=\"xHeadScroll\"\n          inherit\n          mode=\"horizontal\"\n          scroll-only\n          :class=\"[nh.be('wrapper'), props.scrollClass.horizontal]\"\n          :scroll-x=\"state.bodyXScroll\"\n          @scroll=\"handleXScroll\"\n        >\n          <div\n            v-if=\"state.leftFixedColumns.length\"\n            :class=\"{\n              [nh.bem('fixed', 'left')]: true,\n              [nh.bem('fixed', 'active')]: leftFixedActive\n            }\"\n          >\n            <TableHead fixed=\"left\"></TableHead>\n          </div>\n          <TableHead></TableHead>\n          <div\n            v-if=\"state.rightFixedColumns.length\"\n            :class=\"{\n              [nh.bem('fixed', 'right')]: true,\n              [nh.bem('fixed', 'active')]: rightFixedActive\n            }\"\n          >\n            <TableHead fixed=\"right\"></TableHead>\n          </div>\n        </NativeScroll>\n      </div>\n      <div\n        v-if=\"state.aboveSummaries.length\"\n        ref=\"aboveTfoot\"\n        :class=\"[nh.be('foot-wrapper'), nh.bem('foot-wrapper', 'above')]\"\n      >\n        <NativeScroll\n          ref=\"xAboveScroll\"\n          inherit\n          mode=\"horizontal\"\n          scroll-only\n          :class=\"[nh.be('wrapper'), props.scrollClass.horizontal]\"\n          :scroll-x=\"state.bodyXScroll\"\n          @scroll=\"handleXScroll\"\n        >\n          <div\n            v-if=\"state.leftFixedColumns.length\"\n            :class=\"{\n              [nh.bem('fixed', 'left')]: true,\n              [nh.bem('fixed', 'active')]: leftFixedActive\n            }\"\n          >\n            <TableFoot fixed=\"left\" above></TableFoot>\n          </div>\n          <TableFoot above></TableFoot>\n          <div\n            v-if=\"state.rightFixedColumns.length\"\n            :class=\"{\n              [nh.bem('fixed', 'right')]: true,\n              [nh.bem('fixed', 'active')]: rightFixedActive\n            }\"\n          >\n            <TableFoot fixed=\"right\" above></TableFoot>\n          </div>\n        </NativeScroll>\n      </div>\n      <div\n        :class=\"[nh.be('body-wrapper'), state.totalHeight >= bodyMinHeight && nh.bem('body-wrapper', 'scrolled')]\"\n        :style=\"{\n          ...(!bodyScrollHeight && state.totalHeight\n            ? {\n              height: `${state.totalHeight}px`,\n              transition: props.noTransition || state.locked ? undefined : `height ${nh.gnv('transition-base')}`\n            }\n            : undefined),\n          minHeight: `${bodyMinHeight}px`\n        }\"\n      >\n        <NativeScroll\n          ref=\"mainScroll\"\n          inherit\n          mode=\"both\"\n          scroll-only\n          observe-deep\n          :class=\"[nh.be('wrapper'), props.scrollClass.major]\"\n          :bar-class=\"nh.bem('bar', 'horizontal')\"\n          :height=\"bodyScrollHeight\"\n          :scroll-x=\"state.bodyXScroll\"\n          :scroll-y=\"state.bodyYScroll\"\n          @scroll=\"handleMainScroll\"\n          @x-enabled-change=\"xScrollEnabled = $event\"\n          @y-enabled-change=\"yScrollEnabled = $event\"\n          @resize=\"handleResize\"\n        >\n          <div\n            v-if=\"state.leftFixedColumns.length\"\n            :class=\"{\n              [nh.bem('fixed', 'left')]: true,\n              [nh.bem('fixed', 'active')]: leftFixedActive\n            }\"\n            :style=\"{ minHeight: `${state.totalHeight}px` }\"\n          >\n            <TableBody fixed=\"left\">\n              <template #empty=\"{ isFixed }\">\n                <slot name=\"empty\" :is-fixed=\"isFixed\"></slot>\n              </template>\n            </TableBody>\n          </div>\n          <TableBody>\n            <template #empty=\"{ isFixed }\">\n              <slot name=\"empty\" :is-fixed=\"isFixed\"></slot>\n            </template>\n          </TableBody>\n          <div\n            v-if=\"state.rightFixedColumns.length\"\n            :class=\"{\n              [nh.bem('fixed', 'right')]: true,\n              [nh.bem('fixed', 'active')]: rightFixedActive\n            }\"\n            :style=\"{ minHeight: `${state.totalHeight}px` }\"\n          >\n            <TableBody fixed=\"right\">\n              <template #empty=\"{ isFixed }\">\n                <slot name=\"empty\" :is-fixed=\"isFixed\"></slot>\n              </template>\n            </TableBody>\n          </div>\n        </NativeScroll>\n      </div>\n      <div\n        v-if=\"state.belowSummaries.length\"\n        ref=\"belowTfoot\"\n        :class=\"[nh.be('foot-wrapper'), nh.bem('foot-wrapper', 'below')]\"\n      >\n        <NativeScroll\n          ref=\"xBelowScroll\"\n          inherit\n          mode=\"horizontal\"\n          scroll-only\n          :class=\"[nh.be('wrapper'), props.scrollClass.horizontal]\"\n          :bar-class=\"nh.bem('bar', 'horizontal')\"\n          :bar-fade=\"props.barFade\"\n          :scroll-x=\"state.bodyXScroll\"\n          @scroll=\"handleXScroll\"\n        >\n          <div\n            v-if=\"state.leftFixedColumns.length\"\n            :class=\"{\n              [nh.bem('fixed', 'left')]: true,\n              [nh.bem('fixed', 'active')]: leftFixedActive\n            }\"\n          >\n            <TableFoot fixed=\"left\"></TableFoot>\n          </div>\n          <TableFoot></TableFoot>\n          <div\n            v-if=\"state.rightFixedColumns.length\"\n            :class=\"{\n              [nh.bem('fixed', 'right')]: true,\n              [nh.bem('fixed', 'active')]: rightFixedActive\n            }\"\n          >\n            <TableFoot fixed=\"right\"></TableFoot>\n          </div>\n        </NativeScroll>\n      </div>\n      <Scrollbar\n        v-if=\"props.useXBar && useXScroll\"\n        ref=\"xScrollbar\"\n        inherit\n        placement=\"bottom\"\n        :class=\"nh.bem('bar', 'horizontal')\"\n        :fade=\"props.barFade\"\n        :disabled=\"!xScrollEnabled\"\n        :bar-length=\"xBarLength\"\n        :style=\"{ bottom: `${footHeight}px` }\"\n        @scroll-start=\"setBarScrolling(true)\"\n        @scroll=\"handleXBarScroll\"\n        @scroll-end=\"setBarScrolling(false)\"\n      ></Scrollbar>\n      <Scrollbar\n        v-if=\"props.useYBar && bodyScrollHeight\"\n        ref=\"yScrollbar\"\n        inherit\n        placement=\"right\"\n        :class=\"nh.bem('bar', 'vertical')\"\n        :fade=\"props.barFade\"\n        :disabled=\"!yScrollEnabled\"\n        :bar-length=\"yBarLength\"\n        :style=\"{ top: `${headHeight}px`, bottom: `${footHeight}px` }\"\n        @scroll-start=\"setBarScrolling(true)\"\n        @scroll=\"handleYBarScroll\"\n        @scroll-end=\"setBarScrolling(false)\"\n      ></Scrollbar>\n      <div\n        v-if=\"props.rowDraggable || hasDragColumn\"\n        v-show=\"indicatorShow\"\n        ref=\"indicator\"\n        :class=\"[\n          nh.be('indicator'),\n          indicatorType === 'before' && nh.bem('indicator', 'before'),\n          indicatorType === 'after' && nh.bem('indicator', 'after')\n        ]\"\n      ></div>\n      <div\n        v-if=\"state.colResizable === 'lazy'\"\n        v-show=\"state.colResizing\"\n        :class=\"nh.be('resize-indicator')\"\n        :style=\"{ left: `${state.resizeLeft}px` }\"\n      ></div>\n    </Spin>\n  </div>\n</template>\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/utils", "@pocui/hooks"],
  "registryDependencies": [
    "table.scss",
    "tooltip",
    "tree",
    "checkbox",
    "ellipsis",
    "renderer",
    "resize-observer",
    "button",
    "icon",
    "collapse-transition",
    "button-group",
    "checkbox-group",
    "dropdown",
    "dropdown-item",
    "dropdown-list",
    "input",
    "space",
    "native-scroll",
    "scrollbar",
    "spin"
  ],
  "categories": ["display"],
  "meta": { "isReferenceOnly": false }
}
