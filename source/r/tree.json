{
  "name": "tree",
  "type": "registry:component",
  "description": "用于快速生成多层次的结构列表，通常在需要展示文件夹、组织架构、分类等的场景中使用，能够清晰地展现各层级的关系。",
  "files": [
    {
      "target": "components/tree/hooks.ts",
      "content": "import { isNullish, toFalse } from '@pocui/utils'\n\nexport interface CascadedNode {\n  checked: boolean,\n\n  partial: boolean,\n\n  parent?: string | number | symbol,\n\n  children: CascadedNode[]\n}\n\nexport function useCascadedChecked<T extends CascadedNode>(options: {\n  getNode: (key: string | number | symbol | undefined) => T | null | undefined | void,\n  disableNode?: (node: T) => boolean\n}) {\n  function updateCheckedUpward(key: string | number | symbol) {\n    let node = options.getNode(key)\n\n    if (!node) return\n\n    while (!isNullish(node.parent)) {\n      const parentId = node.parent\n      const parent = options.getNode(parentId)\n\n      if (!parent) break\n\n      if (node.checked === parent.checked && node.partial === parent.partial) {\n        break\n      }\n\n      if (node.checked) {\n        parent.checked = parent.children.every(item => item.checked)\n        parent.partial = !parent.checked\n      } else {\n        parent.checked = false\n        parent.partial = parent.children.some(item => item.checked || item.partial)\n      }\n\n      node = parent\n    }\n  }\n\n  function updateCheckedDown(key: string | number | symbol) {\n    const originNode = options.getNode(key)\n\n    if (!originNode) return\n\n    const disable = typeof options.disableNode === 'function' ? options.disableNode : toFalse\n    const checked = originNode.checked\n    const partial = originNode.partial\n\n    const loop = [...(originNode.children as T[])]\n\n    let node: T\n\n    while (loop.length) {\n      node = loop.shift()!\n\n      if (disable(node)) continue\n\n      node.checked = checked\n      node.partial = partial\n\n      if (node.children.length) {\n        loop.push(...(node.children as T[]))\n      }\n    }\n  }\n\n  return {\n    updateCheckedUpward,\n    updateCheckedDown\n  }\n}\n"
    },
    {
      "target": "components/tree/index.ts",
      "content": "import Tree from './tree.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Tree }\nexport { treeProps } from './props'\n\nexport type TreeExposed = ComponentPublicInstance & InstanceType<typeof Tree>\n\nexport type { TreeProps, TreeCProps } from './props'\nexport type {\n  TreeNodeDropType,\n  TreeLinkLine,\n  TreeNodeKeyConfig,\n  TreeNodeProps,\n  TreeNodePostCreate,\n  TreeNodeRenderFn,\n  TreeCommonSlotParams,\n  TreeNodeSlotParams\n} from './symbol'\n"
    },
    {
      "target": "components/tree/props.ts",
      "content": "import { booleanProp, buildProps, eventProp, iconProp, localeProp } from '@pocui/config'\n\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type {\n  AsyncLoadFn,\n  Data,\n  FilterFn,\n  NodePropsFn,\n  TreeLinkLine,\n  TreeNodeDropType,\n  TreeNodeKeyConfig,\n  TreeNodePostCreate,\n  TreeNodeProps,\n  TreeNodeRenderFn\n} from './symbol'\n\nexport const treeProps = buildProps({\n  locale: localeProp('tree'),\n  arrow: {\n    type: [Boolean, String] as PropType<boolean | 'auto'>,\n    default: null\n  },\n  data: Array as PropType<Data[]>,\n  noBuildTree: booleanProp,\n  emptyText: String,\n  disabled: booleanProp,\n  readonly: booleanProp,\n  checkbox: booleanProp,\n  suffixCheckbox: booleanProp,\n  renderer: Function as PropType<TreeNodeRenderFn>,\n  prefixRenderer: Function as PropType<TreeNodeRenderFn>,\n  suffixRenderer: Function as PropType<TreeNodeRenderFn>,\n  multiple: booleanProp,\n  indent: [String, Number],\n  accordion: booleanProp,\n  draggable: booleanProp,\n  appear: booleanProp,\n  floorSelect: booleanProp,\n  onAsyncLoad: Function as PropType<AsyncLoadFn>,\n  cacheNode: booleanProp,\n  rootId: [String, Number],\n  keyConfig: Object as PropType<TreeNodeKeyConfig>,\n  noCascaded: booleanProp,\n  filter: [String, Function] as PropType<string | FilterFn>,\n  ignoreCase: booleanProp,\n  nodeProps: [Object, Function] as PropType<Data | NodePropsFn>,\n  linkLine: {\n    type: [Boolean, String] as PropType<boolean | TreeLinkLine>,\n    default: null\n  },\n  postCreate: Function as PropType<TreeNodePostCreate>,\n  virtual: booleanProp,\n  nodeMinHeight: Number,\n  useYBar: booleanProp,\n  noTransition: booleanProp,\n  arrowIcon: iconProp,\n  blockEffect: booleanProp,\n  filterLeaf: booleanProp,\n  onNodeChange: eventProp<(data: Data, node: TreeNodeProps, checked: boolean) => void>(),\n  onNodeClick: eventProp<(data: Data, node: TreeNodeProps) => void>(),\n  onNodeSelect: eventProp<(data: Data | Data[], node: TreeNodeProps | TreeNodeProps[]) => void>(),\n  onNodeCancel: eventProp<(data: Data, node: TreeNodeProps) => void>(),\n  onNodeExpand: eventProp<(data: Data, node: TreeNodeProps) => void>(),\n  onNodeReduce: eventProp<(data: Data, node: TreeNodeProps) => void>(),\n  onDragStart: eventProp<(data: Data, node: TreeNodeProps) => void>(),\n  onDragOver: eventProp<(data: Data, node: TreeNodeProps) => void>(),\n  onDrop: eventProp<(data: Data, node: TreeNodeProps, type: TreeNodeDropType) => void>(),\n  onDragEnd: eventProp<(data: Data, node: TreeNodeProps) => void>(),\n  onLabelClick: eventProp<(data: Data, node: TreeNodeProps) => void>()\n})\n\nexport type TreeProps = ExtractPropTypes<typeof treeProps>\nexport type TreeCProps = ConfigurableProps<TreeProps, 'data', 'onAsyncLoad'>\n"
    },
    {
      "target": "components/tree/symbol.ts",
      "content": "import type { InjectionKey } from 'vue'\n\nexport type Key = string | number | symbol\nexport type Data = any\nexport type TreeNodeDropType = 'before' | 'inner' | 'after'\nexport type TreeLinkLine = 'dashed' | 'solid' | 'dotted' | 'none'\n\nexport interface TreeNodeKeyConfig {\n  id?: string,\n\n  parent?: string,\n\n  label?: string,\n\n  children?: string,\n\n  visible?: string,\n\n  selected?: string,\n\n  expanded?: string,\n\n  disabled?: string,\n\n  checked?: string,\n\n  loading?: string,\n\n  loaded?: string,\n\n  loadFail?: string,\n\n  readonly?: string,\n\n  arrow?: string,\n\n  checkbox?: string,\n\n  selectDisabled?: string,\n\n  expandDisabled?: string,\n\n  checkDisabled?: string,\n\n  isLeaf?: string\n}\n\nexport const enum DropType {\n  BEFORE = 'before',\n  INNER = 'inner',\n  AFTER = 'after'\n}\n\nexport type TreeNodeProps<D = Data> = {\n  id: Key,\n  parent?: Key,\n  children: TreeNodeProps[],\n  visible: boolean,\n  selected: boolean,\n  expanded: boolean,\n  disabled: boolean,\n  checked: boolean,\n  loading: boolean,\n  loaded: boolean,\n  loadFail: boolean,\n  readonly: boolean,\n  arrow: boolean | 'auto',\n  checkbox: boolean,\n  selectDisabled: boolean,\n  expandDisabled: boolean,\n  checkDisabled: boolean,\n  isLeaf: boolean | 'auto',\n  data: D,\n  /** @internal */\n  partial: boolean,\n  /** @internal */\n  matched: boolean,\n  /** @internal */\n  childMatched: boolean,\n  /** @internal */\n  upperMatched: boolean,\n  /** @internal */\n  depth: number,\n  /** @internal */\n  last: boolean,\n  /** @internal */\n  upstreamLast: boolean[],\n  /** @internal */\n  lineIndexes: number[]\n}\n\nexport type TreeNodePostCreate<D = Data> = (node: TreeNodeProps<D>) => void\nexport type TreeNodeRenderFn<D = Data> = (params: { data: D, node: TreeNodeProps<D> }) => any\nexport type AsyncLoadFn<D = Data> = (data: D, node: Readonly<TreeNodeProps<D>>) => void | boolean | Promise<any>\nexport type FilterFn<D = Data> = (data: D, node: TreeNodeProps<D>) => boolean\nexport type NodePropsFn<D = Data> = (data: D, node: TreeNodeProps<D>) => Data\n\nexport interface TreeCommonSlotParams {\n  data: Data,\n\n  node: TreeNodeProps,\n\n  depth: number,\n\n  focused: boolean\n}\n\nexport interface TreeNodeSlotParams extends TreeCommonSlotParams {\n  /** @deprecated */\n  lineCount: number,\n\n  lineIndexes: number[],\n\n  toggleCheck: (checked?: boolean) => void,\n\n  toggleExpand: (expanded?: boolean) => Promise<void>,\n\n  toggleSelect: (able?: boolean) => Promise<void> | undefined\n}\n\nexport interface TreeNodeInstance {\n  el?: HTMLElement | null,\n\n  arrow?: HTMLElement | null,\n\n  node: TreeNodeProps\n}\n\nexport interface TreeNodeState {\n  el?: HTMLElement | null,\n\n  depth: number,\n\n  disabled: boolean,\n\n  readonly: boolean\n}\n\nexport interface TreeCollapseProps {\n  id: symbol,\n\n  placeholder: true,\n\n  type: 'expand' | 'reduce',\n\n  height: number,\n\n  nodes: TreeNodeProps[]\n}\n\nexport interface TreeState {\n  arrow: boolean | 'auto',\n\n  checkbox: boolean,\n\n  suffixCheckbox: boolean,\n\n  noCascaded: boolean,\n\n  linkLine: false | TreeLinkLine,\n\n  virtual: boolean,\n\n  labelKey: string,\n\n  draggable: boolean,\n\n  floorSelect: boolean,\n\n  renderer: TreeNodeRenderFn,\n\n  prefixRenderer: TreeNodeRenderFn,\n\n  suffixRenderer: TreeNodeRenderFn,\n\n  arrowIcon: Record<string, any>,\n\n  blockEffect: boolean,\n\n  dragging: boolean,\n\n  boundAsyncLoad: boolean,\n\n  nodeStates: Map<Key, TreeNodeState>,\n\n  expanding: boolean,\n\n  getParentNode(node: TreeNodeProps): TreeNodeProps | null,\n\n  updateVisibleNodeEls(): void,\n\n  computeCheckedState(originNode: TreeNodeProps, able: boolean): void,\n\n  handleNodeClick(node: TreeNodeProps): void,\n\n  handleNodeSelect(node: TreeNodeProps): void,\n\n  handleNodeCancel(node: TreeNodeProps): void,\n\n  handleNodeExpand(node: TreeNodeProps): void,\n\n  handleNodeReduce(node: TreeNodeProps): void,\n\n  handleAsyncLoad(node: TreeNodeProps): Promise<boolean>,\n\n  handleNodeDragStart(nodeInstance: TreeNodeInstance): void,\n\n  handleNodeDragOver(nodeInstance: TreeNodeInstance, event: DragEvent): void,\n\n  handleNodeDrop(nodeInstance: TreeNodeInstance): void,\n\n  handleNodeDragEnd(nodeInstance: TreeNodeInstance): void,\n\n  handleHittingChange(type: 'up' | 'down'): void,\n\n  handleNodeHitting(nodeEl?: HTMLElement | null): void,\n\n  handleLabelClick(node: TreeNodeProps): void\n}\n\nexport const TREE_STATE: InjectionKey<TreeState> = Symbol('TREE_STATE')\nexport const TREE_NODE_STATE: InjectionKey<TreeNodeState> = Symbol('TREE_NODE_STATE')\n\nexport const defaultKeyConfig: Required<TreeNodeKeyConfig> = {\n  id: 'id',\n  parent: 'parent',\n  label: 'label',\n  children: 'children',\n  visible: 'visible',\n  selected: 'selected',\n  expanded: 'expanded',\n  disabled: 'disabled',\n  checked: 'checked',\n  loading: 'loading',\n  loaded: 'loaded',\n  loadFail: 'loadFail',\n  readonly: 'readonly',\n  arrow: 'arrow',\n  checkbox: 'checkbox',\n  selectDisabled: 'selectDisabled',\n  expandDisabled: 'expandDisabled',\n  checkDisabled: 'checkDisabled',\n  isLeaf: 'isLeaf'\n}\n"
    },
    {
      "target": "components/tree/tree-node.vue",
      "content": "<script setup lang=\"ts\">\nimport { Checkbox } from '@/components/checkbox'\nimport { Icon } from '@/components/icon'\nimport { Renderer } from '@/components/renderer'\n\nimport { computed, inject, nextTick, onBeforeUnmount, reactive, ref, watch } from 'vue'\n\nimport { useIcons, useNameHelper } from '@pocui/config'\nimport { useModifier } from '@pocui/hooks'\nimport { decide, isNullish } from '@pocui/utils'\n\nimport { TREE_STATE } from './symbol'\n\nimport type { PropType } from 'vue'\n\nimport type { TreeCommonSlotParams, TreeNodeProps, TreeNodeSlotParams } from './symbol'\n\ndefineOptions({\n  name: 'TreeNode',\n  description:'树节点组件，作为树形结构的单个节点项。',\n  categories: ['display'],\n  inheritAttrs: false\n})\n\nconst props = defineProps({\n  node: {\n    type: Object as PropType<TreeNodeProps>,\n    default: () => ({})\n  }\n})\n\ndefineSlots<{\n  default(props: TreeNodeSlotParams): any,\n  arrow(props: TreeCommonSlotParams): any,\n  prefix(props: TreeCommonSlotParams): any,\n  label(props: TreeCommonSlotParams): any,\n  suffix(props: TreeCommonSlotParams): any\n}>()\n\nconst treeState = inject(TREE_STATE)!\n\nconst nh = useNameHelper('tree')\nconst icons = useIcons()\n\nconst wrapper = ref<HTMLElement>()\nconst arrowEl = ref<HTMLElement>()\n\nconst parentState = computed(() => {\n  return props.node.parent ? treeState.nodeStates.get(props.node.parent) : undefined\n})\n\nuseModifier({\n  target: wrapper,\n  passive: false,\n  onKeyDown: (event, modifier) => {\n    if (treeState.expanding) return\n\n    decide(\n      [\n        [() => modifier.up || modifier.down, () => treeState.handleHittingChange(modifier.up ? 'up' : 'down')],\n        [\n          () => modifier.left || modifier.right,\n          () => {\n            const hasChild = props.node.children?.length > 0\n\n            if (modifier.right && props.node.expanded && hasChild) {\n              treeState.handleHittingChange('down')\n            } else if (modifier.left && (!props.node.expanded || !hasChild)) {\n              treeState.handleNodeHitting(parentState.value?.el)\n            } else {\n              toggleExpanded(modifier.right)\n            }\n          }\n        ],\n        [() => hasCheckbox.value && modifier.space, handleToggleCheck],\n        [() => modifier.enter, handleToggleSelect]\n      ],\n      {\n        beforeMatchAny: () => {\n          event.preventDefault()\n          event.stopPropagation()\n        },\n        afterMatchAny: modifier.resetAll\n      }\n    )\n  }\n})\n\nconst loaded = ref(!treeState.boundAsyncLoad || props.node.loaded)\nconst loadFail = ref(treeState.boundAsyncLoad && props.node.loadFail)\nconst dragging = ref(false)\nconst isDragOver = ref(false)\nconst focused = ref(false)\n\nconst isDisabled = computed(() => {\n  return (!treeState.noCascaded && parentState.value?.disabled) || props.node.disabled\n})\nconst isReadonly = computed(() => {\n  return (!treeState.noCascaded && parentState.value?.readonly) || props.node.readonly\n})\nconst secondary = computed(() => !props.node.matched && (props.node.childMatched || props.node.upperMatched))\nconst hasLinkLine = computed(() => !!treeState.linkLine && props.node.depth > 0)\nconst className = computed(() => {\n  return {\n    [nh.be('node')]: true,\n    [nh.bem('node', 'last')]: props.node.last,\n    [nh.bem('node', 'focused')]: focused.value,\n    [nh.bem('node', 'selected')]: props.node.selected,\n    [nh.bem('node', 'expanded')]: props.node.expanded,\n    [nh.bem('node', 'disabled')]: isDisabled.value,\n    [nh.bem('node', 'readonly')]: isReadonly.value,\n    [nh.bem('node', 'secondary')]: secondary.value,\n    [nh.bem('node', 'dragging')]: dragging.value,\n    [nh.bem('node', 'drag-over')]: isDragOver.value,\n    [nh.bem('node', 'link-line')]: hasLinkLine.value,\n    [nh.bem('node', 'no-arrow')]: !hasArrow.value,\n    [nh.bem('node', 'is-floor')]: treeState.floorSelect && props.node.children?.length,\n    [nh.bem('node', 'loaded')]: loaded.value,\n    [nh.bem('node', 'load-fail')]: loadFail.value\n  }\n})\nconst isLeaf = computed(() => {\n  const isLeaf = props.node.isLeaf\n\n  let leafSign: boolean | 'auto' = 'auto'\n  let asyncLoad = false\n\n  if (isNullish(isLeaf) || isLeaf === 'auto') {\n    leafSign = 'auto'\n    asyncLoad = treeState.boundAsyncLoad\n  } else {\n    leafSign = isLeaf\n  }\n\n  return leafSign === 'auto' ? !(props.node.children?.length || (asyncLoad && !loaded.value)) : !!leafSign\n})\nconst hasArrow = computed(() => {\n  return isNullish(props.node.arrow) || props.node.arrow === 'auto'\n    ? treeState.arrow === 'auto'\n      ? !isLeaf.value\n      : treeState.arrow\n    : props.node.arrow\n})\nconst hasCheckbox = computed(() => {\n  const checkbox = props.node.checkbox\n\n  return isNullish(checkbox) ? treeState.checkbox : checkbox\n})\nconst suffixCheckbox = computed(() => treeState.suffixCheckbox)\nconst nodeState = reactive({\n  el: wrapper,\n  depth: computed(() => props.node.depth),\n  disabled: isDisabled,\n  readonly: isReadonly\n})\n\nwatch([() => treeState.boundAsyncLoad, () => props.node.loaded], values => {\n  loaded.value = !values[0] || values[1]\n})\nwatch([() => treeState.boundAsyncLoad, () => props.node.loadFail], values => {\n  loadFail.value = !values[0] || values[1]\n})\nwatch(\n  () => props.node.id,\n  (value, prev) => {\n    treeState.nodeStates.delete(prev)\n    treeState.nodeStates.set(value, nodeState)\n  }\n)\n\ntreeState.nodeStates.set(props.node.id, nodeState)\n\nlet dragTimer: ReturnType<typeof setTimeout>\n\nonBeforeUnmount(() => {\n  clearTimeout(dragTimer)\n  treeState.nodeStates.set(props.node.id, nodeState)\n})\n\nfunction setValue<T = unknown>(key: keyof TreeNodeProps, value: T) {\n  ;(props.node as any)[key] = value\n}\n\nfunction handleClick() {\n  treeState.handleNodeClick(props.node)\n\n  if (treeState.blockEffect) {\n    handleLabelClick()\n  }\n}\n\nfunction handleToggleCheck(able = !props.node.checked) {\n  if (isDisabled.value || props.node.checkDisabled) return\n\n  setValue('checked', able)\n  setValue('partial', false)\n\n  nextTick(() => {\n    treeState.computeCheckedState(props.node, able)\n  })\n}\n\nasync function toggleExpanded(able = !props.node.expanded) {\n  if (treeState.expanding || props.node.loading || isDisabled.value || props.node.expandDisabled || isLeaf.value) {\n    return\n  }\n\n  if (able && treeState.boundAsyncLoad && !loaded.value) {\n    setValue('loading', true)\n\n    const result = await treeState.handleAsyncLoad(props.node)\n\n    asyncLoadCallback(result)\n  } else {\n    setValue('expanded', able)\n\n    if (able) {\n      treeState.handleNodeExpand(props.node)\n    } else {\n      treeState.handleNodeReduce(props.node)\n    }\n  }\n}\n\nfunction handleToggleSelect(able = !props.node.selected) {\n  if (isDisabled.value || props.node.selectDisabled) return\n\n  if (treeState.floorSelect) {\n    return toggleExpanded()\n  }\n\n  setValue('selected', !isReadonly.value && able)\n\n  if (isReadonly.value || able) {\n    treeState.handleNodeSelect(props.node)\n  } else {\n    treeState.handleNodeCancel(props.node)\n  }\n}\n\nfunction handleLabelClick() {\n  treeState.handleLabelClick(props.node)\n  handleToggleSelect()\n}\n\nfunction asyncLoadCallback(success = true) {\n  setValue('loading', false)\n  setValue('expanded', success !== false)\n\n  if (success) {\n    setValue('loaded', true)\n    setValue('loadFail', false)\n    treeState.handleNodeExpand(props.node)\n  } else {\n    setValue('loadFail', true)\n  }\n}\n\nfunction getNodeState() {\n  return {\n    el: wrapper.value,\n    arrow: arrowEl.value,\n    node: props.node\n  }\n}\n\nfunction handleDragStart() {\n  if (!treeState.draggable) return\n\n  dragging.value = true\n  treeState.handleNodeDragStart(getNodeState())\n}\n\nfunction handleDragOver(event: DragEvent) {\n  if (!treeState.draggable || !treeState.dragging) return\n\n  clearTimeout(dragTimer)\n  event.stopPropagation()\n  event.preventDefault()\n\n  isDragOver.value = true\n\n  treeState.handleNodeDragOver(getNodeState(), event)\n}\n\nfunction handleDragLeave(event: DragEvent) {\n  if (!treeState.draggable) return\n\n  clearTimeout(dragTimer)\n  event.preventDefault()\n\n  dragTimer = setTimeout(() => {\n    isDragOver.value = false\n  }, 100)\n}\n\nfunction handleDrop(event: DragEvent) {\n  if (!treeState.draggable || !treeState.dragging) return\n\n  clearTimeout(dragTimer)\n  event.stopPropagation()\n  event.preventDefault()\n\n  isDragOver.value = false\n\n  treeState.handleNodeDrop(getNodeState())\n}\n\nfunction handleDragEnd(event: DragEvent) {\n  if (!treeState.draggable || !treeState.dragging) return\n\n  event.stopPropagation()\n  dragging.value = false\n  treeState.handleNodeDragEnd(getNodeState())\n}\n</script>\n\n<template>\n  <li\n    v-bind=\"$attrs\"\n    ref=\"wrapper\"\n    :class=\"className\"\n    :draggable=\"treeState.draggable\"\n    tabindex=\"-1\"\n    :aria-disabled=\"isDisabled\"\n    :aria-grabbed=\"treeState.draggable && dragging ? 'true' : undefined\"\n    :style=\"{ [nh.cv('depth')]: node.depth }\"\n    @click.left=\"handleClick\"\n    @focus=\"focused = true\"\n    @blur=\"focused = false\"\n    @dragstart.stop=\"handleDragStart\"\n    @dragover=\"handleDragOver\"\n    @dragleave=\"handleDragLeave\"\n    @dragend=\"handleDragEnd\"\n    @drop=\"handleDrop\"\n  >\n    <slot\n      :data=\"node.data\"\n      :node=\"node\"\n      :depth=\"node.depth\"\n      :focused=\"focused\"\n      :line-count=\"0\"\n      :line-indexes=\"node.lineIndexes\"\n      :toggle-check=\"handleToggleCheck\"\n      :toggle-expand=\"toggleExpanded\"\n      :toggle-select=\"handleToggleSelect\"\n    >\n      <template v-if=\"hasLinkLine\">\n        <div\n          v-for=\"(lineIndex, index) in node.lineIndexes\"\n          :key=\"index\"\n          :class=\"[nh.be('link-line'), nh.bem('link-line', 'vertical'), !index && nh.bem('link-line', 'first')]\"\n          :style=\"{ [nh.cv('link-line-index')]: lineIndex }\"\n          aria-hidden=\"true\"\n        ></div>\n\n        <div :class=\"[nh.be('link-line'), nh.bem('link-line', 'horizontal')]\" aria-hidden=\"true\"></div>\n      </template>\n      <div\n        :class=\"{\n          [nh.be('content')]: true,\n          [nh.bem('content', 'effect')]: treeState.blockEffect,\n          [nh.bem('content', 'disabled')]: treeState.blockEffect && (isDisabled || node.selectDisabled)\n        }\"\n      >\n        <span\n          ref=\"arrowEl\"\n          :class=\"{\n            [nh.be('arrow')]: true,\n            [nh.bem('arrow', 'transparent')]: !node.loading && !hasArrow,\n            [nh.bem('arrow', 'expanded')]: node.expanded,\n            [nh.bem('arrow', 'disabled')]: isDisabled || node.expandDisabled\n          }\"\n          :aria-hidden=\"!node.loading && !hasArrow\"\n          @click.stop=\"toggleExpanded()\"\n        >\n          <Icon v-if=\"node.loading\" v-bind=\"icons.loading\" label=\"loading\"></Icon>\n          <slot\n            v-else\n            name=\"arrow\"\n            :data=\"node.data\"\n            :node=\"node\"\n            :depth=\"node.depth\"\n            :focused=\"focused\"\n          >\n            <Icon v-if=\"treeState.arrowIcon\" :icon=\"treeState.arrowIcon\"></Icon>\n            <Icon v-else v-bind=\"icons.angleRight\"></Icon>\n          </slot>\n        </span>\n        <Checkbox\n          v-if=\"hasCheckbox && !suffixCheckbox\"\n          inherit\n          :class=\"nh.be('checkbox')\"\n          :tab-index=\"-1\"\n          :control=\"hasArrow\"\n          :checked=\"node.checked\"\n          :disabled=\"isDisabled || node.checkDisabled\"\n          :partial=\"node.partial\"\n          @click.prevent.stop=\"handleToggleCheck()\"\n        ></Checkbox>\n        <div\n          :class=\"{\n            [nh.be('label')]: true,\n            [nh.bem('label', 'effect')]: !treeState.blockEffect,\n            [nh.bem('label', 'disabled')]: !treeState.blockEffect && (isDisabled || node.selectDisabled)\n          }\"\n          @click=\"!treeState.blockEffect && handleLabelClick()\"\n        >\n          <div v-if=\"treeState.prefixRenderer || $slots.prefix\" :class=\"nh.be('prefix')\">\n            <Renderer\n              v-if=\"treeState.prefixRenderer\"\n              :renderer=\"treeState.prefixRenderer\"\n              :data=\"{ node, depth: node.depth, data: node.data, focused }\"\n            ></Renderer>\n            <slot\n              v-else\n              name=\"prefix\"\n              :data=\"node.data\"\n              :node=\"node\"\n              :depth=\"node.depth\"\n              :focused=\"focused\"\n            ></slot>\n          </div>\n          <div :class=\"nh.be('text')\">\n            <Renderer\n              v-if=\"treeState.renderer\"\n              :renderer=\"treeState.renderer\"\n              :data=\"{ node, depth: node.depth, data: node.data, focused }\"\n            ></Renderer>\n            <slot\n              v-else\n              name=\"label\"\n              :data=\"node.data\"\n              :node=\"node\"\n              :depth=\"node.depth\"\n              :focused=\"focused\"\n            >\n              {{ node.data[treeState.labelKey] }}\n            </slot>\n          </div>\n          <div v-if=\"treeState.suffixRenderer || $slots.suffix\" :class=\"nh.be('suffix')\">\n            <Renderer\n              v-if=\"treeState.suffixRenderer\"\n              :renderer=\"treeState.suffixRenderer\"\n              :data=\"{ node, depth: node.depth, data: node.data, focused }\"\n            ></Renderer>\n            <slot\n              v-else\n              name=\"suffix\"\n              :data=\"node.data\"\n              :node=\"node\"\n              :depth=\"node.depth\"\n              :focused=\"focused\"\n            ></slot>\n          </div>\n        </div>\n        <Checkbox\n          v-if=\"hasCheckbox && suffixCheckbox\"\n          inherit\n          :class=\"[nh.be('checkbox'), nh.bem('checkbox', 'suffix')]\"\n          :tab-index=\"-1\"\n          :control=\"hasArrow\"\n          :checked=\"node.checked\"\n          :disabled=\"isDisabled || node.checkDisabled\"\n          :partial=\"node.partial\"\n          @click.prevent.stop=\"handleToggleCheck()\"\n        ></Checkbox>\n      </div>\n    </slot>\n  </li>\n</template>\n"
    },
    {
      "target": "components/tree/tree.vue",
      "content": "<script setup lang=\"ts\">\nimport { CollapseTransition } from '@/components/collapse-transition'\n\nimport { VirtualList } from '@/components/virtual-list'\n\nimport { computed, nextTick, onMounted, provide, reactive, ref, toRef, watch, watchEffect } from 'vue'\n\nimport { createIconProp, emitEvent, useLocale, useNameHelper, useProps } from '@pocui/config'\nimport { useMounted, useSetTimeout } from '@pocui/hooks'\nimport {\n  debounce,\n  filterTree,\n  flatTree,\n  getGlobalCount,\n  getLast,\n  isNullish,\n  isPromise,\n  mapTree,\n  queryAll,\n  removeArrayItem,\n  transformTree,\n  walkTree\n} from '@pocui/utils'\n\nimport { useCascadedChecked } from './hooks'\nimport { treeProps } from './props'\n\nimport { DropType, TREE_NODE_STATE, TREE_STATE, defaultKeyConfig } from './symbol'\n\nimport TreeNode from './tree-node.vue'\n\nimport type {\n  Data,\n  FilterFn,\n  Key,\n  TreeCollapseProps,\n  TreeCommonSlotParams,\n  TreeNodeInstance,\n  TreeNodeProps,\n  TreeNodeSlotParams,\n  TreeNodeState\n} from './symbol'\n\nimport type { VirtualListExposed } from '@/components/virtual-list'\n\ndefineOptions({ name: 'Tree',\n  description:'用于快速生成多层次的结构列表，通常在需要展示文件夹、组织架构、分类等的场景中使用，能够清晰地展现各层级的关系。',\n  categories: ['display'] })\n\nconst _props = defineProps(treeProps)\nconst props = useProps('tree', _props, {\n  arrow: {\n    default: 'auto',\n    validator: value => typeof value === 'boolean' || value === 'auto'\n  },\n  data: {\n    default: () => [],\n    static: true\n  },\n  noBuildTree: false,\n  emptyText: null,\n  disabled: false,\n  readonly: false,\n  checkbox: false,\n  suffixCheckbox: false,\n  renderer: {\n    default: null,\n    isFunc: true\n  },\n  prefixRenderer: {\n    default: null,\n    isFunc: true\n  },\n  suffixRenderer: {\n    default: null,\n    isFunc: true\n  },\n  multiple: false,\n  indent: '16px',\n  accordion: false,\n  draggable: false,\n  appear: false,\n  floorSelect: false,\n  onAsyncLoad: {\n    default: null,\n    isFunc: true\n  },\n  cacheNode: false,\n  rootId: null,\n  keyConfig: () => ({}),\n  noCascaded: false,\n  filter: '',\n  ignoreCase: false,\n  nodeProps: null,\n  linkLine: false,\n  postCreate: {\n    default: null,\n    isFunc: true\n  },\n  virtual: false,\n  nodeMinHeight: {\n    default: 26,\n    validator: value => value > 0\n  },\n  useYBar: false,\n  noTransition: false,\n  arrowIcon: createIconProp(),\n  blockEffect: false,\n  filterLeaf: false\n})\n\ndefineSlots<{\n  arrow(props: TreeCommonSlotParams): any,\n  empty(): any,\n  label(props: TreeCommonSlotParams): any,\n  node(props: TreeNodeSlotParams): any,\n  prefix(props: TreeCommonSlotParams): any,\n  suffix(props: TreeCommonSlotParams): any\n}>()\n\nconst nh = useNameHelper('tree')\nconst locale = useLocale('tree', toRef(props, 'locale'))\n\nconst nodeMap = new Map<Key, TreeNodeProps>()\nconst nodeDataMap = new Map<Data, TreeNodeProps>()\nconst treeNodes = ref<TreeNodeProps[]>([])\nconst flattedNodes = ref<TreeNodeProps[]>([])\nconst dragging = ref(false)\nconst indicatorShow = ref(false)\nconst keyConfig = reactive({ ...defaultKeyConfig })\nconst nodeStates = reactive(new Map<Key, TreeNodeState>())\nconst expanding = ref(false)\nconst expandingNodes = ref<TreeNodeProps[]>([])\nconst expandedNodeIds = ref(new Set<Key>())\n\nconst { timer } = useSetTimeout()\nconst { isMounted } = useMounted()\n\nconst virtualList = ref<VirtualListExposed>()\nconst trap = ref<HTMLElement>()\nconst indicator = ref<HTMLElement>()\n\nconst wrapper = computed(() => virtualList.value?.wrapper)\n\nlet visibleNodeEls: HTMLElement[] = []\n\nconst defaultNodeProperties = {\n  visible: true,\n  selected: false,\n  expanded: false,\n  disabled: false,\n  checked: false,\n  loading: false,\n  loaded: false,\n  loadFail: false,\n  readonly: false,\n  arrow: 'auto' as boolean | 'auto',\n  // 当未设置（为空）时,将遵循树的复选框属性\n  checkbox: null! as boolean,\n  selectDisabled: false,\n  expandDisabled: false,\n  checkDisabled: false,\n  isLeaf: 'auto' as boolean | 'auto'\n}\n\nconst boundAsyncLoad = computed(() => typeof props.onAsyncLoad === 'function')\nconst linkLine = computed(() => {\n  return props.linkLine === true ? 'dashed' : props.linkLine === 'none' ? false : props.linkLine\n})\nconst style = computed(() => {\n  return {\n    [nh.cv('indent-width')]: typeof props.indent === 'number' ? `${props.indent}px` : props.indent,\n    [nh.cv('link-line-type')]: linkLine.value || undefined\n  }\n})\nconst visibleNodes = computed(() => flatNodes(treeNodes.value))\nconst renderedNodes = computed(() => {\n  return expanding.value ? expandingNodes.value : visibleNodes.value\n})\nconst toNodeProps = computed(() => {\n  return typeof props.nodeProps === 'function' ? props.nodeProps : () => props.nodeProps\n})\n\nfunction createDefaultFilter(value: string) {\n  const pattern = props.ignoreCase ? String(value).toLocaleLowerCase() : value\n  const defaultFilter: FilterFn = data => {\n    const label = data[keyConfig.label]\n\n    return props.ignoreCase ? String(label).toLocaleLowerCase().includes(pattern) : String(label).includes(pattern)\n  }\n\n  return defaultFilter\n}\n\nconst updateVisibleNodeEls = debounce(() => {\n  if (wrapper.value) {\n    visibleNodeEls = queryAll(`.${nh.be('node')}`, wrapper.value)\n  }\n}, 300)\n\nlet disableExpand = false\n\nfunction disableExpandTick() {\n  disableExpand = true\n\n  nextTick(() => {\n    disableExpand = false\n  })\n}\n\nwatchEffect(() => {\n  const nodes = flattedNodes.value\n\n  disableExpandTick()\n\n  if (!props.filter) {\n    for (let i = 0, len = nodes.length; i < len; ++i) {\n      const node = nodes[i]\n\n      node.matched = true\n      node.childMatched = false\n      node.upperMatched = false\n    }\n  } else {\n    const filter = typeof props.filter === 'function' ? props.filter : createDefaultFilter(props.filter)\n    const leafOnly = props.filterLeaf\n\n    for (let i = 0, len = nodes.length; i < len; ++i) {\n      const node = nodes[i]\n\n      if (leafOnly && !isLeafNode(node)) {\n        node.matched = false\n        node.childMatched = false\n        node.upperMatched = false\n\n        continue\n      }\n\n      const parent = node.parent ? nodeMap.get(node.parent) : undefined\n\n      node.matched = filter(node.data, node)\n      node.childMatched = false\n      node.upperMatched = !!parent && (parent.matched || parent.upperMatched)\n\n      if (node.matched) {\n        let upper = parent\n\n        while (upper && !upper.childMatched) {\n          upper.childMatched = true\n          upper.expanded = true\n          upper = upper.parent ? nodeMap.get(upper.parent) : undefined\n        }\n      }\n    }\n  }\n\n  resetExpanded()\n})\nwatchEffect(() => Object.assign(keyConfig, props.keyConfig))\nwatchEffect(() => {\n  const oldIds = expandedNodeIds.value\n  const ids = new Set<Key>()\n\n  let changed = false\n\n  for (const node of flattedNodes.value) {\n    if (node.expanded) {\n      ids.add(node.id)\n\n      if (!changed && !oldIds.has(node.id)) {\n        changed = true\n      }\n    }\n  }\n\n  if (changed || ids.size !== oldIds.size) {\n    expandedNodeIds.value = ids\n  }\n})\nwatch(\n  [\n    () => props.data,\n    () => props.data.length,\n    () => keyConfig.id,\n    () => keyConfig.children,\n    () => keyConfig.parent,\n    () => props.rootId\n  ],\n  parseAndTransformData,\n  { immediate: true }\n)\nwatch(\n  [treeNodes, () => props.rootId],\n  () => {\n    flattedNodes.value = flatTree(treeNodes.value, {\n      keyField: 'id',\n      parentField: 'parent',\n      childField: 'children',\n      rootId: props.rootId,\n      injectId: false,\n      depthFirst: true\n    })\n  },\n  { immediate: true }\n)\nwatch(expandedNodeIds, (value, prev) => {\n  if (props.noTransition) {\n    updateVisibleNodeEls()\n  }\n\n  if (props.noTransition || disableExpand || !wrapper.value) return\n\n  let addedId: Key | undefined\n  let removedId: Key | undefined\n\n  for (const id of value) {\n    if (!prev.has(id)) {\n      if (addedId != null) return\n\n      addedId = id\n    }\n  }\n\n  for (const id of prev) {\n    if (!value.has(id)) {\n      if (removedId != null) return\n\n      removedId = id\n    }\n  }\n\n  if (addedId == null && removedId == null) return\n\n  clearTimeout(timer.expand)\n\n  transferring.value = false\n  expanding.value = true\n\n  let baseExpandedIds: Set<Key> | undefined\n\n  if (addedId != null) {\n    baseExpandedIds = prev\n  }\n\n  if (removedId != null) {\n    if (!baseExpandedIds) {\n      baseExpandedIds = value\n    } else {\n      baseExpandedIds = new Set(baseExpandedIds)\n      baseExpandedIds.delete(removedId)\n    }\n  }\n\n  const baseNodes = flatNodes(treeNodes.value, baseExpandedIds!)\n\n  const virtual = props.virtual\n  const viewHeight = wrapper.value.offsetHeight\n  const nodeHeight = props.nodeMinHeight || 1\n  const viewCount = Math.ceil(viewHeight / nodeHeight) + 1\n\n  const loop = [\n    addedId != null && {\n      id: addedId,\n      type: 'expand'\n    },\n    removedId != null && {\n      id: removedId,\n      type: 'reduce'\n    }\n  ]\n\n  for (const meta of loop) {\n    if (!meta) continue\n\n    const { id, type } = meta\n    const index = baseNodes.findIndex(node => node.id === id)\n\n    if (~index) {\n      const children = baseNodes[index].children\n\n      if (children?.length) {\n        const addedNodes = flatNodes(children, value)\n\n        baseNodes.splice(index + 1, 0, {\n          id: Symbol(''),\n          collapse: true,\n          type,\n          height: virtual ? addedNodes.length * nodeHeight : undefined,\n          nodes: virtual ? addedNodes.slice(0, viewCount) : addedNodes\n        } as any)\n      }\n    }\n  }\n\n  expandingNodes.value = baseNodes\n})\n\nprovide(\n  TREE_STATE,\n  reactive({\n    arrow: toRef(props, 'arrow'),\n    checkbox: toRef(props, 'checkbox'),\n    suffixCheckbox: toRef(props, 'suffixCheckbox'),\n    noCascaded: toRef(props, 'noCascaded'),\n    linkLine,\n    virtual: toRef(props, 'virtual'),\n    labelKey: toRef(keyConfig, 'label'),\n    draggable: toRef(props, 'draggable'),\n    floorSelect: toRef(props, 'floorSelect'),\n    renderer: toRef(props, 'renderer'),\n    prefixRenderer: toRef(props, 'prefixRenderer'),\n    suffixRenderer: toRef(props, 'suffixRenderer'),\n    arrowIcon: toRef(props, 'arrowIcon'),\n    blockEffect: toRef(props, 'blockEffect'),\n    dragging,\n    boundAsyncLoad,\n    nodeStates,\n    expanding,\n    getParentNode,\n    updateVisibleNodeEls,\n    computeCheckedState,\n    handleNodeClick,\n    handleNodeSelect,\n    handleNodeCancel,\n    handleNodeExpand,\n    handleNodeReduce,\n    handleAsyncLoad,\n    handleNodeDragStart,\n    handleNodeDragOver,\n    handleNodeDrop,\n    handleNodeDragEnd,\n    handleHittingChange,\n    handleNodeHitting,\n    handleLabelClick\n  })\n)\nprovide(\n  TREE_NODE_STATE,\n  reactive({\n    depth: -1,\n    disabled: toRef(props, 'disabled'),\n    readonly: toRef(props, 'readonly')\n  })\n)\n\ndefineExpose({\n  treeNodes,\n  flattedNodes,\n  dragging,\n  expanding,\n\n  virtualList,\n  trap,\n  indicator,\n\n  refreshScroll,\n  isLeafNode,\n  parseAndTransformData,\n  forceUpdateData,\n  syncNodeStateIntoData,\n  getCheckedNodes,\n  getCheckedNodeData,\n  getSelectedNodes,\n  getSelectedNodeData,\n  getExpandedNodes,\n  getDisabledNodes,\n  getParentNode,\n  getNodeChildren,\n  getSiblingNodes,\n  getPrevSiblingNode,\n  getNextSiblingNode,\n  getNodeByData,\n  expandNodeByData,\n  selectNodeByData,\n  checkNodeByData,\n  toggleNodeLoadingByData,\n  toggleAllExpanded,\n  getTreeData,\n  getFlattedData,\n  updateVisibleNodeEls\n})\n\nonMounted(updateVisibleNodeEls)\n\nconst { updateCheckedUpward, updateCheckedDown } = useCascadedChecked({\n  getNode: key => (isNullish(key) ? undefined : nodeMap.get(key)),\n  disableNode: node => node.disabled\n})\n\nfunction getIndexId() {\n  return `__poc-tree-key-${getGlobalCount()}`\n}\n\nfunction isLeafNode(node: TreeNodeProps) {\n  const isLeaf = node.isLeaf\n\n  let leafSign: boolean | 'auto' = 'auto'\n  let asyncLoad = false\n\n  if (isNullish(isLeaf) || isLeaf === 'auto') {\n    leafSign = 'auto'\n    asyncLoad = boundAsyncLoad.value\n  } else {\n    leafSign = isLeaf\n  }\n\n  return leafSign === 'auto' ? !(node.children?.length || (asyncLoad && !node.loaded)) : !!leafSign\n}\n\nfunction flatNodes(nodes: TreeNodeProps[], expandedIds?: Set<Key>) {\n  const rootNodes = new Set(nodes)\n\n  return flatTree(nodes, {\n    keyField: 'id',\n    parentField: 'parent',\n    childField: 'children',\n    injectId: false,\n    depthFirst: true,\n    cascaded: true,\n    filter: node => {\n      if (rootNodes.has(node)) {\n        return node.matched || node.childMatched || node.upperMatched\n      }\n\n      const parentNode = getParentNode(node)\n\n      return (\n        node.visible &&\n        (node.matched || node.childMatched || node.upperMatched) &&\n        (!parentNode || (expandedIds ? expandedIds.has(parentNode.id) : parentNode.expanded))\n      )\n    }\n  })\n}\n\nfunction isCollapse(node: any): node is TreeCollapseProps {\n  return node.collapse\n}\n\nfunction refreshNodesDepth() {\n  walkTree(treeNodes.value, (node, depth) => {\n    node.depth = depth\n    node.lineIndexes = [0]\n\n    if (node.parent && nodeMap.has(node.parent)) {\n      const parent = nodeMap.get(node.parent)!\n\n      node.last = getLast(parent.children) === node\n      node.upstreamLast = [parent.last, ...parent.upstreamLast]\n    } else {\n      node.last = getLast(treeNodes.value) === node\n      node.upstreamLast = []\n    }\n\n    for (let i = 1; i < depth; ++i) {\n      if (!node.upstreamLast[i - 1]) {\n        node.lineIndexes.push(i)\n      }\n    }\n  })\n}\n\nfunction buildTreeNodes(nodes: TreeNodeProps[]) {\n  treeNodes.value = transformTree(nodes, {\n    keyField: 'id',\n    parentField: 'parent',\n    childField: 'children',\n    rootId: props.rootId\n  })\n\n  refreshNodesDepth()\n}\n\nfunction parseAndTransformData() {\n  const idKey = keyConfig.id\n  const oldDataMap = new Map<Data, TreeNodeProps>()\n  const oldIdMap = new Map<any, TreeNodeProps>()\n\n  for (const node of nodeMap.values()) {\n    oldDataMap.set(node.data, node)\n    oldIdMap.set(node.data[idKey], node)\n  }\n\n  nodeMap.clear()\n  nodeDataMap.clear()\n\n  const nodes: TreeNodeProps[] = []\n\n  if (props.noBuildTree) {\n    walkTree(\n      props.data,\n      (item, _, parent) => {\n        const oldNode = oldDataMap.get(item)\n        const id = oldNode?.id ?? getIndexId()\n        const node = props.cacheNode ? (oldNode ?? createNodeItem(item)) : createNodeItem(item, oldNode)\n\n        node.id = id\n        node.parent = parent ? nodeDataMap.get(parent)?.id : undefined\n\n        nodeMap.set(node.id, node)\n        nodes.push(node)\n        nodeDataMap.set(item, node)\n      },\n      {\n        childField: keyConfig.children,\n        depthFirst: true\n      }\n    )\n  } else {\n    const data = props.data\n\n    for (let i = 0, len = data.length; i < len; ++i) {\n      const item = data[i]\n      const oldNode = oldDataMap.get(item) ?? oldIdMap.get(item[idKey])\n      const node = props.cacheNode ? (oldNode ?? createNodeItem(item)) : createNodeItem(item, oldNode)\n\n      nodeMap.set(node.id, node)\n      nodes.push(node)\n      nodeDataMap.set(item, node)\n    }\n  }\n\n  buildTreeNodes(nodes)\n\n  if (!props.noCascaded) {\n    const checkedNodes = flattedNodes.value.filter(item => item.checked)\n\n    for (let i = 0, len = checkedNodes.length; i < len; ++i) {\n      const item = checkedNodes[i]\n      const parentKey = item.parent\n\n      updateCheckedDown(item.id)\n\n      if (parentKey && nodeMap.has(parentKey)) {\n        const parent = nodeMap.get(parentKey)!\n\n        if (!parent.checked) {\n          updateCheckedUpward(item.id)\n        }\n      }\n    }\n  }\n\n  resetExpanded()\n}\n\nfunction forceUpdateData() {\n  const nodes: TreeNodeProps[] = []\n\n  const {\n    id: idKey,\n    visible: visibleKey,\n    selected: selectedKey,\n    expanded: expandedKey,\n    disabled: disabledKey,\n    checked: checkedKey,\n    loading: loadingKey,\n    loaded: loadedKey,\n    loadFail: loadFailKey,\n    readonly: readonlyKey,\n    arrow: arrowKey,\n    checkbox: checkboxKey,\n    selectDisabled: selectDisabledKey,\n    expandDisabled: expandDisabledKey,\n    checkDisabled: checkDisabledKey,\n    isLeaf: isLeafKey\n  } = keyConfig\n\n  const refresh = (node: TreeNodeProps, item: Data) => {\n    const {\n      [visibleKey]: visible = node.visible,\n      [selectedKey]: selected = node.selected,\n      [expandedKey]: expanded = node.expanded,\n      [disabledKey]: disabled = node.disabled,\n      [checkedKey]: checked = node.checked,\n      [loadingKey]: loading = node.loading,\n      [loadedKey]: loaded = node.loaded,\n      [loadFailKey]: loadFail = node.loadFail,\n      [readonlyKey]: readonly = node.readonly,\n      [arrowKey]: arrow = node.arrow,\n      [checkboxKey]: checkbox = node.checkbox,\n      [selectDisabledKey]: selectDisabled = node.selectDisabled,\n      [expandDisabledKey]: expandDisabled = node.expandDisabled,\n      [checkDisabledKey]: checkDisabled = node.checkDisabled,\n      [isLeafKey]: isLeaf = node.isLeaf\n    } = item\n\n    node.visible = visible\n    node.selected = selected\n    node.expanded = expanded\n    node.disabled = disabled\n    node.checked = checked\n    node.loading = loading\n    node.loaded = loaded\n    node.loadFail = loadFail\n    node.readonly = readonly\n    node.arrow = arrow\n    node.checkbox = checkbox\n    node.selectDisabled = selectDisabled\n    node.expandDisabled = expandDisabled\n    node.checkDisabled = checkDisabled\n    node.isLeaf = isLeaf\n  }\n\n  if (props.noBuildTree) {\n    walkTree(\n      props.data,\n      (item, _, parent) => {\n        let node = nodeDataMap.get(item)\n\n        if (node) {\n          refresh(node, item)\n        } else {\n          node = createNodeItem(item)\n          node.id = getIndexId()\n          node.parent = parent ? nodeDataMap.get(parent)?.id : undefined\n\n          nodeMap.set(node.id, node)\n          nodeDataMap.set(item, node)\n        }\n\n        nodes.push(node)\n      },\n      {\n        childField: keyConfig.children,\n        depthFirst: true\n      }\n    )\n  } else {\n    const data = props.data\n\n    for (let i = 0, len = data.length; i < len; ++i) {\n      const item = data[i]\n      const id = item[idKey] as Key\n\n      let node = nodeMap.get(id)\n\n      if (node) {\n        refresh(node, item)\n      } else {\n        node = createNodeItem(item)\n        nodeMap.set(id, node)\n      }\n\n      nodes.push(node)\n    }\n  }\n\n  buildTreeNodes(nodes)\n  resetExpanded()\n}\n\nfunction syncNodeStateIntoData() {\n  flattedNodes.value.forEach(node => {\n    if (!node.data) return\n\n    const { data, visible, selected, expanded, disabled, checked, loading, readonly } = node\n\n    data.visible = visible\n    data.selected = selected\n    data.expanded = expanded\n    data.disabled = disabled\n    data.checked = checked\n    data.loading = loading\n    data.readonly = readonly\n  })\n\n  resetExpanded()\n}\n\nfunction createNodeItem(data: Data, defaults = defaultNodeProperties): TreeNodeProps {\n  const {\n    id: idKey,\n    parent: parentKey,\n    visible: visibleKey,\n    selected: selectedKey,\n    expanded: expandedKey,\n    disabled: disabledKey,\n    checked: checkedKey,\n    loading: loadingKey,\n    loaded: loadedKey,\n    loadFail: loadFailKey,\n    readonly: readonlyKey,\n    arrow: arrowKey,\n    checkbox: checkboxKey,\n    selectDisabled: selectDisabledKey,\n    expandDisabled: expandDisabledKey,\n    checkDisabled: checkDisabledKey,\n    isLeaf: isLeafKey\n  } = keyConfig\n\n  const {\n    [visibleKey]: visible = defaults.visible,\n    [selectedKey]: selected = defaults.selected,\n    [expandedKey]: expanded = defaults.expanded,\n    [disabledKey]: disabled = defaults.disabled,\n    [checkedKey]: checked = defaults.checked,\n    [loadingKey]: loading = defaults.loading,\n    [loadedKey]: loaded = defaults.loaded,\n    [loadFailKey]: loadFail = defaults.loadFail,\n    [readonlyKey]: readonly = defaults.readonly,\n    [arrowKey]: arrow = defaults.arrow,\n    [checkboxKey]: checkbox = defaults.checkbox,\n    [selectDisabledKey]: selectDisabled = defaults.selectDisabled,\n    [expandDisabledKey]: expandDisabled = defaults.expandDisabled,\n    [checkDisabledKey]: checkDisabled = defaults.checkDisabled,\n    [isLeafKey]: isLeaf = defaults.isLeaf\n  } = data\n  const id = props.noBuildTree ? null : data[idKey]\n  const parent = props.noBuildTree ? null : data[parentKey]\n\n  const node = {\n    id,\n    parent,\n    data,\n    visible,\n    selected,\n    expanded,\n    disabled,\n    checked,\n    loading,\n    loaded,\n    loadFail,\n    readonly,\n    arrow,\n    checkbox,\n    selectDisabled,\n    expandDisabled,\n    checkDisabled,\n    isLeaf\n  }\n\n  if (typeof props.postCreate === 'function') {\n    props.postCreate(node as TreeNodeProps)\n  }\n\n  return reactive({\n    ...node,\n    id,\n    parent,\n    children: [],\n    partial: false,\n    matched: false,\n    childMatched: false,\n    upperMatched: false,\n    depth: -1,\n    last: false,\n    upstreamLast: [],\n    lineIndexes: []\n  })\n}\n\nfunction computeCheckedState(originNode: TreeNodeProps, able: boolean) {\n  if (!props.noCascaded) {\n    const nodeList = [originNode].concat(\n      // 需要包含被禁用且被勾选的节点\n      flattedNodes.value.filter(item => (item.disabled || item.checkDisabled) && item.checked)\n    )\n\n    for (let i = 0, len = nodeList.length; i < len; ++i) {\n      const item = nodeList[i]\n\n      updateCheckedUpward(item.id)\n      updateCheckedDown(item.id)\n    }\n  }\n\n  emitEvent(props.onNodeChange, originNode.data, originNode, able)\n}\n\nfunction handleNodeClick(node: TreeNodeProps) {\n  emitEvent(props.onNodeClick, node.data, node)\n}\n\nfunction handleLabelClick(node: TreeNodeProps) {\n  emitEvent(props.onLabelClick, node.data, node)\n}\n\nfunction handleNodeSelect(node: TreeNodeProps) {\n  const selectedNodes = flattedNodes.value.filter(item => item.selected)\n\n  if (props.multiple) {\n    emitEvent(\n      props.onNodeSelect,\n      selectedNodes.map(item => item.data),\n      selectedNodes\n    )\n  } else {\n    const currentId = node.id\n\n    for (let i = 0, len = selectedNodes.length; i < len; ++i) {\n      const item = selectedNodes[i]\n\n      item.selected = item.id === currentId\n    }\n\n    emitEvent(props.onNodeSelect, node.data, node)\n  }\n}\n\nfunction handleNodeCancel(node: TreeNodeProps) {\n  emitEvent(props.onNodeCancel, node.data, node)\n}\n\nfunction handleNodeExpand(node: TreeNodeProps) {\n  if (props.accordion) {\n    const siblingNodes = getSiblingNodes(node)\n\n    for (let i = 0, len = siblingNodes.length; i < len; ++i) {\n      siblingNodes[i].expanded = false\n    }\n  }\n\n  emitEvent(props.onNodeExpand, node.data, node)\n}\n\nfunction handleNodeReduce(node: TreeNodeProps) {\n  emitEvent(props.onNodeReduce, node.data, node)\n}\n\nasync function handleAsyncLoad(node: TreeNodeProps) {\n  if (!boundAsyncLoad.value) return false\n\n  let result = props.onAsyncLoad(node.data, node)\n\n  if (isPromise(result)) {\n    result = await result\n  }\n\n  return result !== false\n}\n\nlet dragState: {\n  draggingNode: TreeNodeProps,\n  treeRect: DOMRect,\n  willDropNode: TreeNodeProps | null,\n  dropType: DropType\n} | null = null\n\nfunction handleNodeDragStart(nodeInstance: TreeNodeInstance) {\n  if (!wrapper.value) return\n\n  dragState = {\n    draggingNode: nodeInstance.node,\n    treeRect: wrapper.value.getBoundingClientRect(),\n    willDropNode: null,\n    dropType: DropType.BEFORE\n  }\n\n  dragging.value = true\n  emitEvent(props.onDragStart, nodeInstance.node.data, nodeInstance.node)\n}\n\nfunction handleNodeDragOver(nodeInstance: TreeNodeInstance, event: DragEvent) {\n  if (!dragState || !nodeInstance.el || !nodeInstance.arrow) return\n\n  const dropNodeRect = nodeInstance.el.getBoundingClientRect()\n  const treeRect = dragState.treeRect\n  const dropArrowRect = nodeInstance.arrow.getBoundingClientRect()\n  const prevPercent = 0.25\n  const nextPercent = 0.75\n  const distance = event.clientY - dropNodeRect.top\n  const dropNodeHeight = dropArrowRect.height\n\n  let dropType: DropType\n  let indicatorTop = -9999\n  let isIndicatorShow = true\n\n  if (distance < dropNodeHeight * prevPercent) {\n    dropType = DropType.BEFORE\n    indicatorTop = dropArrowRect.top - treeRect.top\n  } else if (distance > dropNodeHeight * nextPercent) {\n    dropType = DropType.AFTER\n    indicatorTop = dropArrowRect.bottom - treeRect.top\n  } else {\n    dropType = DropType.INNER\n    isIndicatorShow = false\n  }\n\n  if (indicator.value) {\n    indicator.value.style.top = `${indicatorTop}px`\n    indicator.value.style.insetInlineStart = `${dropArrowRect.right - treeRect.left}px`\n  }\n\n  dragState.willDropNode = nodeInstance.node\n  dragState.dropType = dropType\n\n  indicatorShow.value = isIndicatorShow\n  emitEvent(props.onDragOver, nodeInstance.node.data, nodeInstance.node)\n}\n\nfunction isLeftInsideRight(left: TreeNodeProps, right: TreeNodeProps) {\n  if (!left || !right) return true\n\n  while (left) {\n    if (left === right || left.id === right.id) {\n      return true\n    }\n\n    left = getParentNode(left)!\n  }\n\n  return false\n}\n\nfunction handleNodeDrop(nodeInstance: TreeNodeInstance) {\n  if (!dragState) return\n\n  const { draggingNode, willDropNode, dropType } = dragState\n\n  if (!willDropNode || isLeftInsideRight(willDropNode, draggingNode)) return\n\n  let currentId: Key\n  let parent: TreeNodeProps | null\n\n  if (draggingNode) {\n    parent = getParentNode(draggingNode)\n\n    if (!parent) {\n      parent = {\n        children: treeNodes.value\n      } as TreeNodeProps\n    }\n\n    currentId = draggingNode.id as Key\n    removeArrayItem(parent.children, item => item.id === currentId)\n  }\n\n  if (dropType === DropType.INNER) {\n    if (!Array.isArray(willDropNode.children)) {\n      willDropNode.children = []\n    }\n\n    const children = Array.from(willDropNode.children as TreeNodeProps[])\n\n    children.push(draggingNode)\n\n    willDropNode.children = children\n    draggingNode.parent = willDropNode.id\n  } else {\n    parent = getParentNode(willDropNode)\n\n    if (!parent) {\n      parent = {\n        parent: undefined! as Key,\n        children: treeNodes.value\n      } as TreeNodeProps\n    }\n\n    currentId = willDropNode.id\n    const index = parent.children.findIndex(item => item.id === currentId)\n\n    if (~index) {\n      parent.children.splice(+(dropType === DropType.AFTER) + index, 0, draggingNode)\n\n      draggingNode.parent = parent.id\n    }\n  }\n\n  refreshNodesDepth()\n  emitEvent(props.onDrop, nodeInstance.node.data, nodeInstance.node, dropType)\n}\n\nfunction handleNodeDragEnd(nodeInstance: TreeNodeInstance) {\n  dragging.value = true\n  indicatorShow.value = false\n  dragState = null\n  emitEvent(props.onDragEnd, nodeInstance.node.data, nodeInstance.node)\n}\n\nfunction handleHittingChange(type: 'up' | 'down') {\n  const activeEl = document.activeElement\n\n  if (!visibleNodeEls.length || !activeEl) return\n\n  const index = visibleNodeEls.findIndex(nodeEl => nodeEl === activeEl)\n\n  if (~index) {\n    visibleNodeEls[(index + (type === 'up' ? -1 : 1) + visibleNodeEls.length) % visibleNodeEls.length]?.focus()\n  }\n}\n\nfunction handleNodeHitting(nodeEl?: HTMLElement | null) {\n  if (!nodeEl || !visibleNodeEls.length) return\n\n  if (visibleNodeEls.includes(nodeEl)) {\n    nodeEl.focus()\n  }\n}\n\nfunction handleScroll() {\n  // onScroll()\n  updateVisibleNodeEls()\n}\n\nfunction handleTreeFocus(event: FocusEvent) {\n  const target = event.target as HTMLElement\n\n  if (!visibleNodeEls.length || !target || !trap.value) {\n    return\n  }\n\n  if (target === trap.value) {\n    visibleNodeEls[0].focus()\n  }\n}\n\nfunction refreshScroll() {\n  virtualList.value?.refresh()\n}\n\nfunction resetExpanded() {\n  expanding.value = false\n  isMounted.value && updateVisibleNodeEls()\n}\n\nfunction afterExpand() {\n  if (props.virtual) {\n    resetExpanded()\n    return\n  }\n\n  transferring.value = true\n\n  requestAnimationFrame(() => {\n    resetExpanded()\n    timer.expand = setTimeout(() => {\n      transferring.value = false\n    }, 300)\n  })\n}\n\nfunction getCheckedNodes(includePartial = false): TreeNodeProps[] {\n  return flattedNodes.value.filter(item => item.checked || (includePartial && item.partial))\n}\n\nfunction getCheckedNodeData(includePartial = false) {\n  return getCheckedNodes(includePartial).map(node => node.data)\n}\n\nfunction getSelectedNodes(): TreeNodeProps[] {\n  return flattedNodes.value.filter(item => item.selected)\n}\n\nfunction getSelectedNodeData() {\n  return getSelectedNodes().map(node => node.data)\n}\n\nfunction getExpandedNodes(): TreeNodeProps[] {\n  return flattedNodes.value.filter(item => item.expanded)\n}\n\nfunction getDisabledNodes(): TreeNodeProps[] {\n  return flattedNodes.value.filter(item => item.disabled)\n}\n\nfunction getParentNode(node: TreeNodeProps): TreeNodeProps | null {\n  if (node.parent) {\n    return nodeMap.get(node.parent) ?? null\n  }\n\n  return null\n}\n\nfunction getNodeChildren(node: TreeNodeProps) {\n  return node.children\n}\n\nfunction getSiblingNodes(node: TreeNodeProps, includeSelf = false): TreeNodeProps[] {\n  const parent = getParentNode(node)\n\n  const currentId = node.id as Key\n  const parentId = parent ? (parent.id as Key) : null\n\n  return flattedNodes.value.filter(item => {\n    const isChild = parentId === null ? !item.parent : item.parent === parentId\n\n    if (isChild && !includeSelf) {\n      return item.id !== currentId\n    }\n\n    return isChild\n  })\n}\n\nfunction getPrevSiblingNode(node: TreeNodeProps): TreeNodeProps | null {\n  const parent = getParentNode(node)\n\n  if (!parent) return null\n\n  const currentId = node.id\n  const parentId = parent.id\n  const children = flattedNodes.value.filter(item => item.parent === parentId)\n\n  if (children && children.length) {\n    const index = children.findIndex(item => item.id === currentId)\n\n    if (index > 0) {\n      return children[index - 1]\n    }\n  }\n\n  return null\n}\n\nfunction getNextSiblingNode(node: TreeNodeProps): TreeNodeProps | null {\n  const parent = getParentNode(node)\n\n  if (!parent) return null\n\n  const currentId = node.id\n  const parentId = parent.id\n  const children = flattedNodes.value.filter(item => item.parent === parentId)\n\n  if (children && children.length) {\n    const index = children.findIndex(item => item.id === currentId)\n\n    if (!~index && index < children.length - 1) {\n      return children[index + 1]\n    }\n  }\n\n  return null\n}\n\nfunction getNodeByData<T extends Data>(data: T): TreeNodeProps | null {\n  if (props.noBuildTree) {\n    return flattedNodes.value.find(item => item.data === data) ?? null\n  }\n\n  const idKey = keyConfig.id\n\n  return flattedNodes.value.find(item => item.data === data || item.data[idKey] === data[idKey as keyof T]) ?? null\n}\n\nfunction expandNodeByData<T extends Data>(data: T, expanded?: boolean, upstream = false) {\n  const node = getNodeByData(data)\n\n  if (node) {\n    node.expanded = isNullish(expanded) ? !node.expanded : !!expanded\n\n    if (upstream) {\n      let parentNode = getParentNode(node)\n\n      while (parentNode) {\n        parentNode.expanded = node.expanded\n        parentNode = getParentNode(parentNode)\n      }\n    }\n  }\n}\n\nfunction selectNodeByData<T extends Data>(data: T, selected?: boolean) {\n  const node = getNodeByData(data)\n\n  if (node) {\n    node.selected = isNullish(selected) ? !node.selected : !!selected\n  }\n}\n\nfunction checkNodeByData<T extends Data>(data: T, checked?: boolean) {\n  const node = getNodeByData(data)\n\n  if (node) {\n    node.checked = isNullish(checked) ? !node.checked : !!checked\n\n    if (!props.noCascaded) {\n      const nodeList = [node].concat(flattedNodes.value.filter(item => item.disabled && item.checked))\n\n      for (let i = 0, len = nodeList.length; i < len; ++i) {\n        const item = nodeList[i]\n\n        updateCheckedUpward(item.id)\n        updateCheckedDown(item.id)\n      }\n    }\n  }\n}\n\nfunction toggleNodeLoadingByData<T extends Data>(data: T, loading?: boolean) {\n  const node = getNodeByData(data)\n\n  if (node) {\n    node.checked = isNullish(loading) ? !node.loading : !!loading\n  }\n}\n\nfunction toggleAllExpanded(expanded: boolean) {\n  for (const node of flattedNodes.value) {\n    if (!node.disabled && !node.expandDisabled && !node.loading && node.children?.length) {\n      node.expanded = expanded\n    }\n  }\n}\n\nfunction getTreeData(withFilter = false) {\n  return mapTree(\n    withFilter\n      ? filterTree(treeNodes.value, node => node.matched, {\n        childField: 'children',\n        leafOnly: props.filterLeaf,\n        isLeaf: isLeafNode\n      })\n      : treeNodes.value,\n    node => ({ ...node.data })\n  )\n}\n\nfunction getFlattedData(withFilter = false) {\n  return (\n    withFilter\n      ? flattedNodes.value.filter(node => node.matched || node.childMatched || node.upperMatched)\n      : flattedNodes.value\n  ).map(node => ({ ...node.data }))\n}\n\nconst transferring = ref(false)\n</script>\n\n<template>\n  <VirtualList\n    ref=\"virtualList\"\n    :class=\"[nh.b(), nh.bs('vars'), props.inherit && nh.inc()]\"\n    :inherit=\"props.inherit\"\n    :items=\"renderedNodes\"\n    :item-size=\"props.nodeMinHeight\"\n    items-tag=\"ul\"\n    :items-attrs=\"{ class: nh.be('list') }\"\n    :hide-bar=\"!props.useYBar\"\n    :ignore-resize=\"transferring\"\n    role=\"tree\"\n    tabindex=\"-1\"\n    :aria-disabled=\"props.disabled\"\n    :aria-readonly=\"props.readonly\"\n    :style=\"style\"\n    @scroll=\"handleScroll\"\n  >\n    <template #prefix-trap>\n      <span\n        ref=\"trap\"\n        tabindex=\"0\"\n        aria-hidden=\"true\"\n        style=\"width: 0; height: 0; overflow: hidden; outline: none\"\n        @focus=\"handleTreeFocus\"\n      ></span>\n    </template>\n    <template #default=\"data: any\">\n      <CollapseTransition\n        v-if=\"isCollapse(data.item)\"\n        appear\n        :reverse=\"data.item.type === 'reduce'\"\n        @after-enter=\"afterExpand\"\n      >\n        <div :class=\"nh.be('collapse')\" :style=\"{ height: `${data.item.height}px` }\">\n          <TreeNode\n            v-for=\"(innerNode, index) in data.item.nodes\"\n            :key=\"innerNode.id ?? index\"\n            v-bind=\"toNodeProps(innerNode.data, innerNode)\"\n            :node=\"innerNode\"\n          >\n            <template #default=\"payload\">\n              <slot name=\"node\" v-bind=\"payload\"></slot>\n            </template>\n            <template v-if=\"$slots.arrow\" #arrow=\"payload\">\n              <slot name=\"arrow\" v-bind=\"payload\"></slot>\n            </template>\n            <template #label=\"payload\">\n              <slot name=\"label\" v-bind=\"payload\"></slot>\n            </template>\n            <template v-if=\"$slots.prefix\" #prefix=\"payload\">\n              <slot name=\"prefix\" v-bind=\"payload\"></slot>\n            </template>\n            <template v-if=\"$slots.suffix\" #suffix=\"payload\">\n              <slot name=\"suffix\" v-bind=\"payload\"></slot>\n            </template>\n          </TreeNode>\n        </div>\n      </CollapseTransition>\n      <TreeNode v-else v-bind=\"toNodeProps(data.item.data, data.item)\" :node=\"data.item\">\n        <template #default=\"payload\">\n          <slot name=\"node\" v-bind=\"payload\"></slot>\n        </template>\n        <template v-if=\"$slots.arrow\" #arrow=\"payload\">\n          <slot name=\"arrow\" v-bind=\"payload\"></slot>\n        </template>\n        <template #label=\"payload\">\n          <slot name=\"label\" v-bind=\"payload\"></slot>\n        </template>\n        <template v-if=\"$slots.prefix\" #prefix=\"payload\">\n          <slot name=\"prefix\" v-bind=\"payload\"></slot>\n        </template>\n        <template v-if=\"$slots.suffix\" #suffix=\"payload\">\n          <slot name=\"suffix\" v-bind=\"payload\"></slot>\n        </template>\n      </TreeNode>\n    </template>\n    <template #empty>\n      <div :class=\"nh.be('empty-tip')\">\n        <slot name=\"empty\">\n          {{ props.emptyText ?? locale.empty }}\n        </slot>\n      </div>\n    </template>\n    <template #suffix-trap>\n      <div\n        v-if=\"props.draggable\"\n        v-show=\"indicatorShow\"\n        ref=\"indicator\"\n        :class=\"nh.be('indicator')\"\n      ></div>\n    </template>\n  </VirtualList>\n</template>\n"
    }
  ],
  "dependencies": ["@pocui/utils", "vue", "@pocui/config", "@pocui/hooks"],
  "registryDependencies": [
    "tree.scss",
    "checkbox",
    "icon",
    "renderer",
    "collapse-transition",
    "virtual-list"
  ],
  "categories": ["display"],
  "meta": { "isReferenceOnly": false }
}
