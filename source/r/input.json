{
  "name": "input",
  "type": "registry:components",
  "description": "通过键入内容输入数据，是最基础的表单域的包装。",
  "files": [
    {
      "target": "components/input/index.ts",
      "content": "export { default as Input } from './input'\nexport { inputProps } from './props'\n\nexport type { InputProps, InputCProps } from './props'\nexport type { InputType, InputExposed } from './symbol'\n"
    },
    {
      "target": "components/input/input.tsx",
      "content": "import { useFieldStore } from '@/components/form'\nimport { Icon } from '@/components/icon'\n\nimport { SlotsType, Transition, computed, defineComponent, nextTick, ref, renderSlot, toRef, watch } from 'vue'\n\nimport {\n  createIconProp,\n  createSizeProp,\n  createStateProp,\n  emitEvent,\n  useIcons,\n  useLocale,\n  useNameHelper,\n  useProps\n} from '@pocui/config'\n\nimport { useHover } from '@pocui/hooks'\nimport { debounce, isNullish, noop, throttle, toNumber } from '@pocui/utils'\n\nimport { inputProps } from './props'\n\nimport type { ChangeEvent, InputType } from './symbol'\n\ntype InputEventType = 'input' | 'change'\n\nconst inputTypes = Object.freeze<InputType[]>(['text', 'password', 'date', 'datetime', 'time'])\n\nfunction toNotNullString(value: any) {\n  return isNullish(value) ? '' : String(value)\n}\n\nexport default defineComponent({\n  name: 'Input',\n  description: '通过键入内容输入数据，是最基础的表单域的包装。',\n  categories: ['form'],\n  props: inputProps,\n  emits: ['update:value'],\n  slots: Object as SlotsType<{\n    prefix(): any,\n    suffix(): any,\n    before(): any,\n    after(): any,\n    count?(props: { value: string }): any,\n    password?(props: { plain: boolean }): any,\n    beforeAction(): any,\n    'before-action'(): any,\n    afterAction(): any,\n    'after-action'(): any\n  }>,\n  setup(_props, { slots, emit, expose }) {\n    const { idFor, labelId, state, disabled, loading, size, validateField, clearField, getFieldValue, setFieldValue } =\n      useFieldStore<string | number>(() => inputControl.value?.focus())\n\n    const props = useProps('input', _props, {\n      size: createSizeProp(size),\n      state: createStateProp(state),\n      locale: null,\n      type: {\n        default: 'text',\n        validator: value => inputTypes.includes(value)\n      },\n      prefix: createIconProp(),\n      prefixColor: '',\n      suffix: createIconProp(),\n      suffixColor: '',\n      formatter: {\n        default: null,\n        isFunc: true\n      },\n      value: {\n        default: () => getFieldValue(),\n        static: true\n      },\n      placeholder: null,\n      autofocus: false,\n      spellcheck: false,\n      autocomplete: false,\n      readonly: false,\n      disabled: () => disabled.value,\n      controlClass: null,\n      debounce: false,\n      delay: null,\n      maxLength: 0,\n      before: '',\n      after: '',\n      plainPassword: false,\n      clearable: false,\n      loading: () => loading.value,\n      loadingIcon: createIconProp(),\n      loadingLock: false,\n      loadingEffect: null,\n      transparent: false,\n      sync: false,\n      controlAttrs: null,\n      name: {\n        default: '',\n        static: true\n      }\n    })\n    const initValue = toNotNullString(props.value)\n    const nh = useNameHelper('input')\n    const icons = useIcons()\n    const focused = ref(false)\n    const currentValue = ref(initValue)\n    const showPassword = ref(false)\n    const currentLength = ref(initValue.length)\n    const beforeHover = ref(false)\n    const afterHover = ref(false)\n    const composing = ref(false)\n\n    const inputControl = ref<HTMLInputElement>()\n\n    const { wrapper: control, isHover } = useHover()\n    const locale = useLocale('input', toRef(props, 'locale'))\n\n    let lastValue = props.value\n\n    const hasBefore = computed(() => {\n      return !!(slots.before || slots.beforeAction || slots['before-action'] || props.before)\n    })\n    const hasAfter = computed(() => {\n      return !!(slots.after || slots.afterAction || slots['after-action'] || props.after)\n    })\n    const basisClass = computed(() => {\n      return {\n        [nh.bs('wrapper')]: true,\n        [nh.bs('vars')]: true,\n        [nh.in()]: props.inherit,\n        [nh.bm(props.size)]: props.size !== 'default'\n      }\n    })\n    const readonly = computed(() => (props.loading && props.loadingLock) || props.readonly)\n    const className = computed(() => {\n      return [\n        nh.b(),\n        nh.bm(props.type),\n        !hasBefore.value && !hasAfter.value && basisClass.value,\n        {\n          [nh.bm('focused')]: focused.value,\n          [nh.bm('disabled')]: props.disabled,\n          [nh.bm('readonly')]: readonly.value,\n          [nh.bm('loading')]: props.loading,\n          [nh.bm(props.state)]: props.state !== 'default',\n          [nh.bm('before')]: slots.beforeAction || slots['before-action'],\n          [nh.bm('after')]: slots.afterAction || slots['after-action'],\n          [nh.bm('transparent')]: props.transparent,\n          [nh.bm('plain-password')]: props.plainPassword\n        }\n      ]\n    })\n    const wrapperClass = computed(() => {\n      return {\n        ...basisClass.value,\n        [nh.bm(`wrapper--${props.size}`)]: props.size !== 'default',\n        [nh.bs('wrapper--before-only')]: hasBefore.value && !hasAfter.value,\n        [nh.bs('wrapper--after-only')]: !hasBefore.value && hasAfter.value,\n        [nh.bm('transparent')]: props.transparent\n      }\n    })\n    const hasPrefix = computed(() => !!(slots.prefix || props.prefix))\n    const hasSuffix = computed(() => !!(slots.suffix || props.suffix))\n    const inputType = computed(() => {\n      const type = props.type\n\n      if (type === 'password') {\n        return showPassword.value ? 'text' : 'password'\n      }\n\n      if (type === 'datetime') {\n        return 'datetime-local'\n      }\n\n      return type\n    })\n    const formattedValue = computed(() => {\n      return typeof props.formatter === 'function'\n        ? toNotNullString(props.formatter(currentValue.value))\n        : currentValue.value\n    })\n    const passwordIcon = computed(() => (showPassword.value ? icons.value.plainText : icons.value.cipherText))\n    const hasValue = computed(() => {\n      return !(isNullish(currentValue.value) || currentValue.value === '')\n    })\n    const showClear = computed(() => {\n      return !props.disabled && !readonly.value && props.clearable && hasValue.value && isHover.value\n    })\n\n    watch(\n      () => props.value,\n      value => {\n        currentValue.value = toNotNullString(value)\n        lastValue = currentValue.value\n        limitValueLength()\n      }\n    )\n    watch(\n      [formattedValue, inputControl],\n      () => {\n        if (inputControl.value) {\n          inputControl.value.value = formattedValue.value\n        }\n      },\n      {\n        immediate: true,\n        flush: 'post'\n      }\n    )\n    // 在 methods 选项中需要定义一些相同名称和方法来支持推断类型\n    expose({\n      idFor,\n      labelId,\n      focused,\n      currentValue,\n      showPassword,\n      currentLength,\n      composing,\n      input: inputControl,\n      copyValue,\n      focus: (options?: FocusOptions) => {\n        inputControl.value?.focus(options)\n      },\n      blur: () => {\n        inputControl.value?.blur()\n      }\n    })\n\n    function handleFocus(event: FocusEvent) {\n      if (!focused.value) {\n        focused.value = true\n        emitEvent(props.onFocus, event)\n      }\n    }\n\n    function handleBlur(event: FocusEvent) {\n      if (focused.value) {\n        focused.value = false\n\n        setTimeout(() => {\n          if (!focused.value) {\n            emitEvent(props.onBlur, event)\n            emitChangeEvent('change')\n          }\n        }, 120)\n      }\n    }\n\n    function handleChange(event: Event) {\n      const type = event.type as InputEventType\n\n      if (composing.value) {\n        if (type === 'input') return\n\n        composing.value = false\n      }\n\n      currentValue.value = (event.target as HTMLInputElement).value\n      limitValueLength()\n\n      const value = currentValue.value\n\n      setValue(value, type)\n    }\n\n    function setValue(value: string, type: InputEventType, sync = props.sync) {\n      currentValue.value = value\n      emitChangeEvent(type, sync)\n    }\n\n    function emitChangeEvent(type: InputEventType, sync = props.sync) {\n      type = type === 'input' ? 'input' : 'change'\n\n      const value = typeof props.value === 'number' ? parseFloat(currentValue.value) : currentValue.value\n\n      if (type === 'change') {\n        if (lastValue === value) return\n\n        lastValue = value\n\n        if (!sync) {\n          emit('update:value', value)\n          setFieldValue(value)\n        }\n\n        emitEvent(props.onChange as ChangeEvent, value)\n\n        if (!sync) {\n          validateField()\n        }\n      } else {\n        if (sync) {\n          emit('update:value', value)\n          setFieldValue(value)\n        }\n\n        emitEvent(props.onInput as ChangeEvent, value)\n\n        if (sync) {\n          validateField()\n        }\n      }\n    }\n\n    function limitValueLength() {\n      let value = currentValue.value\n\n      if (isNullish(value)) {\n        currentLength.value = 0\n\n        return\n      }\n\n      const maxLength = props.maxLength\n\n      if (maxLength && value.length > maxLength) {\n        value = value.slice(0, maxLength)\n      }\n\n      currentLength.value = value.length\n      currentValue.value = value\n    }\n\n    function toggleShowPassword() {\n      if (props.disabled) {\n        return\n      }\n\n      showPassword.value = !showPassword.value\n      nextTick(() => {\n        inputControl.value?.focus()\n      })\n    }\n\n    function handleClear(event: MouseEvent) {\n      if (props.disabled || readonly.value) return\n\n      event.stopPropagation()\n      setValue('', 'change', false)\n      emitEvent(props.onClear)\n      nextTick(clearField)\n      currentLength.value = 0\n      inputControl.value?.focus()\n    }\n\n    function handleEnter() {\n      emitEvent(props.onEnter)\n    }\n\n    function handlePrefixClick(event: MouseEvent) {\n      emitEvent(props.onPrefixClick, event)\n    }\n\n    function handleSuffixClick(event: MouseEvent) {\n      emitEvent(props.onSuffixClick, event)\n    }\n\n    function handleKeyDown(event: KeyboardEvent) {\n      emitEvent(props.onKeyDown, event)\n    }\n\n    function handleKeyPress(event: KeyboardEvent) {\n      emitEvent(props.onKeyPress, event)\n    }\n\n    function handleKeyUp(event: KeyboardEvent) {\n      if (event.key === 'Enter') {\n        handleEnter()\n      }\n\n      emitEvent(props.onKeyUp, event)\n    }\n\n    function handleCompositionStart(event: CompositionEvent) {\n      composing.value = true\n      emitEvent(props.onCompositionStart, event)\n    }\n\n    function handleCompositionEnd(event: CompositionEvent) {\n      if (composing.value) {\n        composing.value = false\n\n        if (inputControl.value) {\n          inputControl.value.dispatchEvent(new Event('input'))\n        }\n      }\n\n      emitEvent(props.onCompositionStart, event)\n    }\n\n    function copyValue() {\n      const input = document.createElement('input')\n\n      input.style.height = '0'\n      input.setAttribute('readonly', 'readonly')\n      input.value = currentValue.value\n      document.body.appendChild(input)\n      input.select()\n\n      const isSuccess = document.execCommand('copy')\n\n      document.body.removeChild(input)\n\n      return isSuccess\n    }\n\n    function preventDefault(event: Event) {\n      event.preventDefault()\n    }\n\n    const delay = toNumber(props.delay)\n    const handleInput = props.debounce ? debounce(handleChange, delay || 100) : throttle(handleChange, delay || 16)\n\n    function renderPrefix() {\n      return (\n        <div class={[nh.be('icon'), nh.be('prefix')]} style={{ color: props.prefixColor }} onClick={handlePrefixClick}>\n          {renderSlot(slots, 'prefix', undefined, () => [<Icon icon={props.prefix}></Icon>])}\n        </div>\n      )\n    }\n\n    function renderCustomSuffix() {\n      if (hasSuffix.value) {\n        return (\n          <div\n            key='suffix'\n            class={[nh.be('icon'), nh.be('suffix')]}\n            style={{\n              color: props.suffixColor,\n              opacity: showClear.value || props.loading ? '0%' : ''\n            }}\n            onClick={handleSuffixClick}\n          >\n            {renderSlot(slots, 'suffix', undefined, () => [<Icon icon={props.suffix}></Icon>])}\n          </div>\n        )\n      }\n\n      if (props.clearable || props.loading) {\n        return <div key='placeholder' class={[nh.be('icon'), nh.bem('icon', 'placeholder')]}></div>\n      }\n\n      return null\n    }\n\n    function renderSuffixAction() {\n      if (showClear.value) {\n        return (\n          <button\n            key='clear'\n            class={[nh.be('icon'), nh.be('clear')]}\n            type='button'\n            tabindex={-1}\n            aria-label={locale.value.ariaLabel.clear}\n            onClick={handleClear}\n          >\n            <Icon {...icons.value.clear} label='clear'></Icon>\n          </button>\n        )\n      }\n\n      if (props.loading) {\n        return (\n          <div key='loading' class={[nh.be('icon'), nh.be('loading')]}>\n            <Icon\n              {...icons.value.loading}\n              effect={props.loadingEffect || icons.value.loading.effect}\n              icon={props.loadingIcon || icons.value.loading.icon}\n              label='loading'\n            ></Icon>\n          </div>\n        )\n      }\n\n      return null\n    }\n\n    function renderSuffix() {\n      return (\n        <div class={nh.be('suffix-wrapper')}>\n          {renderCustomSuffix()}\n          <Transition name={nh.ns('fade')} appear>\n            {renderSuffixAction()}\n          </Transition>\n        </div>\n      )\n    }\n\n    function renderCount() {\n      return (\n        <div class={nh.be('count')}>\n          {renderSlot(slots, 'count', { value: currentValue.value }, () => [\n            props.maxLength === Infinity ? currentLength.value : `${currentLength.value}/${props.maxLength}`\n          ])}\n        </div>\n      )\n    }\n\n    function renderPlainPassword() {\n      if (props.type === 'password' && props.plainPassword) {\n        return (\n          <div\n            key='password'\n            class={[nh.be('icon'), nh.be('password')]}\n            style={{\n              color: props.suffixColor\n            }}\n            onClick={toggleShowPassword}\n          >\n            {renderSlot(slots, 'password', { plain: showPassword.value }, () => [\n              <Icon {...passwordIcon.value}></Icon>\n            ])}\n          </div>\n        )\n      }\n\n      return null\n    }\n\n    function renderControl() {\n      return (\n        <div id={idFor.value} ref={control} class={className.value} onClick={() => inputControl.value?.focus()}>\n          {hasPrefix.value && renderPrefix()}\n          <input\n            {...props.controlAttrs}\n            ref={inputControl}\n            class={[nh.be('control'), props.controlAttrs?.class, props.controlClass]}\n            type={inputType.value}\n            autofocus={props.autofocus}\n            autocomplete={props.autocomplete ? 'on' : 'off'}\n            spellcheck={props.spellcheck}\n            disabled={props.disabled}\n            readonly={readonly.value || undefined}\n            placeholder={props.placeholder ?? locale.value.placeholder}\n            maxlength={props.maxLength > 0 ? props.maxLength : undefined}\n            name={props.name || props.controlAttrs?.name}\n            aria-labelledby={labelId.value}\n            onBlur={handleBlur}\n            onFocus={handleFocus}\n            onInput={handleInput}\n            onChange={handleChange}\n            onKeypress={handleKeyPress}\n            onKeydown={handleKeyDown}\n            onKeyup={handleKeyUp}\n            onSubmit={preventDefault}\n            onCompositionstart={handleCompositionStart}\n            onCompositionend={handleCompositionEnd}\n          />\n          {renderSuffix()}\n          {props.maxLength > 0 ? renderCount() : null}\n          {renderPlainPassword()}\n        </div>\n      )\n    }\n\n    function renderAside(type: 'before' | 'after') {\n      const buttonSlot = slots[`${type}Action`] || slots[`${type}-action`]\n\n      if (buttonSlot) {\n        return (\n          <div\n            class={[nh.be(type), nh.bem(type, 'action')]}\n            onMouseenter={() => ((type === 'before' ? beforeHover : afterHover).value = true)}\n            onMouseleave={() => ((type === 'before' ? beforeHover : afterHover).value = false)}\n          >\n            {buttonSlot()}\n          </div>\n        )\n      }\n\n      return <div class={nh.be(type)}>{slots[type] ? slots[type]!() : props[type]}</div>\n    }\n\n    return () => {\n      if (hasBefore.value || hasAfter.value) {\n        return (\n          <div class={wrapperClass.value}>\n            {hasBefore.value && renderAside('before')}\n            {renderControl()}\n            {hasAfter.value && renderAside('after')}\n          </div>\n        )\n      }\n\n      return renderControl()\n    }\n  },\n  methods: {\n    focus: noop as (options?: FocusOptions) => void,\n    blur: noop as () => void\n  }\n})\n"
    },
    {
      "target": "components/input/props.ts",
      "content": "import {\n  booleanProp,\n  buildProps,\n  classProp,\n  eventProp,\n  iconProp,\n  localeProp,\n  sizeProp,\n  stateProp\n} from '@pocui/config'\n\nimport type { IconEffect } from '@/components/icon'\nimport type { ConfigurableProps, EventListener } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { ChangeEvent, InputType } from './symbol'\n\nexport const inputProps = buildProps({\n  size: sizeProp,\n  state: stateProp,\n  locale: localeProp('input'),\n  type: String as PropType<InputType>,\n  prefix: iconProp,\n  prefixColor: String,\n  suffix: iconProp,\n  suffixColor: String,\n  formatter: Function as PropType<(value: string | number) => string | number>,\n  value: [String, Number],\n  placeholder: String,\n  autofocus: booleanProp,\n  spellcheck: booleanProp,\n  autocomplete: booleanProp,\n  readonly: booleanProp,\n  disabled: booleanProp,\n  controlClass: classProp,\n  debounce: booleanProp,\n  delay: Number,\n  maxLength: Number,\n  before: String,\n  after: String,\n  /**\n   * 是否显示切换 password 为明文的按钮\n   */\n  plainPassword: booleanProp,\n  clearable: booleanProp,\n  loading: booleanProp,\n  loadingIcon: iconProp,\n  loadingLock: booleanProp,\n  loadingEffect: String as PropType<IconEffect>,\n  transparent: booleanProp,\n  sync: booleanProp,\n  controlAttrs: Object as PropType<Record<string, any>>,\n  name: String,\n  onFocus: eventProp<(event: FocusEvent) => void>(),\n  onBlur: eventProp<(event: FocusEvent) => void>(),\n  onInput: eventProp<EventListener<ChangeEvent>>(),\n  onChange: eventProp<EventListener<ChangeEvent>>(),\n  onEnter: eventProp(),\n  onClear: eventProp(),\n  onPrefixClick: eventProp<(event: MouseEvent) => void>(),\n  onSuffixClick: eventProp<(event: MouseEvent) => void>(),\n  onKeyDown: eventProp<(event: KeyboardEvent) => void>(),\n  onKeyPress: eventProp<(event: KeyboardEvent) => void>(),\n  onKeyUp: eventProp<(event: KeyboardEvent) => void>(),\n  onCompositionStart: eventProp<(event: CompositionEvent) => void>(),\n  onCompositionEnd: eventProp<(event: CompositionEvent) => void>()\n})\n\nexport type InputProps = ExtractPropTypes<typeof inputProps>\nexport type InputCProps = ConfigurableProps<InputProps>\n"
    },
    {
      "target": "components/input/symbol.ts",
      "content": "import type { ComponentPublicInstance } from 'vue'\n\nexport type InputType = 'text' | 'password' | 'date' | 'datetime' | 'time'\n\nexport interface InputExposed extends ComponentPublicInstance {\n  idFor?: string,\n\n  labelId?: string,\n\n  focused: boolean,\n\n  currentValue: string,\n\n  showPassword: boolean,\n\n  currentLength: number,\n\n  composing: boolean,\n\n  input?: HTMLInputElement | null,\n\n  copyValue: () => boolean,\n\n  focus: (options?: FocusOptions) => void,\n\n  blur: () => void\n}\n\nexport type ChangeEvent = (value: string | number) => void\n"
    }
  ],
  "dependencies": ["vue", "@pocui/hooks", "@pocui/utils", "@pocui/config"],
  "registryDependencies": ["form", "icon", "input.scss"],
  "categories": ["form"],
  "meta": { "isReferenceOnly": false }
}
