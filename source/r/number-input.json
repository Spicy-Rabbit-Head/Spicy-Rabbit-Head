{
  "name": "number-input",
  "type": "registry:components",
  "description": "通常用在需要以更友好的交互进行数字的输入的场合。",
  "files": [
    {
      "target": "components/number-input/index.ts",
      "content": "import NumberInput from './number-input.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { NumberInput }\nexport { numberInputProps } from './props'\n\nexport type NumberInputExposed = ComponentPublicInstance & InstanceType<typeof NumberInput>\n\nexport type { NumberInputProps, NumberInputCProps } from './props'\nexport type { NumberInputControlType, NumberInputEmptyType } from './symbol'\n"
    },
    {
      "target": "components/number-input/number-input.vue",
      "content": "<script setup lang=\"ts\">\nimport { useFieldStore } from '@/components/form'\nimport { Icon } from '@/components/icon'\n\nimport { computed, ref, toRef, watch } from 'vue'\n\nimport {\n  createIconProp,\n  createSizeProp,\n  createStateProp,\n  emitEvent,\n  useIcons,\n  useLocale,\n  useNameHelper,\n  useProps\n} from '@pocui/config'\n\nimport { useHover, useModifier, useTimerRecord } from '@pocui/hooks'\nimport {\n  boundRange,\n  debounce,\n  isNullish,\n  isValidNumber,\n  minus,\n  plus,\n  throttle,\n  toFixed,\n  toNumber\n} from '@pocui/utils'\n\nimport { numberInputProps } from './props'\n\ntype InputEventType = 'input' | 'change'\n\nconst isEmpty = (value: unknown) => !value && value !== 0\nconst isNullOrNaN = (value: unknown) => isNullish(value) || Number.isNaN(value)\n\ndefineOptions({ name: 'NumberInput',\n  description:'通常用在需要以更友好的交互进行数字的输入的场合。',\n  categories: ['form'] })\n\nconst { idFor, state, disabled, loading, size, validateField, clearField, getFieldValue, setFieldValue } =\n  useFieldStore<number>(focus)\n\nconst _props = defineProps(numberInputProps)\nconst props = useProps('numberInput', _props, {\n  size: createSizeProp(size),\n  state: createStateProp(state),\n  locale: null,\n  prefix: createIconProp(),\n  prefixColor: '',\n  suffix: createIconProp(),\n  suffixColor: '',\n  // 格式化后显示\n  formatter: {\n    default: null,\n    isFunc: true\n  },\n  value: {\n    default: () => getFieldValue(),\n    static: true\n  },\n  min: -Infinity,\n  max: Infinity,\n  placeholder: null,\n  autofocus: false,\n  spellcheck: false,\n  autocomplete: false,\n  precision: -1,\n  readonly: false,\n  step: 1,\n  ctrlStep: 100,\n  shiftStep: 10,\n  altStep: 0.1,\n  disabled: () => disabled.value,\n  controlClass: null,\n  debounce: false,\n  delay: null,\n  clearable: false,\n  loading: () => loading.value,\n  loadingIcon: createIconProp(),\n  loadingLock: false,\n  loadingEffect: null,\n  sync: false,\n  syncStep: false,\n  controlType: 'right',\n  emptyType: 'NaN',\n  controlAttrs: null,\n  name: {\n    default: '',\n    static: true\n  }\n})\n\nconst emit = defineEmits(['update:value'])\n\nconst slots = defineSlots<{\n  prefix(): any,\n  suffix(): any\n}>()\n\nconst nh = useNameHelper('number-input')\nconst locale = useLocale('numberInput', toRef(props, 'locale'))\nconst icons = useIcons()\n\nconst { timeout, interval } = useTimerRecord()\n\nconst focused = ref(false)\nconst currentValue = ref<string | number>(props.value)\nconst inputting = ref(false)\nconst plusHolding = ref(false)\nconst minusHolding = ref(false)\n\nconst control = ref<HTMLInputElement>()\nconst { wrapper, isHover } = useHover()\n\nuseModifier({\n  target: control,\n  passive: false,\n  onKeyDown: (event, modifier) => {\n    emitEvent(props.onKeyDown, event)\n\n    if (modifier.up || modifier.down) {\n      event.preventDefault()\n      event.stopPropagation()\n\n      if ((modifier.up && plusDisabled.value) || (modifier.down && minusDisabled.value)) {\n        return\n      }\n\n      changeStep(\n        modifier.up ? 'plus' : 'minus',\n        event.ctrlKey ? 'ctrl' : event.shiftKey ? 'shift' : event.altKey ? 'alt' : undefined\n      )\n      modifier.resetAll()\n    } else if (modifier.enter) {\n      event.preventDefault()\n      event.stopPropagation()\n      emitChangeEvent('change')\n      modifier.resetAll()\n    }\n  },\n  onKeyUp: event => {\n    emitEvent(props.onKeyUp, event)\n\n    if (event.key === 'Enter') {\n      handleEnter()\n    }\n  }\n})\n\nlet lastValue: number\n\nconst outOfRange = computed(() => {\n  return (\n    !isNullOrNaN(currentValue.value) &&\n    (toNumber(currentValue.value) > props.max || toNumber(currentValue.value) < props.min)\n  )\n})\nconst isReadonly = computed(() => (props.loading && props.loadingLock) || props.readonly)\nconst plusDisabled = computed(() => {\n  return (\n    props.disabled ||\n    isReadonly.value ||\n    (!isNullOrNaN(currentValue.value) && toNumber(currentValue.value) >= props.max)\n  )\n})\nconst minusDisabled = computed(() => {\n  return (\n    props.disabled ||\n    isReadonly.value ||\n    (!isNullOrNaN(currentValue.value) && toNumber(currentValue.value) <= props.min)\n  )\n})\nconst className = computed(() => {\n  const [display, fade] = (props.controlType || 'right').split('-')\n\n  return [\n    nh.b(),\n    nh.bs('vars'),\n    nh.ns('input-vars'),\n    {\n      [nh.in()]: props.inherit,\n      [nh.bm('focused')]: inputting.value,\n      [nh.bm('disabled')]: props.disabled,\n      [nh.bm('readonly')]: isReadonly.value,\n      [nh.bm('loading')]: props.loading,\n      [nh.bm(props.size)]: props.size !== 'default',\n      [nh.bm(props.state)]: props.state !== 'default',\n      [nh.bm(`control-${display}`)]: display !== 'right',\n      [nh.bm('control-fade')]: fade,\n      [nh.bm('out-of-range')]: outOfRange.value\n    }\n  ]\n})\nconst hasPrefix = computed(() => {\n  return !!(slots.prefix || props.prefix)\n})\nconst hasSuffix = computed(() => {\n  return !!(slots.suffix || props.suffix)\n})\nconst preciseNumber = computed(() => {\n  return !inputting.value && typeof currentValue.value === 'number' && props.precision >= 0\n    ? toFixed(currentValue.value, props.precision)\n    : currentValue.value\n})\nconst formattedValue = computed(() => {\n  if (typeof preciseNumber.value !== 'number') return preciseNumber.value ?? ''\n\n  return !inputting.value && typeof props.formatter === 'function'\n    ? props.formatter(preciseNumber.value as number)\n    : preciseNumber.value.toString()\n})\nconst hasValue = computed(() => !!(currentValue.value || currentValue.value === 0))\nconst showClear = computed(() => {\n  return !props.disabled && !isReadonly.value && props.clearable && isHover.value && hasValue.value\n})\nconst inputValue = computed(() => {\n  if (Number.isNaN(currentValue.value)) {\n    return ''\n  }\n\n  return inputting.value ? preciseNumber.value : formattedValue.value\n})\n\nconst delay = toNumber(props.delay)\nconst handleInput = props.debounce ? debounce(handleChange, delay || 100) : throttle(handleChange, delay || 16)\n\nwatch(\n  () => props.value,\n  value => {\n    if (value !== lastValue) {\n      parseValue()\n    }\n  },\n  { immediate: true }\n)\n\ndefineExpose({\n  idFor,\n  focused,\n  isHover,\n  outOfRange,\n  preciseNumber,\n  formattedValue,\n  isReadonly,\n  wrapper,\n  input: control,\n  focus,\n  blur: () => control.value?.blur()\n})\n\nfunction boundValueRange(value: number) {\n  return boundRange(value, props.min, props.max)\n}\n\nfunction parseValue() {\n  let value = props.value\n  value = inputting.value ? value : isValidNumber(value, true) ? toNumber(value) : getEmptyValue()\n\n  if (props.precision >= 0 && !isNullOrNaN(value)) {\n    value = toFixed(boundValueRange(value), props.precision)\n  }\n\n  currentValue.value = value\n  lastValue = value\n}\n\nfunction focus(options?: FocusOptions) {\n  control.value?.focus(options)\n}\n\nfunction handleFocus(event: FocusEvent) {\n  focused.value = true\n  inputting.value = true\n  emitEvent(props.onFocus, event)\n}\n\nfunction handleBlur(event: FocusEvent) {\n  focused.value = false\n\n  setTimeout(() => {\n    if (!focused.value) {\n      inputting.value = false\n      emitEvent(props.onBlur, event)\n      emitChangeEvent('change')\n    }\n  }, 120)\n}\n\nfunction handleHold(type: 'plus' | 'minus', event: PointerEvent) {\n  const disabled = type === 'plus' ? plusDisabled : minusDisabled\n  const change = type === 'plus' ? plusNumber : minusNumber\n\n  if (event.button !== 0 || disabled.value) return\n\n  change(event)\n  document.addEventListener('pointerup', cancelStep)\n  document.addEventListener('touchend', cancelStep)\n  clearTimeout(timeout.step)\n  clearInterval(interval.step)\n  ;(type === 'plus' ? plusHolding : minusHolding).value = true\n\n  timeout.step = setTimeout(() => {\n    interval.step = setInterval(() => {\n      disabled.value ? cancelStep() : change(event)\n    }, 32)\n  }, 500)\n}\n\nfunction cancelStep() {\n  document.removeEventListener('pointerup', cancelStep)\n  document.removeEventListener('touchend', cancelStep)\n  clearTimeout(timeout.step)\n  clearInterval(interval.step)\n\n  plusHolding.value = false\n  minusHolding.value = false\n}\n\nfunction plusNumber(event: PointerEvent) {\n  !focused.value && focus()\n  changeStep('plus', event.ctrlKey ? 'ctrl' : event.shiftKey ? 'shift' : event.altKey ? 'alt' : undefined)\n}\n\nfunction minusNumber(event: PointerEvent) {\n  !focused.value && focus()\n  changeStep('minus', event.ctrlKey ? 'ctrl' : event.shiftKey ? 'shift' : event.altKey ? 'alt' : undefined)\n}\n\nfunction changeStep(type: 'plus' | 'minus', modifier?: 'ctrl' | 'shift' | 'alt') {\n  if (props.disabled || isReadonly.value) return\n\n  let value = currentValue.value || 0\n  let step!: number\n\n  switch (modifier) {\n    case 'ctrl':\n      step = props.ctrlStep\n      break\n    case 'shift':\n      step = props.shiftStep\n      break\n    case 'alt':\n      step = props.altStep\n      break\n    default:\n      step = props.step\n  }\n\n  const stringValue = value.toString().trim()\n\n  if (stringValue.endsWith('.')) {\n    value = toNumber(stringValue.slice(0, -1))\n  }\n\n  if (type === 'plus') {\n    value = plus(value, step)\n  } else {\n    value = minus(value, step)\n  }\n\n  setValue(value, props.syncStep && !props.sync ? 'change' : 'input')\n}\n\nfunction handleChange(event: Event) {\n  const type = event.type as InputEventType\n  const stringValue = (event.target as HTMLInputElement).value\n\n  let value = stringValue.trim()\n\n  // 当更改时将 `<input>` 中的无效值回滚为空\n  if (type === 'change' && stringValue && !isValidNumber(stringValue, true)) {\n    const floatValue = parseFloat(stringValue)\n\n    if (Number.isNaN(floatValue)) {\n      value = ''\n    } else {\n      value = floatValue.toString()\n    }\n\n    ;(event.target as HTMLInputElement).value = value\n  }\n\n  inputting.value = type === 'input'\n\n  setValue(value, type)\n}\n\nfunction setValue(value: string | number, type: InputEventType, sync = props.sync) {\n  if (type !== 'input') {\n    currentValue.value = isEmpty(value) ? getEmptyValue() : toNumber(value)\n  } else {\n    currentValue.value = value\n  }\n\n  emitChangeEvent(type, sync)\n}\n\nfunction getEmptyValue() {\n  switch (props.emptyType) {\n    case 'undefined':\n      return undefined! as number\n    case 'null':\n      return null! as number\n    default:\n      return NaN\n  }\n}\n\nfunction emitChangeEvent(type: InputEventType, sync = props.sync) {\n  const empty = isEmpty(currentValue.value)\n  const value = empty ? getEmptyValue() : toNumber(currentValue.value)\n\n  type = type === 'input' ? 'input' : 'change'\n\n  if (type === 'change') {\n    let boundValue = empty ? value : boundValueRange(toNumber(value))\n\n    if (props.precision >= 0) {\n      boundValue = toFixed(boundValue, props.precision)\n    }\n\n    const changed = !Object.is(boundValue, value)\n\n    if (!empty) {\n      currentValue.value = boundValue\n    }\n\n    if (!sync && Object.is(lastValue, boundValue)) {\n      !Object.is(props.value, value) && emit('update:value', boundValue)\n      return\n    }\n\n    lastValue = boundValue\n\n    if (!sync || changed) {\n      emit('update:value', boundValue)\n      setFieldValue(boundValue)\n    }\n\n    emitEvent(props.onChange, boundValue)\n\n    if (!sync || changed) {\n      validateField()\n    }\n  } else {\n    if (sync) {\n      emit('update:value', value)\n      setFieldValue(value)\n    }\n\n    emitEvent(props.onInput, value)\n\n    if (sync) {\n      validateField()\n    }\n  }\n}\n\nfunction handleClear() {\n  if (props.disabled || isReadonly.value) return\n\n  setValue(NaN, 'change', false)\n  emitEvent(props.onClear)\n  clearField()\n  focus()\n}\n\nfunction handleEnter() {\n  emitEvent(props.onEnter)\n}\n\nfunction handlePrefixClick(event: MouseEvent) {\n  emitEvent(props.onPrefixClick, event)\n}\n\nfunction handleSuffixClick(event: MouseEvent) {\n  emitEvent(props.onSuffixClick, event)\n}\n\nfunction handleKeyPress(event: KeyboardEvent) {\n  emitEvent(props.onKeyPress, event)\n}\n</script>\n\n<template>\n  <div\n    :id=\"idFor\"\n    ref=\"wrapper\"\n    :class=\"className\"\n    @click=\"control?.focus()\"\n  >\n    <div\n      v-if=\"hasPrefix\"\n      :class=\"[nh.be('icon'), nh.be('prefix')]\"\n      :style=\"{ color: props.prefixColor }\"\n      @click=\"handlePrefixClick\"\n    >\n      <slot name=\"prefix\">\n        <Icon :icon=\"props.prefix\"></Icon>\n      </slot>\n    </div>\n    <input\n      v-bind=\"props.controlAttrs\"\n      ref=\"control\"\n      :class=\"[nh.be('control'), props.controlAttrs?.class, props.controlClass]\"\n      :value=\"inputValue\"\n      type=\"text\"\n      :autofocus=\"props.autofocus\"\n      :autocomplete=\"props.autocomplete ? 'on' : 'off'\"\n      :spellcheck=\"props.spellcheck\"\n      :disabled=\"props.disabled\"\n      :readonly=\"isReadonly\"\n      :placeholder=\"props.placeholder ?? locale.placeholder\"\n      :name=\"props.name || props.controlAttrs?.name\"\n      role=\"spinbutton\"\n      :title=\"outOfRange ? locale.outOfRange : undefined\"\n      :aria-valuenow=\"preciseNumber\"\n      :aria-valuemin=\"props.min !== -Infinity ? props.min : undefined\"\n      :aria-valuemax=\"props.max !== Infinity ? props.max : undefined\"\n      @submit.prevent\n      @blur=\"handleBlur\"\n      @focus=\"handleFocus\"\n      @keypress=\"handleKeyPress\"\n      @input=\"handleInput\"\n      @change=\"handleChange\"\n    />\n    <div\n      v-if=\"hasSuffix\"\n      :class=\"[nh.be('icon'), nh.be('suffix')]\"\n      :style=\"{\n        color: props.suffixColor,\n        opacity: showClear || props.loading ? '0%' : ''\n      }\"\n      @click=\"handleSuffixClick\"\n    >\n      <slot name=\"suffix\">\n        <Icon :icon=\"props.suffix\"></Icon>\n      </slot>\n    </div>\n    <div\n      v-else-if=\"props.clearable || props.loading\"\n      :class=\"[nh.be('icon'), nh.bem('icon', 'placeholder'), nh.be('suffix')]\"\n    ></div>\n    <Transition :name=\"nh.ns('fade')\" appear>\n      <div v-if=\"showClear\" :class=\"[nh.be('icon'), nh.be('clear')]\" @click.stop=\"handleClear\">\n        <Icon v-bind=\"icons.clear\" label=\"clear\"></Icon>\n      </div>\n      <div v-else-if=\"props.loading\" :class=\"[nh.be('icon'), nh.be('loading')]\">\n        <Icon\n          v-bind=\"icons.loading\"\n          :effect=\"props.loadingEffect || icons.loading.effect\"\n          :icon=\"props.loadingIcon || icons.loading.icon\"\n          label=\"loading\"\n        ></Icon>\n      </div>\n    </Transition>\n    <template v-if=\"props.controlType !== 'none'\">\n      <div\n        :class=\"{\n          [nh.be('plus')]: true,\n          [nh.bem('plus', 'disabled')]: plusDisabled,\n          [nh.bem('plus', 'holding')]: plusHolding\n        }\"\n        @pointerdown.prevent=\"handleHold('plus', $event)\"\n        @mousedown.prevent\n        @touchstart.prevent\n      >\n        <Icon v-bind=\"icons.angleUp\" :scale=\"+(icons.angleUp.scale || 1) * 0.6\"></Icon>\n      </div>\n      <div\n        :class=\"{\n          [nh.be('minus')]: true,\n          [nh.bem('minus', 'disabled')]: minusDisabled,\n          [nh.bem('minus', 'holding')]: minusHolding\n        }\"\n        @pointerdown.prevent=\"handleHold('minus', $event)\"\n        @mousedown.prevent\n        @touchstart.prevent\n      >\n        <Icon v-bind=\"icons.angleDown\" :scale=\"+(icons.angleDown.scale || 1) * 0.6\"></Icon>\n      </div>\n    </template>\n  </div>\n</template>\n"
    },
    {
      "target": "components/number-input/props.ts",
      "content": "import {\n  booleanProp,\n  buildProps,\n  classProp,\n  eventProp,\n  iconProp,\n  localeProp,\n  sizeProp,\n  stateProp\n} from '@pocui/config'\n\nimport type { IconEffect } from '@/components/icon'\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { NumberInputControlType, NumberInputEmptyType } from './symbol'\n\nexport const numberInputProps = buildProps({\n  size: sizeProp,\n  state: stateProp,\n  locale: localeProp('input'),\n  prefix: iconProp,\n  prefixColor: String,\n  suffix: iconProp,\n  suffixColor: String,\n  /**\n   * 格式化后显示\n   */\n  formatter: Function as PropType<(value: number) => number | string>,\n  value: Number,\n  min: Number,\n  max: Number,\n  placeholder: String,\n  autofocus: booleanProp,\n  spellcheck: booleanProp,\n  autocomplete: booleanProp,\n  precision: Number,\n  readonly: booleanProp,\n  step: Number,\n  ctrlStep: Number,\n  shiftStep: Number,\n  altStep: Number,\n  disabled: booleanProp,\n  controlClass: classProp,\n  debounce: booleanProp,\n  delay: Number,\n  clearable: booleanProp,\n  loading: booleanProp,\n  loadingIcon: iconProp,\n  loadingLock: booleanProp,\n  loadingEffect: String as PropType<IconEffect>,\n  sync: booleanProp,\n  syncStep: booleanProp,\n  controlType: String as PropType<NumberInputControlType>,\n  emptyType: String as PropType<NumberInputEmptyType>,\n  controlAttrs: Object as PropType<Record<string, any>>,\n  name: String,\n  onFocus: eventProp<(event: FocusEvent) => void>(),\n  onBlur: eventProp<(event: FocusEvent) => void>(),\n  onInput: eventProp<(value: number) => void>(),\n  onChange: eventProp<(value: number) => void>(),\n  onEnter: eventProp(),\n  onClear: eventProp(),\n  onPrefixClick: eventProp<(event: MouseEvent) => void>(),\n  onSuffixClick: eventProp<(event: MouseEvent) => void>(),\n  onKeyDown: eventProp<(event: KeyboardEvent) => void>(),\n  onKeyPress: eventProp<(event: KeyboardEvent) => void>(),\n  onKeyUp: eventProp<(event: KeyboardEvent) => void>()\n})\n\nexport type NumberInputProps = ExtractPropTypes<typeof numberInputProps>\nexport type NumberInputCProps = ConfigurableProps<NumberInputProps>\n"
    },
    {
      "target": "components/number-input/symbol.ts",
      "content": "export type NumberInputControlType = 'right' | 'left' | 'right-fade' | 'left-fade' | 'none'\nexport type NumberInputEmptyType = 'NaN' | 'undefined' | 'null'\n"
    }
  ],
  "dependencies": ["vue", "@pocui/hooks", "@pocui/config"],
  "registryDependencies": ["number-input.scss", "form", "icon"],
  "categories": ["form"],
  "meta": { "isReferenceOnly": false }
}
