{
  "name": "scrollbar",
  "type": "registry:component",
  "description": "滚动条组件，提供自定义样式的滚动条控制功能",
  "files": [
    {
      "target": "components/scrollbar/hooks.ts",
      "content": "import { ref } from 'vue'\n\nimport { USE_TOUCH, noop } from '@pocui/utils'\n\nimport { ScrollbarType } from './symbol'\n\nimport type { Ref } from 'vue'\n\nexport function useTrack({\n  currentScroll = ref(0),\n  trackSpeed = ref(2),\n  track = ref(null),\n  bar = ref(null),\n  tracking = ref(false),\n  type = ref(ScrollbarType.VERTICAL),\n  barLength = ref(35),\n  disabled = ref(false),\n  onDown = noop,\n  onMove = noop,\n  onUp = noop,\n  onScroll = noop\n}: {\n  currentScroll: Ref<number>,\n  type: Ref<ScrollbarType>,\n  trackSpeed?: Ref<number>,\n  track?: Ref<HTMLElement | null | undefined>,\n  bar?: Ref<HTMLElement | null | undefined>,\n  tracking?: Ref<boolean>,\n  barLength?: Ref<number>,\n  disabled?: Ref<boolean>,\n  onDown?: (scroll: number) => void,\n  onMove?: (scroll: number) => void,\n  onUp?: (scroll: number) => void,\n  onScroll?: (scroll: number) => void\n}) {\n  let length: number\n  let startAt: number\n  let cursorAt: number\n  let targetScroll: number\n  let forward = true\n  let processing = false\n\n  function animateMoveBar() {\n    if (!tracking.value) return\n\n    processing = true\n\n    const speedRate = computeSpeedRate(targetScroll, currentScroll.value)\n    let changed = false\n\n    if (forward) {\n      if (currentScroll.value < targetScroll) {\n        currentScroll.value += speedRate * trackSpeed.value\n        changed = true\n      }\n    } else if (currentScroll.value > targetScroll) {\n      currentScroll.value -= speedRate * trackSpeed.value\n      changed = true\n    }\n\n    if (changed) {\n      verifyScroll()\n      onScroll(currentScroll.value)\n    }\n\n    if (tracking.value && forward ? currentScroll.value < targetScroll : currentScroll.value > targetScroll) {\n      requestAnimationFrame(animateMoveBar)\n    } else {\n      processing = false\n    }\n  }\n\n  function handleMouseDown(event: PointerEvent) {\n    if (disabled.value || event.button > 0) {\n      return false\n    }\n\n    event.stopPropagation()\n    event.preventDefault()\n\n    if (!track.value || !bar.value) return false\n\n    document.addEventListener('pointermove', handleMouseMove)\n    document.addEventListener('pointerup', handleMouseUp)\n\n    const rect = track.value.getBoundingClientRect()\n    const barRect = bar.value.getBoundingClientRect()\n\n    let position: number\n\n    if (type.value === ScrollbarType.VERTICAL) {\n      length = rect.height\n      startAt = barRect.top - rect.top\n      cursorAt = barRect.top\n      position = startAt + event.clientY - cursorAt\n    } else {\n      length = rect.width\n      startAt = barRect.left - rect.left\n      cursorAt = barRect.left\n      position = startAt + event.clientX - cursorAt\n    }\n\n    targetScroll = Math.max(0, Math.min((position / length / (100 - barLength.value / 2)) * 1e4, 100))\n    forward = targetScroll >= currentScroll.value\n\n    tracking.value = true\n\n    onDown(currentScroll.value)\n    animateMoveBar()\n  }\n\n  function handleMouseMove(event: PointerEvent) {\n    event.stopPropagation()\n\n    if (!USE_TOUCH) {\n      event.preventDefault()\n    }\n\n    onMove(currentScroll.value)\n\n    let position: number\n\n    if (type.value === ScrollbarType.VERTICAL) {\n      position = startAt + event.clientY - cursorAt\n    } else {\n      position = startAt + event.clientX - cursorAt\n    }\n\n    targetScroll = Math.max(0, Math.min((position / length / (100 - barLength.value / 2)) * 1e4, 100))\n\n    !processing && animateMoveBar()\n  }\n\n  function handleMouseUp(event: PointerEvent) {\n    event.preventDefault()\n\n    document.removeEventListener('pointermove', handleMouseMove)\n    document.removeEventListener('pointerup', handleMouseUp)\n\n    tracking.value = false\n\n    onUp(currentScroll.value)\n  }\n\n  function verifyScroll() {\n    currentScroll.value = Math.max(0, Math.min(currentScroll.value, 100))\n  }\n\n  return {\n    currentScroll,\n    trackSpeed,\n    track,\n    bar,\n    tracking,\n    type,\n    barLength,\n    disabled,\n\n    handleMouseDown\n  }\n}\n\nfunction computeSpeedRate(start: number, end: number) {\n  const span = Math.abs(start - end)\n\n  for (let i = 0; i < 5; ++i) {\n    if (span < (i + 1) * 20) {\n      return 1 + 0.25 * i\n    }\n  }\n\n  return 2\n}\n"
    },
    {
      "target": "components/scrollbar/index.ts",
      "content": "import Scrollbar from './scrollbar.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Scrollbar }\nexport { scrollbarProps } from './props'\n\nexport type ScrollbarExposed = ComponentPublicInstance & InstanceType<typeof Scrollbar>\n\nexport type { ScrollbarProps, ScrollbarCProps } from './props'\nexport type { ScrollbarPlacement } from './symbol'\n"
    },
    {
      "target": "components/scrollbar/props.ts",
      "content": "import { booleanProp, buildProps, eventProp } from '@pocui/config'\n\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { ScrollbarPlacement } from './symbol'\n\nexport const scrollbarProps = buildProps({\n  placement: String as PropType<ScrollbarPlacement>,\n  scroll: Number,\n  barLength: Number,\n  width: Number,\n  appear: booleanProp,\n  fade: Number,\n  barColor: String,\n  trackColor: String,\n  disabled: booleanProp,\n  wrapper: [String, Object] as PropType<string | HTMLElement>,\n  duration: Number,\n  useTrack: booleanProp,\n  trackSpeed: Number,\n  onScrollStart: eventProp<(percent: number) => void>(),\n  onScroll: eventProp<(percent: number) => void>(),\n  onScrollEnd: eventProp<(percent: number) => void>()\n})\n\nexport type ScrollbarProps = ExtractPropTypes<typeof scrollbarProps>\nexport type ScrollbarCProps = ConfigurableProps<ScrollbarProps, 'scroll'>\n"
    },
    {
      "target": "components/scrollbar/scrollbar.vue",
      "content": "<script setup lang=\"ts\">\nimport { computed, getCurrentInstance, nextTick, onBeforeUnmount, onMounted, ref, toRef, watch, watchEffect } from 'vue'\n\nimport { emitEvent, useNameHelper, useProps } from '@pocui/config'\nimport { useManualRef, useSetTimeout } from '@pocui/hooks'\nimport { USE_TOUCH, boundRange, isDefined, throttle } from '@pocui/utils'\nimport { useTrack } from './hooks'\nimport { scrollbarProps } from './props'\nimport { ScrollbarType, scrollbarPlacements } from './symbol'\n\ndefineOptions({ name: 'Scrollbar',\n  description:'滚动条组件，提供自定义样式的滚动条控制功能',\n  categories: ['other'] })\n\nconst _props = defineProps(scrollbarProps)\nconst props = useProps('scrollbar', _props, {\n  placement: {\n    default: 'right',\n    validator: value => scrollbarPlacements.includes(value)\n  },\n  scroll: {\n    default: 0,\n    validator: value => value >= 0 && value <= 100,\n    static: true\n  },\n  barLength: {\n    default: 35,\n    validator: value => value > 0 && value < 100\n  },\n  width: null,\n  appear: false,\n  fade: 1500,\n  barColor: null,\n  trackColor: null,\n  disabled: false,\n  wrapper: null,\n  duration: null,\n  useTrack: false,\n  trackSpeed: {\n    default: 2,\n    validator: value => value > 0 && value < 10\n  }\n})\n\nconst nh = useNameHelper('scrollbar')\nconst active = ref(false)\nconst scrolling = ref(false)\n\nconst { manualRef, triggerUpdate } = useManualRef()\n\nconst currentScroll = manualRef(props.scroll)\n\nconst container = ref<HTMLElement>()\nconst bar = ref<HTMLElement>()\nconst track = ref<HTMLElement>()\n\nconst { timer } = useSetTimeout()\n\nconst type = computed(() => {\n  return props.placement === 'right' || props.placement === 'left' ? ScrollbarType.VERTICAL : ScrollbarType.HORIZONTAL\n})\n\nconst { tracking, handleMouseDown: handleTrackMouseDown } = useTrack({\n  currentScroll,\n  track,\n  bar,\n  type,\n  trackSpeed: toRef(props, 'trackSpeed'),\n  barLength: toRef(props, 'barLength'),\n  disabled: toRef(props, 'disabled'),\n  onDown: scroll => {\n    clearTimeout(timer.fade)\n    emitEvent(props.onScrollStart, scroll)\n  },\n  onUp: scroll => {\n    setScrollbarFade()\n    triggerUpdate()\n    emitEvent(props.onScrollEnd, scroll)\n  },\n  onScroll: scroll => {\n    triggerUpdate()\n    emitEvent(props.onScroll, scroll)\n  }\n})\n\nconst className = computed(() => {\n  return [\n    nh.b(),\n    nh.bs('vars'),\n    nh.bm(props.placement),\n    {\n      [nh.inc()]: props.inherit,\n      [nh.bm('fade')]: props.fade,\n      [nh.bm('scrolling')]: scrolling.value,\n      [nh.bm('tracking')]: tracking.value,\n      [nh.bm('active')]: active.value,\n      [nh.bm('disabled')]: props.disabled\n    }\n  ]\n})\nconst style = computed<Record<string, string>>(() => {\n  return {\n    [nh.cv('bar-bg-color')]: props.barColor,\n    [nh.cv('track-bg-color')]: props.trackColor,\n    [nh.cv('width')]: props.width ? `${props.width}px` : null!\n  }\n})\n\nwatch(\n  () => props.scroll,\n  value => {\n    currentScroll.value = value\n    triggerUpdate()\n  }\n)\nwatchEffect(() => {\n  if (!bar.value) return\n\n  const position = `${((100 - props.barLength) * currentScroll.value) / props.barLength}%`\n  const length = `${props.barLength}%`\n\n  if (type.value === ScrollbarType.VERTICAL) {\n    bar.value.style.height = length\n    bar.value.style.transform = `translate3d(0, ${position}, 0)`\n  } else {\n    bar.value.style.width = length\n    bar.value.style.transform = `translate3d(${position}, 0, 0)`\n  }\n})\nwatchEffect(() => {\n  if (!bar.value) return\n\n  bar.value.style.transitionDuration = isDefined(props.duration) && props.duration >= 0 ? `${props.duration}ms` : ''\n})\n\nif (props.appear) {\n  watch(currentScroll, () => {\n    clearTimeout(timer.fade)\n    active.value = true\n\n    if (!scrolling.value && !tracking.value) {\n      setScrollbarFade()\n    }\n  })\n}\n\nconst handleWrapperMouseMove = throttle(() => {\n  clearTimeout(timer.fade)\n\n  if (props.disabled) {\n    active.value = false\n  } else {\n    active.value = true\n\n    if (!scrolling.value && !tracking.value) {\n      setScrollbarFade()\n    }\n  }\n})\n\nlet wrapperElement: HTMLElement | null\n\nonMounted(() => {\n  let instance = getCurrentInstance()\n\n  nextTick(() => {\n    if (typeof props.wrapper === 'string') {\n      wrapperElement = document.querySelector(props.wrapper)\n    } else {\n      wrapperElement = props.wrapper\n    }\n\n    if (!wrapperElement) {\n      if (instance?.parent) {\n        wrapperElement = instance.parent.proxy?.$el\n\n        if (!wrapperElement) {\n          wrapperElement = container.value?.parentElement ?? null\n        }\n      } else {\n        wrapperElement = container.value?.parentElement ?? null\n      }\n    }\n\n    if (wrapperElement && props.fade >= 300) {\n      wrapperElement.addEventListener('mousemove', handleWrapperMouseMove)\n    }\n\n    instance = null\n\n    if (!props.appear) {\n      watch(currentScroll, () => {\n        clearInterval(timer.fade)\n        active.value = true\n        setScrollbarFade()\n      })\n    }\n  })\n})\n\nonBeforeUnmount(() => {\n  if (wrapperElement) {\n    wrapperElement.removeEventListener('mousemove', handleWrapperMouseMove)\n  }\n\n  wrapperElement = null\n  clearTimeout(timer.fade)\n})\n\ndefineExpose({\n  currentScroll,\n  container,\n  bar,\n  track,\n  handleScroll\n})\n\nlet length: number\nlet startAt: number\nlet cursorAt: number\n\nfunction handleMouseDown(event: PointerEvent) {\n  if (event.button !== 0 || props.disabled) {\n    return false\n  }\n\n  event.stopPropagation()\n  event.preventDefault()\n\n  if (!track.value || !bar.value) return false\n\n  document.addEventListener('pointermove', handleMouseMove)\n  document.addEventListener('pointerup', handleMouseUp)\n\n  const rect = track.value.getBoundingClientRect()\n  const barRect = bar.value.getBoundingClientRect()\n\n  if (type.value === ScrollbarType.VERTICAL) {\n    length = rect.height\n    startAt = barRect.top - rect.top\n    cursorAt = event.clientY\n  } else {\n    length = rect.width\n    startAt = barRect.left - rect.left\n    cursorAt = event.clientX\n  }\n\n  clearTimeout(timer.fade)\n\n  scrolling.value = true\n  emitEvent(props.onScrollStart, currentScroll.value)\n}\n\nfunction handleMouseMove(event: PointerEvent) {\n  event.stopPropagation()\n\n  if (!USE_TOUCH) {\n    event.preventDefault()\n  }\n\n  let position: number\n\n  if (type.value === ScrollbarType.VERTICAL) {\n    position = startAt + event.clientY - cursorAt\n  } else {\n    position = startAt + event.clientX - cursorAt\n  }\n\n  currentScroll.value = (position / length / (100 - props.barLength)) * 1e4\n\n  verifyScroll()\n  triggerUpdate()\n  emitEvent(props.onScroll, currentScroll.value)\n}\n\nfunction handleMouseUp(event: PointerEvent) {\n  event.preventDefault()\n\n  document.removeEventListener('pointermove', handleMouseMove)\n  document.removeEventListener('pointerup', handleMouseUp)\n\n  setScrollbarFade()\n\n  scrolling.value = false\n  emitEvent(props.onScrollEnd, currentScroll.value)\n}\n\nfunction verifyScroll() {\n  currentScroll.value = Math.max(0, Math.min(currentScroll.value, 100))\n}\n\nfunction setScrollbarFade() {\n  if (props.fade >= 300) {\n    timer.fade = setTimeout(() => {\n      active.value = false\n    }, props.fade)\n  }\n}\n\nfunction handleScroll(scroll: number) {\n  if (Math.abs(currentScroll.value - scroll) < 0.0001) return\n\n  currentScroll.value = boundRange(scroll, 0, 100)\n  triggerUpdate()\n}\n\nfunction disableEvent<E extends Event>(event: E) {\n  if (event.cancelable) {\n    event.stopPropagation()\n    event.preventDefault()\n  }\n}\n</script>\n\n<template>\n  <div\n    ref=\"container\"\n    role=\"scrollbar\"\n    :class=\"className\"\n    :style=\"style\"\n  >\n    <div\n      ref=\"track\"\n      :class=\"[nh.be('track'), props.useTrack ? null : nh.bem('track', 'disabled')]\"\n      @touchstart=\"disableEvent\"\n      @pointerdown=\"handleTrackMouseDown\"\n    ></div>\n    <div\n      ref=\"bar\"\n      :class=\"nh.be('bar')\"\n      @touchstart=\"disableEvent\"\n      @pointerdown=\"handleMouseDown\"\n    ></div>\n  </div>\n</template>\n"
    },
    {
      "target": "components/scrollbar/symbol.ts",
      "content": "export type ScrollbarPlacement = 'top' | 'right' | 'bottom' | 'left'\n\nexport const enum ScrollbarType {\n  HORIZONTAL,\n  VERTICAL\n}\n\nexport const scrollbarPlacements = Object.freeze<ScrollbarPlacement[]>([\n  'top',\n  'right',\n  'bottom',\n  'left'\n])\n"
    }
  ],
  "dependencies": ["vue", "@pocui/utils", "@pocui/config", "@pocui/hooks"],
  "registryDependencies": ["scrollbar.scss"],
  "categories": ["other"],
  "meta": { "isReferenceOnly": false }
}
