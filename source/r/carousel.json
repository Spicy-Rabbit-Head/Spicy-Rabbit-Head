{
  "name": "carousel",
  "type": "registry:component",
  "description": "轮播组件可以快速构建一个轮播的区域，常用与一组平级内容的灵活展示。",
  "files": [
    {
      "target": "components/carousel/carousel-item.vue",
      "content": "<script lang=\"ts\">\nimport { computed, defineComponent, inject, onBeforeUnmount, reactive } from 'vue'\n\nimport { useNameHelper } from '@pocui/config'\n\nimport { CAROUSEL_STATE } from './symbol'\n\nimport type { SlotsType } from 'vue'\n\nimport type { ItemState } from './symbol'\n\nexport default defineComponent({\n  name: 'CarouselItem',\n  description: '走马灯的单个子项，通常由 Carousel 组件使用。',\n  categories: ['display'],\n  slots: Object as SlotsType<{\n    default(props: { active: boolean }): any\n  }>,\n  setup() {\n    const carouselState = inject(CAROUSEL_STATE, null)\n\n    const nh = useNameHelper('carousel')\n    const state: ItemState = reactive({\n      label: -1,\n      width: 0,\n      height: 0,\n      offset: 0\n    })\n\n    const active = computed(() => {\n      return carouselState?.isItemActive(state.label) ?? false\n    })\n    const className = computed(() => {\n      return {\n        [nh.be('item')]: true,\n        [nh.bem('item', 'active')]: active.value\n      }\n    })\n    const style = computed(() => {\n      const { width, height, offset } = state\n\n      return {\n        width: width ? `${width}px` : undefined,\n        height: height ? `${height}px` : undefined,\n        transform: offset ? `translate${carouselState?.vertical ? 'Y' : 'X'}(${offset}px)` : undefined\n      }\n    })\n\n    if (carouselState) {\n      carouselState.increaseItem(state)\n\n      onBeforeUnmount(() => {\n        carouselState.decreaseItem(state)\n      })\n    }\n\n    function handleClick() {\n      carouselState?.handleSelect(state.label)\n    }\n\n    return {\n      active,\n      className,\n      style,\n\n      handleClick\n    }\n  }\n})\n</script>\n\n<template>\n  <div\n    :class=\"className\"\n    role=\"listitem\"\n    :style=\"style\"\n    @click=\"handleClick\"\n  >\n    <slot :active=\"active\"></slot>\n  </div>\n</template>\n"
    },
    {
      "target": "components/carousel/carousel.vue",
      "content": "<script lang=\"ts\">\nimport { Icon } from '@/components/icon'\nimport { ResizeObserver } from '@/components/resize-observer'\n\nimport { computed, defineComponent, onBeforeUnmount, onMounted, provide, reactive, ref, toRef, watch } from 'vue'\n\nimport { emitEvent, useHoverDelay, useIcons, useNameHelper, useProps } from '@pocui/config'\nimport { useHover, useSetTimeout } from '@pocui/hooks'\nimport { debounceMinor } from '@pocui/utils'\n\nimport { carouselProps } from './props'\n\nimport { CAROUSEL_STATE } from './symbol'\n\nimport type { SlotsType } from 'vue'\n\nimport type { CarouselState, ItemState } from './symbol'\n\nexport default defineComponent({\n  name: 'Carousel',\n  description: '轮播组件可以快速构建一个轮播的区域，常用与一组平级内容的灵活展示。',\n  categories: ['display'],\n  components: {\n    ResizeObserver,\n    Icon\n  },\n  props: carouselProps,\n  slots: Object as SlotsType<{\n    default(): any,\n    'prev-arrow'(props: { disabled: boolean }): any,\n    'next-arrow'(props: { disabled: boolean }): any,\n    pointer(props: { active: boolean }): any\n  }>,\n  emits: ['update:active'],\n  setup(_props, { emit }) {\n    const props = useProps('carousel', _props, {\n      active: {\n        default: 0,\n        static: true\n      },\n      viewSize: {\n        default: 3,\n        validator: value => value > 0\n      },\n      vertical: false,\n      disabled: false,\n      loop: false,\n      arrow: {\n        default: 'outside',\n        validator: value => ['outside', 'inside', 'none'].includes(value)\n      },\n      arrowTrigger: {\n        default: 'hover',\n        validator: value => ['hover', 'always'].includes(value)\n      },\n      autoplay: {\n        default: false,\n        validator: value => (typeof value === 'number' ? value > 500 : true)\n      },\n      pointer: {\n        default: 'none',\n        validator: value => ['outside', 'inside', 'none'].includes(value)\n      },\n      speed: 300,\n      activeOffset: 0,\n      height: null,\n      ignoreHover: false\n    })\n    const nh = useNameHelper('carousel')\n    const icons = useIcons()\n    const hoverDelay = useHoverDelay()\n    const itemStates = ref(new Set<ItemState>())\n    const currentActive = ref(0)\n    const isLocked = ref(false) // 用于控制阻断快速连点\n    const arrowActive = ref(props.arrowTrigger === 'always')\n\n    const listRect = reactive({\n      width: 0,\n      height: 0\n    })\n    const trackRect = reactive({\n      width: 0,\n      height: 0,\n      offset: 0\n    })\n    const itemRect = reactive({\n      width: 0,\n      height: 0\n    })\n\n    const { wrapper, isHover } = useHover()\n\n    const prev = ref<HTMLElement>()\n    const next = ref<HTMLElement>()\n\n    const isDisabled = computed(() => {\n      return props.disabled || itemStates.value.size <= props.viewSize\n    })\n    const className = computed(() => {\n      return {\n        [nh.b()]: true,\n        [nh.bs('vars')]: true,\n        [nh.inc()]: props.inherit,\n        [nh.bm('vertical')]: props.vertical,\n        [nh.bm('disabled')]: isDisabled.value\n      }\n    })\n    const style = computed(() => {\n      return {\n        height:\n          props.vertical && props.height ? `${props.height}${typeof props.height === 'number' ? 'px' : ''}` : undefined\n      }\n    })\n    const listStyle = computed(() => {\n      return {\n        width: listRect.width ? `${listRect.width}px` : undefined,\n        height: listRect.height ? `${listRect.height}px` : undefined\n      }\n    })\n    const trackStyle = computed(() => {\n      return {\n        width: trackRect.width ? `${trackRect.width}px` : undefined,\n        height: trackRect.height ? `${trackRect.height}px` : undefined,\n        transform: trackRect.offset\n          ? `translate${props.vertical ? 'Y' : 'X'}(${trackRect.offset}px) translateZ(0)`\n          : undefined,\n        transitionDuration: isLocked.value ? '0ms' : `${props.speed}ms`\n      }\n    })\n    const disabledPrev = computed(() => {\n      return isDisabled.value || (!props.loop && currentActive.value <= 0)\n    })\n    const disabledNext = computed(() => {\n      return isDisabled.value || (!props.loop && currentActive.value >= itemStates.value.size - props.viewSize)\n    })\n    const arrowIcons = computed(() => {\n      return props.vertical\n        ? [icons.value.angleUp, icons.value.angleDown]\n        : [icons.value.angleLeft, icons.value.angleRight]\n    })\n\n    watch(\n      () => props.active,\n      value => {\n        handleWheel(value - props.activeOffset)\n      }\n    )\n    watch(isHover, value => {\n      if (props.ignoreHover) return\n\n      if (value) {\n        handleMouseEnter()\n      } else {\n        handleMouseLeave()\n      }\n    })\n    watch(() => props.viewSize, refresh)\n    watch(() => props.autoplay, setAutoplay)\n\n    const refreshLabels = debounceMinor(() => {\n      Array.from(itemStates.value).forEach((item, index) => {\n        item.label = index\n      })\n    })\n    const updateItemRect = debounceMinor(() => {\n      itemStates.value.forEach(state => {\n        state.width = itemRect.width\n        state.height = itemRect.height\n      })\n    })\n    const updateListRect = debounceMinor(() => {\n      trackRect.width = itemRect.width * itemStates.value.size\n      trackRect.height = itemRect.height * itemStates.value.size\n    })\n\n    provide<CarouselState>(\n      CAROUSEL_STATE,\n      reactive({\n        vertical: toRef(props, 'vertical'),\n        increaseItem,\n        decreaseItem,\n        isItemActive,\n        handleSelect\n      })\n    )\n\n    // 初始化时不使用过渡效果\n    let inTransition = false\n    let shouldReset = false\n\n    isLocked.value = true\n\n    let observer: MutationObserver | null\n\n    onMounted(() => {\n      computeItemRect()\n      handleWheel(props.active - props.activeOffset)\n      handleAfterMove()\n\n      setTimeout(() => {\n        isLocked.value = false\n        inTransition = false\n\n        setAutoplay()\n      }, 0)\n\n      window.addEventListener('resize', refresh)\n\n      if (wrapper.value) {\n        observer = new MutationObserver(() => {\n          refresh()\n        })\n\n        observer.observe(wrapper.value, {\n          attributes: true,\n          childList: true,\n          characterData: true,\n          attributeFilter: ['style']\n        })\n      }\n    })\n\n    onBeforeUnmount(() => {\n      observer?.disconnect()\n      observer = null\n      window.removeEventListener('resize', refresh)\n    })\n\n    function increaseItem(item: ItemState) {\n      itemStates.value.add(item)\n      refreshLabels()\n      updateItemRect()\n      updateListRect()\n    }\n\n    function decreaseItem(item: ItemState) {\n      itemStates.value.delete(item)\n      refreshLabels()\n      updateListRect()\n    }\n\n    function isItemActive(label: number) {\n      return (currentActive.value + props.activeOffset) % itemStates.value.size === label\n    }\n\n    function computeItemRect() {\n      if (!wrapper.value) return\n\n      let prevFix = 0\n      let nextFix = 0\n\n      if (props.arrow === 'outside') {\n        if (props.vertical) {\n          prevFix = prev.value ? prev.value.offsetHeight : 0\n          nextFix = next.value ? next.value.offsetHeight : 0\n        } else {\n          prevFix = prev.value ? prev.value.offsetWidth : 0\n          nextFix = next.value ? next.value.offsetWidth : 0\n        }\n      }\n\n      if (props.vertical) {\n        listRect.width = 0\n        listRect.height = wrapper.value.offsetHeight - prevFix - nextFix\n\n        itemRect.width = 0\n        itemRect.height = listRect.height / props.viewSize\n      } else {\n        listRect.width = wrapper.value.offsetWidth - prevFix - nextFix\n        listRect.height = 0\n\n        itemRect.width = listRect.width / props.viewSize\n        itemRect.height = 0\n      }\n    }\n\n    function refresh() {\n      computeItemRect()\n      updateItemRect()\n      updateListRect()\n\n      if (trackRect.offset > 0) {\n        handlePrev(0)\n      } else {\n        handleNext(0)\n      }\n\n      setTimeout(() => {\n        isLocked.value = false\n        inTransition = false\n      }, 0)\n    }\n\n    function emitChangeEvent() {\n      const active = (currentActive.value + props.activeOffset) % itemStates.value.size\n\n      emit('update:active', active)\n      emitEvent(props.onChange, active)\n    }\n\n    function handlePrev(amount = 1) {\n      if (isDisabled.value || inTransition) return\n\n      const itemLength = props.vertical ? itemRect.height : itemRect.width\n      const itemList = Array.from(itemStates.value)\n      const itemCount = itemList.length\n      const targetIndex = (currentActive.value - amount + itemCount) % itemCount\n      const prevActive = currentActive.value\n\n      if (targetIndex >= itemCount - props.viewSize) {\n        if (!props.loop) return\n\n        if (trackRect.offset < 0) {\n          if (amount < currentActive.value) {\n            trackRect.offset = -targetIndex * itemLength\n          } else {\n            trackRect.offset = itemLength * (itemCount - targetIndex)\n\n            for (let i = targetIndex; i < itemCount; ++i) {\n              itemList[i].offset = -itemCount * itemLength\n            }\n          }\n        } else {\n          for (let i = 0; i < itemCount; ++i) {\n            itemList[i].offset = i < targetIndex ? 0 : -itemCount * itemLength\n          }\n\n          trackRect.offset = itemLength * (itemCount - targetIndex)\n        }\n\n        currentActive.value = targetIndex\n      } else {\n        currentActive.value = targetIndex\n        trackRect.offset = -currentActive.value * itemLength\n      }\n\n      shouldReset = currentActive.value <= itemCount - props.viewSize\n      inTransition = true\n\n      currentActive.value !== prevActive && emitChangeEvent()\n    }\n\n    function handleNext(amount = 1) {\n      if (isDisabled.value || inTransition) return\n\n      const itemLength = props.vertical ? itemRect.height : itemRect.width\n      const itemList = Array.from(itemStates.value)\n      const itemCount = itemList.length\n      const targetIndex = currentActive.value + amount\n      const prevActive = currentActive.value\n\n      if (targetIndex > itemStates.value.size - props.viewSize) {\n        if (!props.loop) return\n\n        if (trackRect.offset > 0) {\n          trackRect.offset = itemLength * (itemCount - targetIndex)\n        } else {\n          const anchorIndex = targetIndex + props.viewSize - itemCount\n\n          for (let i = 0, len = itemList.length; i < len; ++i) {\n            itemList[i].offset = i < anchorIndex ? itemCount * itemLength : 0\n          }\n\n          trackRect.offset = -targetIndex * itemLength\n        }\n\n        currentActive.value = targetIndex % itemCount\n      } else {\n        currentActive.value = targetIndex\n        trackRect.offset = -currentActive.value * itemLength\n      }\n\n      shouldReset = currentActive.value <= itemCount - props.viewSize\n      inTransition = true\n\n      currentActive.value !== prevActive && emitChangeEvent()\n    }\n\n    function handleWheel(active: number) {\n      if (isDisabled.value || inTransition || active === currentActive.value) return\n\n      const itemCount = itemStates.value.size\n\n      active = (active % itemCount) + (active < 0 ? itemCount : 0)\n\n      if (props.loop) {\n        let forward: number\n        let back: number\n\n        if (active > currentActive.value) {\n          forward = active - currentActive.value\n          back = itemCount - active + currentActive.value\n        } else {\n          forward = itemCount - currentActive.value + active\n          back = currentActive.value - active\n        }\n\n        if (forward < back) {\n          handleNext(forward)\n        } else if (forward > back) {\n          handlePrev(back)\n        } else {\n          if (trackRect.offset > 0) {\n            handlePrev(forward)\n          } else {\n            handleNext(forward)\n          }\n        }\n      } else {\n        if (active < currentActive.value) {\n          handlePrev(currentActive.value - active)\n        } else {\n          handleNext(active - currentActive.value)\n        }\n      }\n    }\n\n    function handleAfterMove() {\n      if (!shouldReset) {\n        inTransition = false\n      } else {\n        itemStates.value.forEach(state => {\n          state.offset = 0\n        })\n\n        shouldReset = false\n        isLocked.value = true\n\n        requestAnimationFrame(() => {\n          trackRect.offset = -currentActive.value * (props.vertical ? itemRect.height : itemRect.width)\n\n          requestAnimationFrame(() => {\n            isLocked.value = false\n            inTransition = false\n          })\n        })\n      }\n    }\n\n    function handlePrevClick() {\n      handlePrev(1)\n      emitEvent(props.onPrev, (currentActive.value + props.activeOffset) % itemStates.value.size)\n    }\n\n    function handleNextClick() {\n      handleNext(1)\n      emitEvent(props.onNext, (currentActive.value + props.activeOffset) % itemStates.value.size)\n    }\n\n    function handleSelect(label: number) {\n      emitEvent(props.onSelect, label)\n    }\n\n    const { timer } = useSetTimeout()\n\n    function setAutoplay() {\n      clearInterval(timer.play)\n\n      if (!props.autoplay) return\n\n      let waiting = 4000\n\n      if (typeof props.autoplay === 'number') {\n        waiting = props.autoplay\n      }\n\n      timer.play = window.setInterval(() => {\n        if (!props.loop && disabledNext.value) {\n          handleWheel(0)\n        } else {\n          handleNext()\n        }\n      }, waiting)\n    }\n\n    function handleMouseEnter() {\n      if (props.autoplay) {\n        clearTimeout(timer.hover)\n\n        timer.hover = setTimeout(() => {\n          clearInterval(timer.play)\n        }, hoverDelay.value)\n      }\n\n      if (props.arrowTrigger === 'hover' && props.arrow === 'inside') {\n        arrowActive.value = true\n      }\n    }\n\n    function handleMouseLeave() {\n      if (props.autoplay) {\n        clearTimeout(timer.hover)\n\n        timer.hover = setTimeout(() => {\n          setAutoplay()\n        }, hoverDelay.value)\n      }\n\n      if (props.arrowTrigger === 'hover') {\n        arrowActive.value = false\n      }\n    }\n\n    function isPointerDisabled(index: number) {\n      if (props.loop) return false\n\n      return !(index >= props.activeOffset - 1 && index < itemStates.value.size - props.activeOffset - 1)\n    }\n\n    return {\n      props,\n      nh,\n      itemStates,\n      currentActive,\n      arrowActive,\n\n      className,\n      style,\n      listStyle,\n      trackStyle,\n      disabledPrev,\n      disabledNext,\n      arrowIcons,\n\n      wrapper,\n      prev,\n      next,\n\n      handlePrevClick,\n      handleNextClick,\n      handleWheel,\n      handleAfterMove,\n      isPointerDisabled,\n\n      refresh\n    }\n  }\n})\n</script>\n\n<template>\n  <div\n    ref=\"wrapper\"\n    :class=\"className\"\n    role=\"list\"\n    :style=\"style\"\n  >\n    <ResizeObserver @resize=\"refresh\">\n      <div\n        :style=\"{\n          position: 'relative',\n          display: 'flex',\n          flexDirection: props.vertical ? 'column' : 'row',\n          width: '100%'\n        }\"\n      >\n        <div\n          v-if=\"props.arrow !== 'none'\"\n          ref=\"prev\"\n          :class=\"[nh.bem('arrow', props.arrow), nh.bem('arrow', 'prev'), arrowActive ? nh.bem('arrow', 'show') : '']\"\n        >\n          <div\n            :class=\"{\n              [nh.be('handler')]: true,\n              [nh.bem('handler', 'disabled')]: disabledPrev\n            }\"\n            @click=\"handlePrevClick\"\n          >\n            <slot name=\"prev-arrow\" :disabled=\"disabledPrev\">\n              <Icon v-bind=\"arrowIcons[0]\" :scale=\"+(arrowIcons[0].scale || 1) * 1.5\"></Icon>\n            </slot>\n          </div>\n        </div>\n        <div :class=\"nh.be('list')\" :style=\"listStyle\">\n          <div :class=\"nh.be('track')\" :style=\"trackStyle\" @transitionend.self=\"handleAfterMove\">\n            <slot></slot>\n          </div>\n        </div>\n        <div\n          v-if=\"props.arrow !== 'none'\"\n          ref=\"next\"\n          :class=\"[nh.bem('arrow', props.arrow), nh.bem('arrow', 'next'), arrowActive ? nh.bem('arrow', 'show') : '']\"\n        >\n          <div\n            :class=\"{\n              [nh.be('handler')]: true,\n              [nh.bem('handler', 'disabled')]: disabledNext\n            }\"\n            @click=\"handleNextClick\"\n          >\n            <slot name=\"next-arrow\" :disabled=\"disabledNext\">\n              <Icon v-bind=\"arrowIcons[1]\" :scale=\"+(arrowIcons[1].scale || 1) * 1.5\"></Icon>\n            </slot>\n          </div>\n        </div>\n      </div>\n    </ResizeObserver>\n    <div v-if=\"props.pointer !== 'none'\" :class=\"nh.bem('pointers', props.pointer)\">\n      <div\n        v-for=\"index in itemStates.size\"\n        :key=\"index\"\n        :class=\"{\n          [nh.be('pointer')]: true,\n          [nh.bem('pointer', 'active')]: index - 1 === (currentActive + props.activeOffset) % itemStates.size,\n          [nh.bem('pointer', 'disabled')]: isPointerDisabled(index - props.activeOffset - 1)\n        }\"\n        @click=\"handleWheel(index - props.activeOffset - 1)\"\n      >\n        <slot name=\"pointer\" :active=\"index - 1 === (currentActive + props.activeOffset) % itemStates.size\">\n          <span :class=\"nh.be('pointer-inner')\"></span>\n        </slot>\n      </div>\n    </div>\n  </div>\n</template>\n"
    },
    {
      "target": "components/carousel/index.ts",
      "content": "import Carousel from './carousel.vue'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Carousel }\nexport { carouselProps } from './props'\n\nexport type CarouselExposed = ComponentPublicInstance & InstanceType<typeof Carousel>\n\nexport type { CarouselProps, CarouselCProps } from './props'\nexport type { CarouselArrowType, CarouselArrowTrigger, CarouselPointerType } from './symbol'\n"
    },
    {
      "target": "components/carousel/props.ts",
      "content": "import { booleanNumberProp, booleanProp, buildProps, eventProp } from '@pocui/config'\n\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { CarouselArrowTrigger, CarouselArrowType, CarouselPointerType } from './symbol'\n\nexport const carouselProps = buildProps({\n  active: Number,\n  viewSize: Number,\n  vertical: booleanProp,\n  disabled: booleanProp,\n  loop: booleanProp,\n  arrow: String as PropType<CarouselArrowType>,\n  arrowTrigger: String as PropType<CarouselArrowTrigger>,\n  autoplay: booleanNumberProp,\n  pointer: String as PropType<CarouselPointerType>,\n  speed: Number,\n  activeOffset: Number,\n  height: [Number, String],\n  ignoreHover: booleanProp,\n  onChange: eventProp<(active: number) => void>(),\n  onPrev: eventProp<(active: number) => void>(),\n  onNext: eventProp<(active: number) => void>(),\n  onSelect: eventProp<(active: number) => void>()\n})\n\nexport type CarouselProps = ExtractPropTypes<typeof carouselProps>\nexport type CarouselCProps = ConfigurableProps<CarouselProps>\n"
    },
    {
      "target": "components/carousel/symbol.ts",
      "content": "import type { InjectionKey } from 'vue'\n\nexport type CarouselArrowType = 'outside' | 'inside' | 'none'\nexport type CarouselArrowTrigger = 'hover' | 'always'\nexport type CarouselPointerType = 'outside' | 'inside' | 'none'\n\nexport interface ItemState {\n  label: number,\n  width: number,\n  height: number,\n  offset: number\n}\n\nexport interface CarouselState {\n  vertical: boolean,\n  increaseItem: (item: ItemState) => void,\n  decreaseItem: (item: ItemState) => void,\n  isItemActive: (label: number) => boolean,\n  handleSelect: (label: number) => void\n}\n\nexport const CAROUSEL_STATE: InjectionKey<CarouselState> = Symbol('CAROUSEL_STATE')\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/hooks", "@pocui/utils"],
  "registryDependencies": ["carousel.scss", "icon", "resize-observer"],
  "categories": ["display"],
  "meta": { "isReferenceOnly": false }
}
