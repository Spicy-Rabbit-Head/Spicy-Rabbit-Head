{
  "name": "overflow",
  "type": "registry:components",
  "description": "用于在内容宽度/高度超出指定阈值时自动渲染更多等，保持界面整洁。",
  "files": [
    {
      "target": "components/overflow/index.ts",
      "content": "export { default as Overflow } from './overflow'\nexport { overflowProps } from './props'\n\nexport type { OverflowProps, OverflowCProps } from './props'\nexport type { OverflowExposed } from './symbol'\n"
    },
    {
      "target": "components/overflow/overflow.tsx",
      "content": "import { ResizeObserver } from '@/components/resize-observer'\n\nimport { Fragment, SlotsType, computed, createTextVNode, defineComponent, nextTick, onMounted, ref, watch } from 'vue'\n\nimport { emitEvent, useNameHelper, useProps } from '@pocui/config'\nimport { isDefined, isNotNullish, isTrue } from '@pocui/utils'\n\nimport { overflowProps } from './props'\n\nconst TEXT_VNODE = createTextVNode('').type\n\nexport default defineComponent({\n  name: 'Overflow',\n  description:'用于在内容宽度/高度超出指定阈值时自动渲染更多等，保持界面整洁。',\n  categories: ['other'],\n  inheritAttrs: false,\n  props: overflowProps,\n  slots: Object as SlotsType<{\n    default?(props: { item: Record<string, any> | string, index: number }): any,\n    counter(props: { count: number }): any,\n    suffix?(): any\n  }>,\n  emits: [],\n  setup(_props, { attrs, slots, expose }) {\n    const props = useProps('overflow', _props, {\n      items: {\n        default: null,\n        static: true\n      },\n      tag: 'div',\n      attrFlag: false,\n      static: false,\n      maxCount: 0\n    })\n\n    const nh = useNameHelper('overflow')\n    const restCount = ref(0)\n\n    const wrapper = ref<HTMLElement>()\n    const counter = ref<HTMLElement>()\n    const suffix = ref<HTMLElement>()\n\n    const className = computed(() => {\n      return [\n        nh.b(),\n        nh.bs('vars'),\n        {\n          [nh.inc()]: props.inherit,\n          [nh.bm('manual')]: props.maxCount > 0\n        }\n      ]\n    })\n    const hiddenFlag = computed(() => {\n      return props.attrFlag ? (isTrue(props.attrFlag) ? 'hidden' : props.attrFlag) : false\n    })\n\n    watch([() => props.items?.length, () => props.maxCount], () => {\n      nextTick(refresh)\n    })\n\n    expose({ refresh })\n\n    onMounted(refresh)\n\n    function toggleDisplay(el: HTMLElement, show: boolean) {\n      if (hiddenFlag.value) {\n        show ? el.removeAttribute(hiddenFlag.value) : el.setAttribute(hiddenFlag.value, '')\n      } else {\n        if (show) {\n          el.style.display = ''\n        } else {\n          el.style.display = 'none'\n        }\n      }\n    }\n\n    function computeHorizontalMargin(el: HTMLElement) {\n      const style = getComputedStyle(el)\n      const marginLeft = parseFloat(style.marginLeft) || 0\n      const marginRight = parseFloat(style.marginRight) || 0\n\n      return marginLeft + marginRight\n    }\n\n    function computeHorizontalPadding(el: HTMLElement) {\n      const style = getComputedStyle(el)\n      const paddingLeft = parseFloat(style.paddingLeft) || 0\n      const paddingRight = parseFloat(style.paddingRight) || 0\n\n      return paddingLeft + paddingRight\n    }\n\n    function computeOuterWidth(el: HTMLElement) {\n      return el.offsetWidth + computeHorizontalMargin(el)\n    }\n\n    let lastOverflow = false\n    let lastRestCount = restCount.value\n\n    function refresh() {\n      const counterEl = counter.value\n\n      if (!wrapper.value || !counterEl) return\n\n      toggleDisplay(counterEl, true)\n\n      const children = wrapper.value.children\n      const childCount = children.length\n\n      let overflow = false\n\n      if (props.maxCount > 0) {\n        for (let i = 0, len = childCount - 1; i < len; ++i) {\n          const child = children[i] as HTMLElement\n\n          child.style.display = i < props.maxCount ? '' : 'none'\n        }\n\n        if (props.maxCount > childCount - 1) {\n          toggleDisplay(counterEl, false)\n\n          restCount.value = 0\n        } else {\n          restCount.value = childCount - 1 - props.maxCount - (slots.suffix ? 1 : 0)\n          overflow = restCount.value > 0\n        }\n\n        postRefresh(overflow)\n        return\n      }\n\n      const suffixEl = suffix.value\n      const wrapperWidth = wrapper.value.offsetWidth - computeHorizontalPadding(wrapper.value)\n      const childWidths: number[] = []\n\n      let totalWidth = suffixEl ? suffixEl.offsetWidth : 0\n\n      const counterMargin = computeHorizontalMargin(counterEl)\n      const length = childCount - (suffixEl ? 2 : 1)\n\n      for (let i = 0; i < length; ++i) {\n        if (i < 0) continue\n\n        const child = children[i] as HTMLElement\n\n        if (overflow) {\n          toggleDisplay(child, false)\n          continue\n        } else {\n          toggleDisplay(child, true)\n        }\n\n        const childWidth = computeOuterWidth(child)\n\n        totalWidth += childWidth\n        childWidths[i] = childWidth\n\n        if (totalWidth > wrapperWidth) {\n          for (let j = i; j >= 0; --j) {\n            restCount.value = length - j\n            totalWidth -= childWidths[j]\n\n            if (totalWidth + counterEl.offsetWidth + counterMargin <= wrapperWidth || !j) {\n              overflow = true\n              i = j - 1\n\n              if (suffixEl) {\n                suffixEl.style.maxWidth = i === -1 ? `${wrapperWidth - counterEl.offsetWidth}px` : ''\n              }\n\n              break\n            }\n          }\n        }\n      }\n\n      postRefresh(overflow)\n    }\n\n    function postRefresh(overflow: boolean) {\n      if (lastRestCount !== restCount.value) {\n        lastRestCount = restCount.value\n        emitEvent(props.onRestChange, restCount.value)\n      }\n\n      counter.value && toggleDisplay(counter.value, overflow)\n\n      if (overflow !== lastOverflow) {\n        lastOverflow = overflow\n        emitEvent(props.onToggle, overflow)\n      }\n    }\n\n    function syncCounterRef(el?: HTMLElement | null) {\n      if (el) {\n        counter.value = el.nextElementSibling as HTMLElement | undefined\n      } else {\n        counter.value = undefined\n      }\n    }\n\n    return () => {\n      const CustomTag = (props.tag || 'div') as any\n      const itemSlot = slots.default\n      const staticItem = props.static\n      const counterVNode = slots.counter?.({ count: restCount.value })[0] || null\n\n      const renderCounter = () => (counterVNode?.type === TEXT_VNODE ? <span>{counterVNode}</span> : counterVNode)\n      const render = () => (\n        <CustomTag {...attrs} ref={wrapper} class={className.value}>\n          {itemSlot && isDefined(props.items)\n            ? props.items.map((item, index) => {\n              const vnode = itemSlot({\n                item,\n                index\n              })[0]\n\n              if (staticItem) {\n                vnode.key = index\n\n                return vnode\n              }\n\n              return (\n                <ResizeObserver key={index} onResize={refresh}>\n                  {() => vnode}\n                </ResizeObserver>\n              )\n            })\n            : isNotNullish(itemSlot) && itemSlot({} as any)}\n          {counterVNode\n            ? (\n              <Fragment ref={syncCounterRef as any}>{renderCounter()}</Fragment>\n              )\n            : (\n              <span ref={counter} style={{ display: 'inline-block' }}></span>\n              )}\n          {slots.suffix\n            ? (\n              <ResizeObserver onResize={refresh}>\n                <div ref={suffix} class={nh.be('suffix')}>\n                  {slots.suffix()}\n                </div>\n              </ResizeObserver>\n              )\n            : null}\n        </CustomTag>\n      )\n\n      if (import.meta.env.MODE === 'test') {\n        // 很难测试,直接呈现\n        return render()\n      }\n\n      return <ResizeObserver onResize={refresh}>{render()}</ResizeObserver>\n    }\n  }\n})\n"
    },
    {
      "target": "components/overflow/props.ts",
      "content": "import { booleanProp, booleanStringProp, buildProps, eventProp } from '@pocui/config'\n\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\n\nexport const overflowProps = buildProps({\n  items: Array as PropType<any[]>,\n  tag: String,\n  attrFlag: booleanStringProp,\n  static: booleanProp,\n  maxCount: Number,\n  onRestChange: eventProp<(rest: number) => void>(),\n  onToggle: eventProp<(overflow: boolean) => void>()\n})\n\nexport type OverflowProps = ExtractPropTypes<typeof overflowProps>\nexport type OverflowCProps = ConfigurableProps<OverflowProps, 'items'>\n"
    },
    {
      "target": "components/overflow/symbol.ts",
      "content": "import type { ComponentPublicInstance } from 'vue'\n\nexport interface OverflowExposed extends ComponentPublicInstance {\n  refresh: () => void\n}\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/utils"],
  "registryDependencies": ["overflow.scss", "resize-observer"],
  "categories": ["other"],
  "meta": { "isReferenceOnly": false }
}
