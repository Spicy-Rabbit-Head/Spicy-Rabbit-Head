{
  "name": "modal",
  "type": "registry:components",
  "description": "模态框，用来放你想放的东西。",
  "files": [
    {
      "target": "components/modal/index.ts",
      "content": "import { createApp, createVNode, getCurrentInstance, h, nextTick, ref, render } from 'vue'\n\nimport { isClient, noop } from '@pocui/utils'\n\nimport Component from './modal.vue'\n\nimport type { App, AppContext, ComponentPublicInstance } from 'vue'\n\nimport type { ModalProps } from './props'\nimport type { ModalCommonSLot } from './symbol'\n\nexport type ModalOptions = Omit<ModalProps, 'active' | 'transfer' | 'autoRemove'> & {\n  /**\n   * 指定应用上下文，确保模态框使用相同的上下文\n   */\n  appContext: AppContext,\n  /**\n   * 使用默认插槽的另一种方法\n   */\n  renderer: ModalCommonSLot,\n  /**\n   * 使用 header slot 的另一种方法\n   */\n  headerRenderer: ModalCommonSLot,\n  /**\n   * 使用标题槽的另一种方法\n   */\n  titleRenderer: ModalCommonSLot,\n  /**\n   * 使用关闭槽的另一种方法\n   */\n  closeRenderer: ModalCommonSLot,\n  /**\n   * 使用页脚插槽的另一种方法\n   */\n  footerRenderer: ModalCommonSLot\n}\n\nexport function useModal(options: Partial<ModalOptions> = {}): () => Promise<void> {\n  if (!isClient) return noop\n\n  const { appContext, renderer, headerRenderer, titleRenderer, closeRenderer, footerRenderer, onHide, ...props } =\n    options\n\n  const active = ref(false)\n\n  let instance = getCurrentInstance()\n\n  let container: HTMLElement | undefined = document.createElement('div')\n  let app: App | undefined\n\n  if (appContext || instance) {\n    const vnode = createVNode(createModal, null, null)\n\n    vnode.appContext = appContext || instance!.appContext\n    render(vnode, container)\n  } else {\n    app = createApp(createModal)\n    app.mount(container)\n  }\n\n  document.body.appendChild(container)\n\n  // 确保模态显示转换有效\n  nextTick(() => {\n    active.value = true\n  })\n\n  function createModal() {\n    return h(\n      Component,\n      {\n        ...props,\n        active: active.value,\n        transfer: false,\n        autoRemove: false,\n        onHide: Array.isArray(onHide) ? [...onHide, destroy] : onHide ? [onHide, destroy] : destroy\n      },\n      {\n        header: headerRenderer,\n        title: titleRenderer,\n        close: closeRenderer,\n        default: renderer,\n        footer: footerRenderer\n      }\n    )\n  }\n\n  function destroy() {\n    if (instance) {\n      container && render(null, container)\n      instance = null\n    }\n\n    if (app) {\n      app.unmount()\n      app = undefined\n    }\n\n    if (container) {\n      document.body.removeChild(container)\n      container = undefined\n    }\n  }\n\n  return () =>\n    nextTick(() => {\n      active.value = false\n    })\n}\n\nComponent.open = useModal\n\nconst Modal = Component as typeof Component & { open: typeof useModal }\n\nexport { Modal }\nexport { modalProps } from './props'\n\nexport type ModalExposed = ComponentPublicInstance & InstanceType<typeof Component>\n\nexport type { ModalProps, ModalCProps } from './props'\nexport type { ModalSlotParams } from './symbol'\n"
    },
    {
      "target": "components/modal/modal.vue",
      "content": "<script setup lang=\"ts\">\nimport { Button } from '@/components/button'\nimport { Icon } from '@/components/icon'\n\nimport { Masker } from '@/components/masker'\nimport { ResizeObserver } from '@/components/resize-observer'\n\nimport { computed, nextTick, reactive, ref, shallowReadonly, toRef, watch } from 'vue'\n\nimport { createSizeProp, emitEvent, useIcons, useLocale, useNameHelper, useProps } from '@pocui/config'\nimport { useMoving } from '@pocui/hooks'\nimport { getGlobalCount, isNullish, isPromise, isValidNumber, toNumber } from '@pocui/utils'\n\nimport { modalProps, positionProp } from './props'\n\nimport type { MaskerExposed } from '@/components/masker'\nimport type { ModalCommonSLot } from './symbol'\n\ndefineOptions({\n  name: 'Modal',\n  description:'模态框，用来放你想放的东西。',\n  categories: ['feedback']\n})\n\nconst nh = useNameHelper('modal')\n\nconst _props = defineProps(modalProps)\nconst props = useProps('modal', _props, {\n  locale: null,\n  transfer: false,\n  active: {\n    default: false,\n    static: true\n  },\n  width: positionProp,\n  height: positionProp,\n  top: positionProp,\n  left: positionProp,\n  right: positionProp,\n  bottom: positionProp,\n  title: '',\n  closable: true,\n  inner: false,\n  maskClose: true,\n  modalClass: null,\n  modalStyle: null,\n  noFooter: false,\n  hideMask: false,\n  draggable: false,\n  resizable: false,\n  onBeforeClose: {\n    default: null,\n    isFunc: true\n  },\n  loading: false,\n  minWidth: 150,\n  minHeight: 120,\n  transitionName: () => nh.ns('ease'),\n  confirmText: null,\n  cancelText: null,\n  autoRemove: false,\n  confirmType: 'primary',\n  cancelType: 'default',\n  actionSize: createSizeProp('small'),\n  undivided: false,\n  xOffset: 0,\n  yOffset: 0\n})\n\nconst emit = defineEmits(['update:active'])\n\nconst slots = defineSlots<{\n  header: ModalCommonSLot,\n  title: ModalCommonSLot,\n  close: ModalCommonSLot,\n  default: ModalCommonSLot,\n  footer: ModalCommonSLot\n}>()\n\nconst locale = useLocale('modal', toRef(props, 'locale'))\nconst icons = useIcons()\n\nfunction isSpecified(value?: string | number) {\n  return !isNullish(value) && value !== 'auto'\n}\n\nfunction normalizeStyle(value?: string | number) {\n  return isValidNumber(value, true) ? `${toNumber(value)}px` : isNullish(value) ? 'auto' : String(value)\n}\n\nconst currentActive = ref(props.active)\nconst rect = reactive({\n  top: normalizeStyle(props.top),\n  right: normalizeStyle(props.right),\n  bottom: normalizeStyle(props.bottom),\n  left: normalizeStyle(props.left),\n  width: normalizeStyle(props.width),\n  height: normalizeStyle(props.height)\n})\nconst maskerRect = reactive({\n  width: 0,\n  height: 0\n})\nconst modalRect = reactive({\n  width: 0,\n  height: 0\n})\n\nconst idIndex = `${getGlobalCount()}`\nconst transformed = ref(false)\n\nconst masker = ref<MaskerExposed>()\nconst wrapper = ref<HTMLElement>()\nconst footer = ref<HTMLElement>()\n\nconst uselessTop = computed(() => {\n  return props.top === 'auto' && isSpecified(props.bottom) && isSpecified(props.height)\n})\nconst uselessLeft = computed(() => {\n  return props.left === 'auto' && isSpecified(props.right) && isSpecified(props.width)\n})\n\nconst { target: header, moving: dragging } = useMoving({\n  capture: false,\n  onStart: (state, event) => {\n    if (!wrapper.value || !props.draggable || event.button > 0) {\n      return false\n    }\n\n    transferRect(false)\n\n    transformed.value = true\n    state.xStart = parseFloat(rect.left)\n    state.yStart = parseFloat(rect.top)\n\n    emitEvent(props.onDragStart, {\n      top: state.yStart,\n      left: state.xStart\n    })\n  },\n  onMove: state => {\n    rect.left = `${state.xEnd}px`\n    rect.top = `${state.yEnd}px`\n\n    emitEvent(props.onDragMove, {\n      top: state.yEnd,\n      left: state.xEnd\n    })\n  },\n  onEnd: state => {\n    emitEvent(props.onDragEnd, {\n      top: state.yEnd,\n      left: state.xEnd\n    })\n  }\n})\n\nconst { target: resizer, moving: resizing } = useMoving({\n  onStart: (state, event) => {\n    if (!wrapper.value || !props.resizable || event.button > 0) {\n      return false\n    }\n\n    transferRect()\n\n    let minHeight = 32\n\n    if (header.value) {\n      minHeight += header.value.offsetHeight\n    }\n\n    if (footer.value) {\n      minHeight += footer.value.offsetHeight\n    }\n\n    transformed.value = true\n    state.xStart = parseFloat(rect.width)\n    state.yStart = parseFloat(rect.height)\n    state.minHeight = Math.max(minHeight, props.minHeight)\n\n    emitEvent(props.onResizeStart, {\n      width: state.xStart,\n      height: state.yStart\n    })\n  },\n  onMove: state => {\n    const width = Math.max(props.minWidth, state.xEnd, 32)\n    const height = Math.max(state.minHeight as number, state.yEnd)\n\n    rect.width = `${width}px`\n    rect.height = `${height}px`\n\n    emitEvent(props.onResizeMove, {\n      width,\n      height\n    })\n  },\n  onEnd: state => {\n    const width = Math.max(props.minWidth, state.xEnd, 32)\n    const height = Math.max(state.minHeight as number, state.yEnd)\n\n    emitEvent(props.onResizeEnd, {\n      width,\n      height\n    })\n  }\n})\n\nconst className = computed(() => {\n  return [\n    nh.b(),\n    nh.bs('vars'),\n    {\n      [nh.inc()]: props.inherit,\n      [nh.bm('inner')]: props.inner,\n      [nh.bm('draggable')]: props.draggable,\n      [nh.bm('resizable')]: props.resizable,\n      [nh.bm('undivided')]: props.undivided\n    }\n  ]\n})\nconst wrapperClass = computed(() => {\n  return [\n    nh.be('wrapper'),\n    {\n      [nh.bem('wrapper', 'closable')]: props.closable,\n      [nh.bem('wrapper', 'dragging')]: dragging.value,\n      [nh.bem('wrapper', 'resizing')]: resizing.value\n    },\n    props.modalClass\n  ]\n})\nconst transform = computed(() => {\n  const transforms: string[] = []\n\n  if (props.xOffset) {\n    transforms.push(`translateX(${normalizeStyle(props.xOffset)})`)\n  }\n\n  if (props.yOffset) {\n    transforms.push(`translateY(${normalizeStyle(props.yOffset)})`)\n  }\n\n  if (transforms.length) {\n    transforms.push('translateZ(0)')\n  }\n\n  return transforms.length ? transforms.join(' ') : undefined\n})\nconst wrapperStyle = computed(() => {\n  return [\n    props.modalStyle,\n    {\n      ...rect,\n      height: rect.height !== 'auto' ? rect.height : undefined,\n      transform: transform.value\n    }\n  ]\n})\nconst transformOrigin = computed(() => {\n  const origin = {\n    x: '50%',\n    y: '50%'\n  }\n\n  if (transformed.value) {\n    origin.x = `${parseFloat(rect.left) + 0.5 * modalRect.width}px`\n    origin.y = `${parseFloat(rect.top) + 0.5 * modalRect.height}px`\n  } else {\n    if (uselessTop.value) {\n      origin.y = `calc(100% - ${parseFloat(rect.bottom) + 0.5 * parseFloat(rect.height)}px)`\n    } else if (isSpecified(props.top)) {\n      const top = parseFloat(rect.top)\n\n      if (isSpecified(props.height)) {\n        origin.y = `${top + 0.5 * parseFloat(rect.height)}px`\n      } else if (isSpecified(props.bottom)) {\n        const bottom = parseFloat(rect.bottom)\n        const height = maskerRect.height - top - bottom\n\n        origin.y = `${top + 0.5 * height}px`\n      } else {\n        origin.y = `${parseFloat(rect.top) + 0.5 * modalRect.height}px`\n      }\n    }\n\n    if (uselessLeft.value) {\n      origin.x = `calc(100% - ${parseFloat(rect.right) + 0.5 * parseFloat(rect.width)}px)`\n    } else if (isSpecified(props.left)) {\n      const left = parseFloat(rect.left)\n\n      if (isSpecified(props.width)) {\n        origin.x = `${left + 0.5 * parseFloat(rect.width)}px`\n      } else if (isSpecified(props.right)) {\n        const right = parseFloat(rect.right)\n        const width = maskerRect.width - left - right\n\n        origin.x = `${left + 0.5 * width}px`\n      } else {\n        origin.x = `${parseFloat(rect.left) + 0.5 * modalRect.width}px`\n      }\n    }\n  }\n\n  return `${origin.x} ${origin.y}`\n})\nconst hasTitle = computed(() => {\n  return !!(slots.header || slots.title || props.title)\n})\nconst titleId = computed(() => `${nh.bs(idIndex)}__title`)\nconst bodyId = computed(() => `${nh.bs(idIndex)}__body`)\n\nfor (const style of Object.keys(rect) as Array<keyof typeof rect>) {\n  watch(\n    () => props[style],\n    value => {\n      rect[style] = normalizeStyle(value)\n    }\n  )\n}\n\nwatch(\n  () => props.active,\n  value => {\n    currentActive.value = value\n  }\n)\nwatch(currentActive, value => {\n  props.hideMask && value && handleResize()\n})\nwatch([() => props.top, () => props.bottom, () => props.height], () => {\n  currentActive.value && nextTick(computeTop)\n})\nwatch([() => props.left, () => props.right, () => props.width], () => {\n  currentActive.value && nextTick(computeLeft)\n})\n\nconst handleResize = () => {\n  if (currentActive.value && !transformed.value) {\n    nextTick(() => {\n      computeTop()\n      computeLeft()\n    })\n  }\n\n  if (masker.value?.wrapper) {\n    maskerRect.width = masker.value.wrapper.offsetWidth\n    maskerRect.height = masker.value.wrapper.offsetHeight\n  }\n}\n\ndefineExpose({\n  dragging,\n  resizing,\n  titleId,\n  bodyId,\n  wrapper,\n  header,\n  footer,\n  resizer,\n  handleResize,\n  handleConfirm,\n  handleCancel,\n  handleClose\n})\n\nconst slotParams = shallowReadonly(\n  reactive({\n    dragging,\n    resizing,\n    handleResize,\n    handleConfirm,\n    handleCancel,\n    handleClose\n  })\n)\n\nfunction setActive(active: boolean) {\n  if (currentActive.value === active) return\n\n  currentActive.value = active\n\n  emit('update:active', active)\n  emitEvent(props.onToggle, active)\n}\n\nfunction findPositionalParent() {\n  if (!wrapper.value) return document.body\n\n  let parentElement = wrapper.value.parentElement as HTMLElement\n\n  while (parentElement && parentElement !== document.body) {\n    if (getComputedStyle(parentElement).position !== 'static') {\n      return parentElement\n    }\n\n    parentElement = parentElement.parentElement as HTMLElement\n  }\n\n  return parentElement\n}\n\nfunction computeTop() {\n  if (!wrapper.value || props.top !== 'auto' || uselessTop.value) return\n\n  const currentHeight = wrapper.value.offsetHeight\n\n  if (props.inner) {\n    rect.top = `${(findPositionalParent().offsetHeight - currentHeight) / 2}px`\n  } else {\n    rect.top = `${(window.innerHeight - currentHeight) / 2 - 20}px`\n  }\n}\n\nfunction computeLeft() {\n  if (!wrapper.value || props.left !== 'auto' || uselessLeft.value) return\n\n  const currentWidth = wrapper.value.offsetWidth\n\n  if (props.inner) {\n    rect.left = `${(findPositionalParent().offsetWidth - currentWidth) / 2}px`\n  } else {\n    rect.left = `${(window.innerWidth - currentWidth) / 2}px`\n  }\n}\n\nfunction transferRect(withSize = true) {\n  if (!wrapper.value) return\n\n  const { offsetWidth, offsetHeight, offsetTop, offsetLeft } = wrapper.value\n\n  // 如果使用顶部/底部或右侧/左侧来指定大小，\n  // 此处需要强制传输以使用偏移大小\n  if (!withSize && ((!uselessTop.value && props.bottom !== 'auto') || (!uselessLeft.value && props.right !== 'auto'))) {\n    withSize = true\n  }\n\n  Object.assign(\n    rect,\n    {\n      top: `${offsetTop}px`,\n      right: 'auto',\n      bottom: 'auto',\n      left: `${offsetLeft}px`\n    },\n    withSize\n      ? {\n          width: `${offsetWidth}px`,\n          height: `${offsetHeight}px`\n        }\n      : {}\n  )\n}\n\nfunction handleConfirm() {\n  handleClose(true)\n  emitEvent(props.onConfirm)\n}\n\nfunction handleCancel() {\n  handleClose(false)\n  emitEvent(props.onCancel)\n}\n\nasync function handleClose(isConfirm = false) {\n  let result: unknown = true\n\n  if (typeof props.onBeforeClose === 'function') {\n    result = props.onBeforeClose(isConfirm)\n\n    if (isPromise(result)) {\n      result = await result\n    }\n  }\n\n  if (result !== false) {\n    await nextTick(() => {\n      setActive(false)\n      emitEvent(props.onClose)\n    })\n  }\n\n  return result\n}\n\nfunction handleShow() {\n  emitEvent(props.onShow)\n}\n\nfunction handleHide() {\n  emitEvent(props.onHide)\n}\n\nfunction handleMaskClose() {\n  if (props.maskClose) {\n    return handleClose(false)\n  }\n}\n\nfunction handleModalResize(entry: ResizeObserverEntry) {\n  const box = entry.borderBoxSize?.[0]\n\n  if (box) {\n    modalRect.width = box.inlineSize\n    modalRect.height = box.blockSize\n  } else {\n    modalRect.width = entry.contentRect.width\n    modalRect.height = entry.contentRect.height\n  }\n}\n</script>\n\n<template>\n  <Masker\n    ref=\"masker\"\n    v-model:active=\"currentActive\"\n    :inherit=\"props.inherit\"\n    :class=\"className\"\n    :inner=\"props.inner\"\n    :transition-name=\"props.transitionName\"\n    :closable=\"props.maskClose\"\n    :disabled=\"props.hideMask\"\n    :on-before-close=\"handleMaskClose\"\n    :transfer=\"props.transfer\"\n    :auto-remove=\"props.autoRemove\"\n    @show=\"handleShow\"\n    @hide=\"handleHide\"\n    @resize=\"handleResize\"\n  >\n    <template #default=\"{ show }\">\n      <section v-show=\"show\" :class=\"nh.be('transform')\" :style=\"{ transformOrigin }\">\n        <ResizeObserver @resize=\"handleModalResize\">\n          <div\n            ref=\"wrapper\"\n            :class=\"wrapperClass\"\n            role=\"dialog\"\n            :style=\"wrapperStyle\"\n            :aria-modal=\"show ? 'true' : undefined\"\n            :aria-labelledby=\"titleId\"\n            :aria-describedby=\"bodyId\"\n          >\n            <div v-if=\"hasTitle\" ref=\"header\" :class=\"nh.be('header')\">\n              <slot name=\"header\" v-bind=\"slotParams\">\n                <div :id=\"titleId\" :class=\"nh.be('title')\">\n                  <slot name=\"title\" v-bind=\"slotParams\">\n                    {{ props.title }}\n                  </slot>\n                </div>\n                <button\n                  v-if=\"props.closable\"\n                  type=\"button\"\n                  :class=\"nh.be('close')\"\n                  @pointerdown.stop\n                  @mousedown.stop\n                  @touchstart.stop\n                  @click=\"handleClose(false)\"\n                >\n                  <slot name=\"close\" v-bind=\"slotParams\">\n                    <Icon v-bind=\"icons.close\" :scale=\"+(icons.close.scale || 1) * 1.2\" label=\"close\"></Icon>\n                  </slot>\n                </button>\n              </slot>\n            </div>\n            <div\n              :id=\"bodyId\"\n              :class=\"nh.be('content')\"\n              :style=\"{\n                overflow: resizing ? 'hidden' : undefined\n              }\"\n            >\n              <slot v-bind=\"slotParams\"></slot>\n            </div>\n            <div v-if=\"!props.noFooter\" ref=\"footer\" :class=\"nh.be('footer')\">\n              <slot name=\"footer\" v-bind=\"slotParams\">\n                <Button\n                  :class=\"[nh.be('button'), nh.bem('button', 'cancel')]\"\n                  inherit\n                  text\n                  :type=\"props.cancelType\"\n                  :size=\"props.actionSize\"\n                  @click=\"handleCancel\"\n                >\n                  {{ props.cancelText || locale.cancel }}\n                </Button>\n                <Button\n                  :class=\"[nh.be('button'), nh.bem('button', 'confirm')]\"\n                  inherit\n                  :type=\"props.confirmType\"\n                  :size=\"props.actionSize\"\n                  :loading=\"props.loading\"\n                  @click=\"handleConfirm\"\n                >\n                  {{ props.confirmText || locale.confirm }}\n                </Button>\n              </slot>\n            </div>\n            <div v-if=\"props.resizable\" ref=\"resizer\" :class=\"nh.be('resizer')\"></div>\n          </div>\n        </ResizeObserver>\n      </section>\n    </template>\n  </Masker>\n</template>\n"
    },
    {
      "target": "components/modal/props.ts",
      "content": "import {\n  booleanProp,\n  booleanStringProp,\n  buildProps,\n  classProp,\n  eventProp,\n  localeProp,\n  sizeProp,\n  styleProp\n} from '@pocui/config'\n\nimport type { ButtonType } from '@/components/button'\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { PositionPayload, SizePayload } from './symbol'\n\nconst positionType = [Number, String]\n\nexport const positionValidator = (value: string | number) => {\n  return value === 'auto' || !Number.isNaN(parseFloat(value as string))\n}\nexport const positionProp = {\n  default: 'auto' as const,\n  validator: positionValidator\n}\n\nexport const modalProps = buildProps({\n  locale: localeProp('modal'),\n  transfer: booleanStringProp,\n  active: booleanProp,\n  width: positionType,\n  height: positionType,\n  top: positionType,\n  left: positionType,\n  right: positionType,\n  bottom: positionType,\n  title: String,\n  closable: booleanProp,\n  inner: booleanProp,\n  maskClose: booleanProp,\n  modalClass: classProp,\n  modalStyle: styleProp,\n  noFooter: booleanProp,\n  hideMask: booleanProp,\n  draggable: booleanProp,\n  resizable: booleanProp,\n  onBeforeClose: Function as PropType<(isConfirm: boolean) => any>,\n  loading: booleanProp,\n  minWidth: Number,\n  minHeight: Number,\n  transitionName: String,\n  confirmText: String,\n  cancelText: String,\n  actionSize: sizeProp,\n  autoRemove: booleanProp,\n  confirmType: String as PropType<ButtonType>,\n  cancelType: String as PropType<ButtonType>,\n  undivided: booleanProp,\n  xOffset: positionType,\n  yOffset: positionType,\n  onToggle: eventProp<(active: boolean) => void>(),\n  onConfirm: eventProp(),\n  onCancel: eventProp(),\n  onClose: eventProp(),\n  onShow: eventProp(),\n  onHide: eventProp(),\n  onDragStart: eventProp<(position: PositionPayload) => void>(),\n  onDragMove: eventProp<(position: PositionPayload) => void>(),\n  onDragEnd: eventProp<(position: PositionPayload) => void>(),\n  onResizeStart: eventProp<(size: SizePayload) => void>(),\n  onResizeMove: eventProp<(size: SizePayload) => void>(),\n  onResizeEnd: eventProp<(size: SizePayload) => void>()\n})\n\nexport type ModalProps = ExtractPropTypes<typeof modalProps>\nexport type ModalCProps = ConfigurableProps<ModalProps, never, 'onBeforeClose'>\n"
    },
    {
      "target": "components/modal/symbol.ts",
      "content": "export interface PositionPayload {\n  top: number,\n  left: number\n}\n\nexport interface SizePayload {\n  width: number,\n  height: number\n}\n\nexport interface ModalSlotParams {\n  dragging: boolean,\n  resizing: boolean,\n  handleResize: () => void,\n  handleConfirm: () => void,\n  handleCancel: () => void,\n  handleClose: (isConfirm?: boolean) => Promise<unknown>\n}\n\nexport type ModalCommonSLot = (params: ModalSlotParams) => any\n"
    }
  ],
  "dependencies": ["vue", "@pocui/utils", "@pocui/config", "@pocui/hooks"],
  "registryDependencies": ["modal.scss", "button", "icon", "masker", "resize-observer"],
  "categories": ["feedback"],
  "meta": { "isReferenceOnly": false }
}
