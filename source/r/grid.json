{
  "name": "grid",
  "type": "registry:component",
  "description": "二维栅格布局组件，基于行和列来定义区域块，用于快捷地创建稳健的纵横交错布局。",
  "files": [
    {
      "target": "components/grid/cell.ts",
      "content": "import { computed, defineComponent, h, inject, provide, reactive, watch } from 'vue'\n\nimport { useNameHelper, useProps } from '@pocui/config'\nimport { has, isDefined, isNumber } from '@pocui/utils'\n\nimport { breakPoints, currentBreakPoint } from './helper'\nimport { cellProps } from './props'\nimport { GRID_STATE } from './symbol'\n\nimport type { BreakPoint } from './helper'\nimport type { CSSProperties } from 'vue'\n\nimport type { ClassType } from '@pocui/config'\n\nexport default defineComponent({\n  name: \"Cell\",\n  description:\n    \"栅格子项，实现灵活的内容区域划分。\",\n  categories: [\"display\"],\n  props: cellProps,\n  setup(_props, { slots }) {\n    const props = useProps(\"cell\", _props, {\n      tag: \"div\",\n      top: \"auto\",\n      left: \"auto\",\n      width: null,\n      height: 1,\n      right: \"\",\n      bottom: \"\",\n      xs: null,\n      sm: null,\n      md: null,\n      lg: null,\n      xl: null,\n      xxl: null,\n      useFlex: null,\n    });\n\n    const gridState = inject(GRID_STATE, null);\n    const nh = useNameHelper(\"cell\");\n\n    provide(GRID_STATE, null!);\n\n    const layoutState = reactive({\n      top: props.top,\n      right: props.right,\n      bottom: props.bottom,\n      left: props.left,\n      width: props.width,\n      height: props.height,\n    });\n    const layoutKeys = Object.keys(layoutState) as (\n      | \"top\"\n      | \"right\"\n      | \"bottom\"\n      | \"left\"\n      | \"width\"\n      | \"height\"\n    )[];\n\n    const defaultWidth = computed(() => {\n      if (isDefined(props.width)) {\n        return props.width;\n      }\n\n      return gridState?.columns && typeof gridState.columns === \"number\"\n        ? gridState.columns\n        : 1;\n    });\n\n    watch(\n      currentBreakPoint,\n      (value) => {\n        const matchSize = queryBreakPointOptions(value);\n\n        if (matchSize) {\n          if (isNumber(matchSize)) {\n            layoutKeys.forEach((key) => {\n              layoutState[key] = props[key] as any;\n            });\n\n            layoutState.width = matchSize;\n          } else {\n            layoutKeys.forEach((key) => {\n              layoutState[key] = has(matchSize, key)\n                ? matchSize[key]\n                : (props[key] as any);\n            });\n\n            layoutState.width = layoutState.width ?? defaultWidth.value;\n          }\n        } else {\n          layoutKeys.forEach((key) => {\n            layoutState[key] = props[key] as any;\n          });\n\n          layoutState.width = defaultWidth.value;\n        }\n      },\n      { immediate: true },\n    );\n\n    const className = computed(() => {\n      const cellFlex = props.useFlex !== false &&\n        (props.useFlex || gridState?.cellFlex) && {\n          ...(gridState?.cellFlex || {}),\n          ...(props.useFlex\n            ? props.useFlex === true\n              ? {\n                  justify: \"start\",\n                  align: \"top\",\n                }\n              : props.useFlex\n            : {}),\n        };\n      const className: ClassType = {\n        [nh.b()]: true,\n        [nh.in()]: gridState || props.inherit,\n        [nh.bm(\"flex\")]: cellFlex,\n      };\n\n      if (cellFlex) {\n        if (cellFlex.justify) className[nh.bm(cellFlex.justify)] = true;\n        if (cellFlex.align) className[nh.bm(cellFlex.align)] = true;\n      }\n\n      return className;\n    });\n    const style = computed(() => {\n      const style: CSSProperties = {};\n\n      const topSet = isPositionSet(layoutState.top);\n      const rightSet = isPositionSet(layoutState.right);\n      const bottomSet = isPositionSet(layoutState.bottom);\n      const leftSet = isPositionSet(layoutState.left);\n\n      if (topSet && bottomSet) {\n        style.gridRowStart = parsePosition(layoutState.top);\n        style.gridRowEnd = parsePosition(layoutState.bottom);\n      } else if (topSet) {\n        style.gridRowStart = parsePosition(layoutState.top);\n        style.gridRowEnd = `span ${layoutState.height}`;\n      } else if (bottomSet) {\n        style.gridRowStart = `span ${layoutState.height}`;\n        style.gridRowEnd = parsePosition(layoutState.bottom);\n      } else {\n        style.gridRowEnd = `span ${layoutState.height}`;\n      }\n\n      if (leftSet && rightSet) {\n        style.gridColumnStart = parsePosition(layoutState.left);\n        style.gridColumnEnd = parsePosition(layoutState.right);\n      } else if (leftSet) {\n        style.gridColumnStart = parsePosition(layoutState.left);\n        style.gridColumnEnd = `span ${layoutState.width}`;\n      } else if (rightSet) {\n        style.gridColumnStart = `span ${layoutState.width}`;\n        style.gridColumnEnd = parsePosition(layoutState.right);\n      } else {\n        style.gridColumnStart = `span ${layoutState.width}`;\n      }\n\n      return style;\n    });\n\n    function isPositionSet(value: number | string) {\n      return value === 0 || (value && value !== \"auto\");\n    }\n\n    function parsePosition(value: number | string) {\n      return typeof value === \"number\" ? value + 1 : value;\n    }\n\n    function queryBreakPointOptions(breakPoint: BreakPoint) {\n      const index = breakPoints.findIndex((v) => v === breakPoint);\n\n      if (~index) {\n        for (let i = index; i >= 0; --i) {\n          if (isDefined(props[breakPoints[i]])) {\n            return props[breakPoints[i]];\n          }\n        }\n      }\n\n      return null;\n    }\n\n    return () =>\n      h(\n        props.tag || \"div\",\n        {\n          class: className.value,\n          style: style.value,\n        },\n        {\n          default: () => slots.default?.(),\n        },\n      );\n  },\n});\n"
    },
    {
      "target": "components/grid/grid.ts",
      "content": "import { computed, defineComponent, h, provide, reactive, toRef } from 'vue'\n\nimport { useNameHelper, useProps } from '@pocui/config'\nimport { isString } from '@pocui/utils'\n\nimport { gridProps } from './props'\n\nimport { GRID_STATE } from './symbol'\n\nimport type { CSSProperties } from 'vue'\n\nimport type { GridAlign, GridJustify, LayoutProp } from './symbol'\n\nconst numberRE = /^\\d+$/\n\nconst justifyList = Object.freeze<GridJustify[]>([\n  'start',\n  'end',\n  'center',\n  'space-around',\n  'space-between',\n  'space-evenly'\n])\nconst alignList = Object.freeze<GridAlign[]>(['top', 'middle', 'bottom', 'stretch'])\n\nexport default defineComponent({\n  name: 'Grid',\n  description:'二维栅格布局组件，基于行和列来定义区域块，用于快捷地创建稳健的纵横交错布局。',\n  categories: ['layout'],\n  props: gridProps,\n  setup(_props, { slots }) {\n    const props = useProps('grid', _props, {\n      tag: 'div',\n      gap: 0,\n      rows: 'none',\n      columns: 24,\n      autoRows: 'auto',\n      autoColumns: 'auto',\n      dense: false,\n      justify: {\n        default: 'start',\n        validator: value => justifyList.includes(value)\n      },\n      align: {\n        default: 'stretch',\n        validator: value => alignList.includes(value)\n      },\n      cellFlex: false\n    })\n\n    const nh = useNameHelper('grid')\n\n    const className = computed(() => {\n      return {\n        [nh.b()]: true,\n        [nh.bm(props.justify)]: true,\n        [nh.in()]: props.inherit,\n        [nh.bm(props.align)]: props.align !== 'stretch',\n        [nh.bm('dense')]: props.dense\n      }\n    })\n    const style = computed(() => {\n      const style: CSSProperties = {}\n\n      if (props.gap) {\n        style.gap = Array.isArray(props.gap) ? `${props.gap[0]}px ${props.gap[1]}px` : `${props.gap}px`\n      }\n\n      style.gridTemplateColumns = parseSizeLayout(props.columns)\n\n      if (props.rows !== 'none') {\n        style.gridTemplateRows = parseSizeLayout(props.rows)\n      }\n\n      if (props.autoRows !== 'auto') {\n        style.gridAutoRows = parseAutoLayout(props.autoRows)\n      }\n\n      if (props.autoColumns !== 'auto') {\n        style.gridAutoColumns = parseAutoLayout(props.autoColumns)\n      }\n\n      return style\n    })\n    const cellFlex = computed(() => {\n      if (props.cellFlex === true) {\n        return {\n          justify: 'start',\n          align: 'top'\n        } as const\n      } else if (props.cellFlex) {\n        return {\n          justify: 'start',\n          align: 'top',\n          ...props.cellFlex\n        } as const\n      }\n\n      return false\n    })\n\n    provide(\n      GRID_STATE,\n      reactive({\n        cellFlex,\n        columns: toRef(props, 'columns')\n      })\n    )\n\n    function parseSizeLayout(value: LayoutProp) {\n      if (typeof value === 'number') {\n        return `repeat(${value}, 1fr)`\n      }\n\n      return getLayoutValue(value)\n    }\n\n    function parseAutoLayout(value: LayoutProp) {\n      if (typeof value === 'number') {\n        return `${value}fr`\n      }\n\n      return getLayoutValue(value)\n    }\n\n    function getLayoutValue(value: LayoutProp) {\n      if (typeof value === 'string') {\n        return numberRE.test(value.trim()) ? `repeat(${value}, 1fr)` : value\n      }\n\n      if (Array.isArray(value)) {\n        return value\n          .map(item => {\n            if (typeof item === 'number') {\n              return `${item}fr`\n            }\n\n            if (isString(item)) {\n              return numberRE.test(item.trim()) ? `${item}fr` : item\n            }\n\n            return item\n          })\n          .join(' ')\n      }\n\n      return value\n    }\n\n    return () =>\n      h(\n        props.tag || 'div',\n        {\n          class: className.value,\n          style: style.value\n        },\n        {\n          default: () => slots.default?.()\n        }\n      )\n  }\n})\n"
    },
    {
      "target": "components/grid/helper.ts",
      "content": "import { ref } from 'vue'\n\nimport { isClient } from '@pocui/utils'\n\nexport type BreakPoint = 'xs' | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'\n\nexport const breakPoints = Object.freeze<BreakPoint[]>(['xs', 'sm', 'md', 'lg', 'xl', 'xxl'])\nexport const currentBreakPoint = ref<BreakPoint>('xs')\n\nif (isClient) {\n  const computedStyle = getComputedStyle(document.documentElement)\n  const queryMap = {} as Record<BreakPoint, MediaQueryList>\n\n  breakPoints.forEach(point => {\n    const media = computedStyle.getPropertyValue(`--poc-break-point-${point}`).trim()\n    const query = matchMedia(`only screen and ${media}`)\n\n    query.addEventListener('change', handleBreakPointChange)\n    queryMap[point] = query\n  })\n\n  const queryEntries = Object.entries(queryMap).reverse() as [BreakPoint, MediaQueryList][]\n\n  function handleBreakPointChange() {\n    for (const [point, query] of queryEntries) {\n      if (query.matches) {\n        currentBreakPoint.value = point\n        break\n      }\n    }\n  }\n\n  handleBreakPointChange()\n}\n"
    },
    {
      "target": "components/grid/index.ts",
      "content": "import Grid from './grid'\n\nimport type { ComponentPublicInstance } from 'vue'\n\nexport { Grid }\nexport { gridProps } from './props'\n\nexport type GridExposed = ComponentPublicInstance & InstanceType<typeof Grid>\n\nexport { currentBreakPoint } from './helper'\nexport type { GridProps, GridCProps } from './props'\nexport type { GridJustify, GridAlign, CellFlex } from './symbol'\n"
    },
    {
      "target": "components/grid/props.ts",
      "content": "import { booleanProp, buildProps } from '@pocui/config'\n\nimport type { ConfigurableProps } from '@pocui/config'\n\nimport type { ExtractPropTypes, PropType } from 'vue'\nimport type { CellFlex, CellOptions, GridAlign, GridJustify, LayoutProp } from './symbol'\n\nconst layoutProp = [Number, String, Array] as PropType<LayoutProp>\n\nexport const gridProps = buildProps({\n  tag: String,\n  gap: [Number, Array] as PropType<number | number[]>,\n  rows: layoutProp,\n  columns: layoutProp,\n  autoRows: layoutProp,\n  autoColumns: layoutProp,\n  dense: booleanProp,\n  justify: String as PropType<GridJustify>,\n  align: String as PropType<GridAlign>,\n  cellFlex: {\n    type: [Boolean, Object] as PropType<boolean | Partial<CellFlex>>,\n    default: null\n  }\n})\n\nexport type GridProps = ExtractPropTypes<typeof gridProps>\nexport type GridCProps = ConfigurableProps<GridProps>\n\nconst mediaProp = [Number, Object] as PropType<CellOptions>\n\nexport const cellProps = buildProps({\n  tag: String,\n  top: [Number, String],\n  left: [Number, String],\n  width: Number,\n  height: Number,\n  right: [Number, String],\n  bottom: [Number, String],\n  xs: mediaProp,\n  sm: mediaProp,\n  md: mediaProp,\n  lg: mediaProp,\n  xl: mediaProp,\n  xxl: mediaProp,\n  useFlex: {\n    type: [Boolean, Object] as PropType<boolean | Partial<CellFlex>>,\n    default: null\n  }\n})\n\nexport type CellProps = ExtractPropTypes<typeof cellProps>\nexport type CellCProps = ConfigurableProps<CellProps>\n"
    },
    {
      "target": "components/grid/symbol.ts",
      "content": "import type { InjectionKey } from 'vue'\n\nexport type LayoutProp = number | string | (number | string)[]\n\nexport type GridJustify =\n  | 'start'\n  | 'end'\n  | 'center'\n  | 'space-around'\n  | 'space-between'\n  | 'space-evenly'\nexport type GridAlign = 'top' | 'middle' | 'bottom' | 'stretch'\n\nexport interface CellFlex {\n  justify: 'start' | 'end' | 'center' | 'space-around' | 'space-between' | 'space-evenly',\n  align: 'top' | 'middle' | 'bottom' | 'stretch'\n}\n\nexport interface GridState {\n  cellFlex: CellFlex | false,\n  columns: LayoutProp\n}\n\nexport interface CellOptions {\n  top?: number | string,\n  left?: number | string,\n  width?: number,\n  height?: number,\n  right?: number | string,\n  bottom?: number | string\n}\n\nexport const GRID_STATE: InjectionKey<GridState> = Symbol('GRID_STATE')\n"
    }
  ],
  "dependencies": ["vue", "@pocui/config", "@pocui/utils"],
  "registryDependencies": ["grid.scss"],
  "categories": ["layout"],
  "meta": { "isReferenceOnly": false }
}
